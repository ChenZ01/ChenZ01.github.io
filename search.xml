<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello, 2019!]]></title>
    <url>%2F2019%2F01%2F01%2FHello-2019%2F</url>
    <content type="text"><![CDATA[Goodbye, 2018! Hello, 2019! 20186月，第一次买了Office 3659月，进入江苏省丹阳高级中学拔尖创新人才预备班10月，第一次月考达到巅峰11月，胆大无比地向年纪主任要停课的时间11月，第一次NOIP提高组11月，NOIP后一天，期中考试爆炸12月，自己与一等奖的线只差了5分12月，某OIer的退役感想令我愣了半天12月，数学第一次没有涂答题卡12月，压抑不住自己对日本文学的好奇，偷偷地去买了本《罗生门》12月，第一次去看DC的电影Amber Heard小姐姐真好看12月，抛弃了Visual Studio，正式加入Visual Studio Code大军12月，可爱的老同学给我买了一份Cytus II 2019?三句话，继往开来 人生不如一行波德莱尔 艺术至上？学术至上？我希望做一个学术至上的人，但在2018，很显然并不是 人生悲剧的第一幕始于成为父母子女。遗传、境遇、偶然，掌握我们命运的，终究还是这三种东西 18年提高组，真是苦涩啊这是我第一次被“偶然”击败，月考的没涂答题卡是第二次震惊于自己的不佳状态，对不起，让你们失望了看到高二学长AFO，自己呢？声嘶力竭地吼着”Always Firmly in OI”，你有实力吗？ 人生就像一部缺了很多页的书，实在难以称之为书，但总算勉成一部 缺憾终究会有，2019，希望能少一些吧 Goodbye, 2018! Hello, 2019! 2019，A new ChenZ01]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ChenZ01's Code Style]]></title>
    <url>%2F2018%2F12%2F31%2FChenZ01-s-Code-Style%2F</url>
    <content type="text"><![CDATA[ForewordVSCode的奇怪问题最后检查下来是自己Code Style的锅痛改前非，决定规范一下自己的代码 头文件预编译指令所有预编译指令不缩进 前置声明除非必要，不使用前置声明 内联函数只有当函数只有10行甚至更少时才将其定义为内联函数 include所有#include必须置于程序开头 作用域命名空间不使用using语句命名空间中用到的全部变量必须声明于命名空间内在命名空间最后注释出命名空间的名字 局部变量应使用初始化的方式替代声明再赋值 代码美观缩进必须使用4个空格缩进 大括号大括号必须换行，括号内代码块遵循缩进原则 if - else遵循以下写法12345678if ()&#123;&#125;else&#123;&#125; 和12345678if ()&#123;&#125;else if ()&#123;&#125; 空格除下述符号外，任何符号两侧必须有空格++、--、.、::、-&gt;两侧不得有空格 空行相对独立的代码块之间应有空行 逗号一个独立且没有关键字的代码块中语句可以使用,隔开 命名变量、函数、结构体应遵循小驼峰命名法命名空间应遵循大驼峰命名法]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VSCode 配置 C++]]></title>
    <url>%2F2018%2F12%2F30%2FVSCode-%E9%85%8D%E7%BD%AE-C%2B%2B%2F</url>
    <content type="text"><![CDATA[Foreword由于网上乱七八糟的VSCode配置没几个能用的，故萌生了这个想法 MethodStep 1下载MinGW G++或其他版本的C++编译器，配置环境变量 Step 2VSCode工作区内新建.vscode文件夹，在该文件夹内部新建launch.json和tasks.json launch.json内容如下，相应路径更改即可12345678910111213141516171819&#123; "version": "0.2.0", "configurations": [ &#123; "name": "C++ Launch (GDB)", "type": "cppdbg", "request": "launch", "targetArchitecture": "x64", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "miDebuggerPath": "S:\\mingw64\\bin\\gdb.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceRoot&#125;", "externalConsole": true, "preLaunchTask": "g++" &#125; ]&#125; tasks.json1234567891011121314151617181920&#123; "version": "2.0.0", "label": "build", "command": "g++", "args": ["-g", "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe"], "problemMatcher": &#123; "owner": "cpp", "fileLocation": ["relative", "$&#123;workspaceFolder&#125;"], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;&#125; Step 3完毕，接下来就是F5 Debug之类的了 c_cpp_properties.json#include时说没有iostream，发现includePath未配置12345678910111213141516171819202122&#123; "configurations": [ &#123; "name": "Win32", "includePath": [ "$&#123;workspaceFolder&#125;/**", "S:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\8.1.0\\include\\c++", "S:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\8.1.0\\include\\c++\\x86_64-w64-mingw32", "S:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\8.1.0\\include\\c++\\tr1", "S:\\mingw64\\x86_64-w64-mingw32\\include" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "intelliSenseMode": "msvc-x64" &#125; ], "version": 4&#125;]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2010」 古代猪文 - CRT + Lucas]]></title>
    <url>%2F2018%2F12%2F04%2FSDOI2010-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87%2F</url>
    <content type="text"><![CDATA[Link洛谷 2480 Solution题意即求$$G ^ {\sum_{d | n}C_n^d}\,\mathrm{mod}\,999911659$$ Step 1推广费马小定理可得$$G^{\sum_{d | n}C_n^d\,\mathrm{mod}\,999911659} = G^{\sum_{d | n}C_n^d\,\mathrm{mod}\,999911658}\,\mathrm{mod}\,999911659$$ Step 2快速幂很好办，那么唯一的难点就是指数——模数不为质数，不能直接用Lucas Theorem再看一眼我们要求的指数$$\sum_{d | n}C_n^d\,\mathrm{mod}\,999911658$$对于$d$我们采用$O(\sqrt{n})$的方式暴力枚举，然后呢……似乎我们已经走入穷途末路了…… Step 3方便起见令$s = \sum_{d | n}C_n^d, x = s \,\mathrm{mod}\,999911659$分解$999911658 = 2 \cdot 3 \cdot 4679 \cdot 35617$令$a_1 = s\,\mathrm{mod}\, 2, a_2 = s\,\mathrm{mod}\, 3, a_3 = s\,\mathrm{mod}\, 4679, a_4 = s\,\mathrm{mod}\, 35617$我们可以得到\begin{cases}x \equiv a_1 (\mathrm{mod}\, 2)\\x \equiv a_2 (\mathrm{mod}\, 3)\\x \equiv a_3 (\mathrm{mod}\, 4679)\\x \equiv a_3 (\mathrm{mod}\, 35617)\end{cases}求解出$x$即为指数 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;#define MOD 999911659template &lt;class T&gt;void Read(T &amp;x)&#123; x = 0; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;long long n, g;long long frac[50010];void init(long long p)&#123; frac[0] = 1; for (register long long i = 1; i &lt;= p; ++i) frac[i] = frac[i - 1] * i % p;&#125;inline long long fastpow(long long base, long long index, long long p)&#123; register long long ret = 1; while (index) &#123; if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; &#125; return ret;&#125;inline long long inv(long long x, long long p)&#123; return fastpow(x, p - 2, p);&#125;inline long long C(long long x, long long y, long long p)&#123; if (x &lt; y) return 0; else return frac[x] * inv(frac[y], p) * inv(frac[x - y], p) % p;&#125;inline long long Lucas(long long x, long long y, long long p)&#123; if (x &lt; y) return 0; else if (x &lt; p &amp;&amp; y &lt; p) return C(x, y, p); else return Lucas(x % p, y % p, p) * Lucas(x / p, y / p, p) % p;&#125;inline long long CRT(vector &lt;long long&gt; &amp;a, vector &lt;long long&gt; &amp;b)&#123; register long long ret = 0, m = MOD - 1; for (register int i = 0; i &lt; 4; ++i) ret = (ret + a[i] * (m / b[i]) % m * inv(m / b[i], b[i]) % m) % m; return (ret % m + m) % m;&#125;inline long long sum(long long p)&#123; vector &lt;long long&gt; a(4), b(4); b[0] = 2, b[1] = 3, b[2] = 4679, b[3] = 35617; for (register int j = 0; j &lt; 4; ++j) &#123; init(b[j]); for (register int i = 1; i * i &lt;= n; ++i) &#123; if (!(n % i)) &#123; a[j] = (a[j] + Lucas(n, i, b[j])) % b[j]; if (i * i != n) a[j] = (a[j] + Lucas(n, n / i, b[j])) % b[j]; &#125; &#125; &#125; return CRT(a, b) % p;&#125;int main()&#123; Read(n), Read(g); if (!(g % MOD)) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; fastpow(g, sum(MOD), MOD)&lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2013」 随机数生成器 - BSGS]]></title>
    <url>%2F2018%2F12%2F04%2FSDOI2013-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Link洛谷 3306 Solution大力推式子 \begin{align}X_{i + 1} &amp;\equiv aX_i + b(\mathrm{mod}\,p)\\X_{i + 1} + \frac{b}{a} &amp;\equiv aX_i + b + \frac{b}{a}(\mathrm{mod}\,p)\\aX_{i + 1} + b &amp;\equiv a^2X_i + ab + b(\mathrm{mod}\,p)\\X_{i + 2} &amp;\equiv a^2X_i + ab + b(\mathrm{mod}\,p)\\\end{align} 那么我们得到 \begin{align}X_2 &amp;\equiv aX_1 + b(\mathrm{mod}\,p)\\X_3 &amp;\equiv a ^ 2X_1 + ab + b(\mathrm{mod}\,p)\\X_4 &amp;\equiv a ^ 3X_1 + a ^ 2b + ab + b(\mathrm{mod}\,p)\\\dots\\X_i &amp;\equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)\\\end{align} 也就是我们要判断如下方程是否有整数解，若有则求解 $$t \equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)$$ 继续化化化 \begin{align}t &amp;\equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)\\t &amp;\equiv a ^ {i - 1}X_1 + b\frac{1 - a ^ {i - 1}}{1 - a}(\mathrm{mod}\,p)\\t &amp;\equiv a ^ {i - 1}X_1 + \frac{b}{1 - a} - \frac{b}{1 - a} \cdot a^{i - 1}(\mathrm{mod}\,p)\\t &amp;\equiv a ^ {i - 1}(X_1 - \frac{b}{1 - a}) + \frac{b}{1 - a}(\mathrm{mod}\,p)\\a ^ {i - 1} &amp;\equiv \frac{t - \frac{b}{1 - a}}{X_1 - \frac{b}{1 - a}}(\mathrm{mod}\,p)\\\end{align} 大功告成，用BSGS求解出$i - 1$的值，由于$t$是第$i$项，答案加一即可 Detail 1对于$X_1 = t$时，直接输出$1$ Detail 2对于$a = 0$时，$X_i = b$ Detail 3对于$a = 1$时，有$X_i \equiv X_1 + b(i - 1)(\mathrm{mod}\,p)$那么求解$t - X_1 \equiv b(i - 1)(\mathrm{mod}\,p)$的系数$i - 1$即可注意当答案就是$p$的时候不要再模$p$了 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;template &lt;class I&gt;inline void Read(I &amp;x)&#123; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;long long NUMOFCASES, a, b, p, x, t, X, Y;long long fastpow(long long base, int index, int MOD)&#123; register long long ret = 1; while (index) &#123; if (index &amp; 1) ret = ret * base % MOD; base = base * base % MOD; index &gt;&gt;= 1; &#125; return ret;&#125;long long gcd(long long a, long long b)&#123; return b ? gcd(b, a % b) : a;&#125;long long inv(long long x, int MOD)&#123; return fastpow(x, MOD - 2, MOD);&#125;long long bsgs(long long a, long long b, int MOD)&#123; a %= MOD, b %= MOD; std::map&lt;long long, long long&gt; map; register long long m = ceil(sqrt(MOD)), t = 1; for (register int i = 0; i &lt; m; ++i) &#123; if (!map.count(t)) map[t] = i; t = t * a % MOD; &#125; register long long k = inv(t, MOD), w = b; for (int i = 0; i &lt; m; ++i) &#123; if (map.count(w)) return i * m + map[w]; w = w * k % MOD; &#125; return -1;&#125;int main()&#123; Read(NUMOFCASES); for (; NUMOFCASES; --NUMOFCASES) &#123; Read(p), Read(a), Read(b), Read(x), Read(t); if (x == t) cout &lt;&lt; 1 &lt;&lt; endl; else if (a == 1) &#123; t = (t - x + p) % p; if (t % gcd(b, p)) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; (t * inv(b, p) + 1 == p ? t * inv(b, p) + 1 : (t * inv(b, p) + 1) % p) &lt;&lt; endl; &#125; else if (a == 0) &#123; if (b == t) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; long long ans = bsgs(a, ((t - b * inv(1 - a, p)) % p + p) % p * inv(((x - b * inv(1 - a, p)) % p + p) % p , p), p) % p; if (ans == -1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans + 1 &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 1441」 Min - 裴蜀定理]]></title>
    <url>%2F2018%2F11%2F21%2FBZOJ-1441%2F</url>
    <content type="text"><![CDATA[LinkBZOJ 1441 Solution第一发BZOJ题解，顺便改一下post标题格式 Analysis我们先不管$a_3\dots a_n$，单看$a_1, a_2$方便起见我们令$a = a_1, b = a_2$那么很显然$a$与$b$的线性组合集中最小正元素即为$\gcd(a, b)$现在我们考虑加入$c = a_3$，则它与$a, b$构造的最小解即为$\gcd(c, \gcd(a, b))$上面我们先考虑线性组合$a, b$，即我们按顺序构造解，正确性显然 裴蜀定理对于任意整数$a, b$，定有$\gcd(a, b) | (ax + by)$ Proof有了该定理，我们更理性地看一下我们的做法首先对于两个整数$a, b$，其能构造出的最小正值为$\gcd(a, b)$，且对于$a, b$线性组合集中的任意元素$k$，都有$\gcd(a, b) | k$那么加入第三个数$c$，则肯定有$\gcd(c, k) \geq \gcd(c, \gcd(a, b))$推广至一般形式，对于已经处理出的最小解$s=\gcd(a_1, a_2, \dots, a_k)$以及另一个解$s’$，加入$a_{k + 1}$，则定有$$\gcd(s’, a_{k + 1}) \geq \gcd(s, a_{k + 1})$$因此本题的$s$即为$\gcd(a_1, a_2, \dots, a_n)$ Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;inline void Read(int &amp;x)&#123; x = 0; char ch = getchar(); int minu = 0; while (!isdigit(ch)) ch = getchar(), minu = ch == '-'; while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if (minu) x = -x;&#125;int gcd(int x, int y)&#123; return y ? gcd(y, x % y) : x;&#125;int n, a, b, ans;int main()&#123; freopen("1441.in", "r", stdin); freopen("1441.out", "w", stdout); Read(n); Read(a); for (int i = 2; i &lt;= n; ++i) &#123; Read(b); ans = (a = gcd(a, b)); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2009」 猜数字]]></title>
    <url>%2F2018%2F11%2F16%2FTJOI2009-%E7%8C%9C%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Link洛谷 3868 Solution经典的Chinese Remainder Theorem例题然而我并不是被CRT卡的，细节较多考虑将方程组变形\begin{cases}x\equiv a_1(\mathrm{mod}\,b_1)\\x\equiv a_2(\mathrm{mod}\,b_2)\\\dots\\x\equiv a_k(\mathrm{mod}\,b_k)\end{cases}直接用CRT实现即可 Detail 1乘法会爆long long，须用快速龟速乘 Detail 2快读注意判负数 Detail 3$a_i$可能为负，为了方便实现，在使用时转为模$b_i$等价类的最小正元素 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;inline void Read(long long &amp;x)&#123; x = 0; register char ch = getchar(); register int flag = 0; while (!isdigit(ch)) flag = (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if (flag) x = -x;&#125;long long mul(long long a, long long b, long long MOD)&#123; long long ret = 0; while (a) &#123; if (a &amp; 1) (ret += b) %= MOD; (b += b) %= MOD; a &gt;&gt;= 1; &#125; return ret;&#125;long long k, s = 1, n;long long a[110], b[110];void exgcd(long long a, long long b, long long &amp;x, long long &amp;y)&#123; if (!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x;&#125;int main()&#123; Read(k); for (int i = 1; i &lt;= k; ++i) Read(a[i]); for (int i = 1; i &lt;= k; ++i) Read(b[i]), s *= b[i]; for (int i = 1; i &lt;= k; ++i) &#123; register long long m = s / b[i], x, y; exgcd(m, b[i], x, y); (n += mul(mul((a[i] % b[i] + b[i]) % b[i], m, s), x, s)) %= s; &#125; cout &lt;&lt; (n + s) % s &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2017初中组」 alter]]></title>
    <url>%2F2018%2F10%2F27%2FAHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84-alter%2F</url>
    <content type="text"><![CDATA[Link洛谷 3718 Solution由于对于一个答案我们很容易验证是否可行，考虑二分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int n, k, t;string st;int check(int x)&#123; int len = 1, cnt = 0; for (int i = 1; i &lt; st.length(); ++i) &#123; if (st[i] == st[i - 1]) ++len; else len = 1; if (len &gt; x) &#123; ++cnt, len = 0; if (x &lt; 2) st[i] = st[i] == 'N' ? 'F' : 'N', ++len; &#125; &#125; if (cnt &lt;= k) return 1; else return 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; st; int l = 1, r = n; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2006」 保安站岗]]></title>
    <url>%2F2018%2F10%2F26%2FSDOI2006-%E4%BF%9D%E5%AE%89%E7%AB%99%E5%B2%97%2F</url>
    <content type="text"><![CDATA[Link洛谷 2458 Solution对于某个节点，其被覆盖的情况有三种： 被其父节点覆盖 被自己覆盖 被其子节点覆盖 那么我们可按以下方式转移：设$f(0/1/2,i)$表示节点$i$被父节点/本身/子节点覆盖且其子树全被覆盖的最小代价，设$j$为其子节点，易得方程$$f(0,i)=\sum\min\lbrace f(1,j),f(2,j)\rbrace$$$$f(1,i)=\sum\min\lbrace f(0,j),f(1,j),f(2,j)\rbrace$$$$f(2,i)=f(1,k)+\sum_{j\neq k}\min\lbrace f(1,j),f(2,j)\rbrace,f(1,k)=\min\lbrace f(1,j)\rbrace$$ $f(2,i)$转移的细节依然令$j$为$i$的一个子节点思路即取一个最优的子节点强制性的使用它的$f(1,j)$来转移，其余的取最优方案有个细节千万注意：并非$f(1,j)$最小的$j$为最优，反例即为该点的$f(2,j)$远小于该点的$f(1,j)$值也就是我们强制选择的点就是$f(1,j)-f(2,j)$最小的点以$x$记录上述值，$y$记录是否选过$f(1,j)&lt;f(2,j)$的点（$j$本身覆盖优于$j$的子节点覆盖）若$y=0$，那么我们必须加上一个最小的$f(1,j)-f(2,j)$，否则代表我们已经选过最优的这种点了，不作改动 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, numi, ordi, soni;int w[1510], f[3][1510];vector &lt;int&gt; tree[1510];void dfs(int cur, int fr)&#123; int x = 0x7f7f7f7f, y = 0; f[1][cur] = w[cur]; for (int i = 0; i &lt; tree[cur].size(); ++i) &#123; int to = tree[cur][i]; if (to != fr) &#123; dfs(to, cur), f[0][cur] += min(f[1][to], f[2][to]), f[1][cur] += min(f[0][to], min(f[1][to], f[2][to])); if (f[1][to] &lt; f[2][to]) ++y; else x = min(x, f[1][to] - f[2][to]); f[2][cur] += min(f[1][to], f[2][to]); &#125; &#125; if (!y) f[2][cur] += x;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; ordi &gt;&gt; w[ordi] &gt;&gt; numi; for (; numi; --numi) cin &gt;&gt; soni, tree[ordi].push_back(soni), tree[soni].push_back(ordi); &#125; dfs(1, 0); cout &lt;&lt; min(f[1][1], f[2][1]) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 767C」 Garland]]></title>
    <url>%2F2018%2F10%2F25%2FCodeforces-767C-Garland%2F</url>
    <content type="text"><![CDATA[LinkCF767C Solution很显然，权值总和不为$3$倍数的话无解那么对于可将权值分成三份相等的情况，我们的工作就是分三棵子树使得每棵子树的权值和等于总和的三分之一我们可以自叶节点向根节点方向累加权值，遇到目前累加和符合条件的就记录一下重点来了：满足权值和条件的子树个数不一定等于3，因为有负权的存在假设有$4$棵子树的权值和都等于$w=W/3$，那么树上必定存在一部分其权值和等于$-w$由于我们是从下往上统计的，这部分一定处在最上面两棵子树之间。那么我们把这一部分与两个权值为$w$的子树合并，必然能得到3棵符合要求的子树因此最后的判断条件就是$cnt&gt;=3$ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, u, w, W, Root;int s[1000010];vector &lt;int&gt; tree[1000010];vector &lt;int&gt; cut;void dfs(int cur, int fr)&#123; for (int i = 0; i &lt; tree[cur].size(); ++i) if (tree[cur][i] != fr) dfs(tree[cur][i], cur), s[cur]+= s[tree[cur][i]]; if (s[cur] == W) cut.push_back(cur), s[cur] = 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; u &gt;&gt; w, s[i] = w, W += w; if (u) tree[u].push_back(i), tree[i].push_back(u); else Root = i; &#125; if (W % 3) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; W /= 3, dfs(Root, Root); if (cut.size() &gt;= 3) cout &lt;&lt; cut[0] &lt;&lt; " " &lt;&lt; cut[1] &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HEOI2015」 兔子与樱花]]></title>
    <url>%2F2018%2F10%2F23%2FHEOI2015-%E5%85%94%E5%AD%90%E4%B8%8E%E6%A8%B1%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[Link洛谷 4107 Solution假设当前节点为$i$，则其某个子节点$j$被删除且不违背最大载重的话一定满足$$c_i+c_j-1\leq m$$而且只需满足这个条件即可那么我们为了删除尽可能多的点，易想到贪心解决 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, m, tmp, son, ans;int c[2000010], k[2000010];vector &lt;int&gt; tree[2000010];bool cmp(const int &amp;x, const int &amp;y)&#123; return c[x] &lt; c[y];&#125;void dfs(int root)&#123; int sze = tree[root].size(); if (!sze) return; for (int i = 0; i &lt; sze; ++i) dfs(tree[root][i]); sort(tree[root].begin(), tree[root].end(), cmp); for (register int i = 0; i &lt; sze; ++i) &#123; if (c[root] + c[tree[root][i]] - 1 &lt;= m) c[root] += c[tree[root][i]] - 1, ++ans; else break; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; c[i]; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; tmp; c[i] += tmp; while (tmp--) cin &gt;&gt; son, tree[i].push_back(son); &#125; dfs(0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Extra洛谷提交时记得开O2]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2011」 计算器]]></title>
    <url>%2F2018%2F10%2F04%2FSDOI2011-%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Link洛谷 2485 Solution1裸的快速幂取模 2令$d=\gcd(a,n)$ 一个推论当且仅当$d|b$时，方程$ax\equiv b(\mathrm{mod}\,n)$对于未知量$x$有解 一个定理假设对某些整数$x’$和$y’$，有$d=ax’+ny’$。若$d|b$，则方程$ax\equiv b(\mathrm{mod}\,n)$的有一个解的值为$x_0$，这里$$x_0=x’(b/d)\,\mathrm{mod}\,n$$ 证明根据$x’$的性质，即：$$ax\equiv d(\mathrm{mod}\,n)$$可得：\begin{align}ax_0&amp;\equiv ax’(b/d)(\mathrm{mod}\,n)\\&amp;\equiv d(b/d)(\mathrm{mod}\,n)\\&amp;\equiv b(\mathrm{mod}\,n)\end{align}因此$x_0$是方程$ax\equiv b(\mathrm{mod}\,n)$的一个解 解决那么对于询问2，用扩欧求方程$ax’+ny’=d$即可注意根据上面的一个推论，当$d$不整除$b$时该方程无解 3我们引入一个概念—— 离散对数若$g$是$\mathrm{Z}_n^*$的一个原根且$a$是$\mathrm{Z}_n^*$中的任意元素，则存在一个$z$，使得$g^z\equiv a(\mathrm{mod}\,n)$，则将$z$称为对模$n$到基$g$上的$a$的一个离散对数或指数说人话，也就是对于给定的$a,b,p$，存在一个$x$，使得$$a^x\equiv b(\mathrm{mod}\,p)$$则称$x$为$b$在模$p$意义下以$a$为底的离散对数 很显然本题就是让我们求$y$的离散对数，常用方法叫做BSGS——Baby Step-Giant Step BSGS拿出我们要解的关于$x$的方程：$$a^x\equiv b(\mathrm{mod}\,p)$$令$m=\lceil \sqrt{p}\rceil$。根据费马小定理，有$a^{p-1}\equiv 1(\mathrm{mod}\,p)$故若方程有解，则必存在一个$0\leq x&lt;p-1$根据除法的定义，令$x=im+j$，方程可化为： \begin{align}a^x&amp;\equiv b(\mathrm{mod}\,p)\\a^{im+j}&amp;\equiv b(\mathrm{mod}\,p)\\a^j&amp;\equiv b\cdot a^{-im}(\mathrm{mod}\,p)\\a^j&amp;\equiv b\cdot (a^{-m})^i(\mathrm{mod}\,p)\end{align}得到这玩意，我们就只需找到一组$i,j$使得最后一个式子成立即可那么我们先枚举$j$，递推出左边$a^j\,\mathrm{mod}\,p$的所有取值，并将其按照$(a^j\,\mathrm{mod}\,p)\mapsto j$的映射关系插入到哈希表中之后求出$a^m\,\mathrm{mod}\,p$的乘法逆元，枚举$i$，递推出所有的$b\cdot(a^{-m})^i$，每得到一个值后在哈希表内查找该值。若存在，取出对应的$j$，$x=im+j$即为一个解 Extra注意取模的时候可能有负数，并且应该先模$p$，具体见代码注释的那一行，卡了我35分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;long long T, K, y, z, p, gcd, X, Y;map &lt;long long, long long&gt; mp;inline long long fastpow(long long base, long long index)&#123; long long ret = 1; while (index) &#123; if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; &#125; return ret;&#125;inline void exgcd(long long a, long long b, long long &amp;d, long long &amp;x, long long &amp;y)&#123; if (!b) d = a, x = 1, y = 0; else exgcd(b, a % b, d, y, x), y -= a / b * x;&#125;inline long long inv(long long x)&#123; return fastpow(x, p - 2);&#125;inline long long bsgs(long long a, long long b)&#123; if (!a) return b ? -1 : 1; mp.clear(); long long m = ceil(sqrt(p)), t = 1; for (long long i = 0; i &lt; m; i++) &#123; if (!mp.count(t)) mp[t] = i; t = t * a % p; &#125; long long k = inv(t), w = b; for (long long i = 0; i &lt; m; i++) &#123; if (mp.count(w)) return i * m + mp[w]; w = w * k % p; &#125; return -1;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; T &gt;&gt; K; while (T--) &#123; cin &gt;&gt; y &gt;&gt; z &gt;&gt; p; if (K == 1) &#123; cout &lt;&lt; fastpow(y, z) &lt;&lt; endl; &#125; else if (K == 2) &#123; exgcd(y, p, gcd, X, Y); if (z % gcd) cout &lt;&lt; "Orz, I cannot find x!" &lt;&lt; endl; else &#123; cout &lt;&lt; (X * z / gcd % p + p) % p &lt;&lt; endl;//Important &#125; &#125; else &#123; long long ans = bsgs(y % p, z % p); if (ans == -1) cout &lt;&lt; "Orz, I cannot find x!" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 后记BSGS部分参考Menci的博客]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1313」 计算系数]]></title>
    <url>%2F2018%2F09%2F29%2F%E6%B4%9B%E8%B0%B7-1313%2F</url>
    <content type="text"><![CDATA[前言感谢学长！虽然问了很多智障问题，占用了你宝贵的打游戏的时间由衷的感谢你！ 题目链接洛谷 1313本题亦是NOIP2011提高组D2T1 题解二项式定理展开拿到式子首先变个形（$y$在前太丑了）：$$(ax+by)^k$$二项式定理展开后，得：$$C_k^0(ax)^k(by)^0+C_k^1(ax)^{k-1}(by)^1+\dots+C_n^k(ax)^0(by)^k$$由于$n+m=k$，可得$x^ny^m$项就是$C_k^m(ax)^{k-m}(by)^m$展开并合并，得：$$C_k^m\cdot x^{k-m}y^m\cdot a^{k-m}b^m$$ 分析$a^{k-m}b^m$用快速幂很好处理，我们的主要目标就是对$C_k^m$取模这里毫无疑问可以递推，但是数学题就纯数学！再将$C_k^m$写成定义式的形式：$$C_k^m=\frac{k!}{m!(k-m)!}$$直接算阶乘long long也承受不了，那么继续使用数学方法 引理1$$\frac{a}{b}\,\mathrm{mod}\,p=ab^{-1}\,\mathrm{mod}\,p$$其中$b^{-1}$表示$b$在模$p$（通常情况下$p$为质数，本题为$10007$）意义下关于$a$的乘法逆元且$b|a$ 证明这么简单的结论我竟然折腾了半天才搞出来……\begin{align}\frac{a}{b}b\,\mathrm{mod}\,p&amp;=a\,\mathrm{mod}\,p\\&amp;=ab^{-1}b\,\mathrm{mod}\,p\\\end{align}$\therefore \frac{a}{b}\,\mathrm{mod}\,p=ab^{-1}\,\mathrm{mod}\,p$ 继续分析根据引理1，有：$$C_k^m=\frac{k!}{m!(k-m)!}=k![m!(k-m)!]^{-1}$$很显然我们要求$m!(k-m)!$的逆元，扩欧可以很好的做到这点（求之前先模一下）但是我们想要更有趣一些的做法啊 引理2若$p$为质数，$n\perp p$，则$$n\,\mathrm{mod}\,p,2n\,\mathrm{mod}\,p\dots (p-1)n\,\mathrm{mod}\,p$$生成一个$1\dots p-1$的排列 证明设存在$0&lt;a&lt;b&lt;p$使得$an\,\mathrm{mod}\,p=bn\,\mathrm{mod}\,p$则有$(a-b)n\,\mathrm{mod}\,p=0$\begin{align}&amp;\therefore (a-b)n=kp\\&amp;\because n\perp p\\&amp;\therefore (a-b)\,\mathrm{mod}\,p=0\\&amp;\because 0&lt;a,b&lt;p\\&amp;\therefore a=b\end{align}而这与$a&lt;b$矛盾$\therefore \nexists 0&lt;a&lt;b&lt;p$使得$an\equiv bn(\mathrm{mod}\,p)$因此$n\,\mathrm{mod}\,p,2n\,\mathrm{mod}\,p\dots (p-1)n\,\mathrm{mod}\,p$生成一个$1\dots p-1$的排列 引理3（费马小定理）$$n^{p-1}\equiv 1(\mathrm{mod}\,p),\,n\perp p$$ 证明我为什么吃饱了撑的要来证明这个根据引理2，我们把这$p-1$个数乘起来，可得：\begin{align}\prod_{i=1}^{p-1}in&amp;\equiv\prod_{i=1}^{p-1}(in\,\mathrm{mod}\,p)(\mathrm{mod}\,p)\\&amp;\equiv(p-1)!\end{align}即：$$(p-1)!n^{p-1}\equiv(p-1)!(\mathrm{mod}\,p)$$$p$是质数，因此$\gcd((p-1)!,p)=1$，故可将上式的$(p-1)!$消去，故得：$$n^{p-1}\equiv 1(\mathrm{mod}\,p)$$ 对费马小定理的变形根据费马小定理，有$n^{p-1}\equiv 1(\mathrm{mod}\,p),\,n\perp p$$\therefore n\cdot n^{p-2}\equiv 1(\mathrm{mod}\,p)$$\therefore n^{p-2}\equiv \frac{1}{n}(\mathrm{mod}\,p)$根据引理1，有：$$n^{p-2}\equiv n^{-1}(\mathrm{mod}\,p)$$因此可以通过快速幂求$n^{p-2}$来求$n^{-1}$ 最后一步根据所有前置的分析，我们将式$k![m!(k-m)!]^{-1}$写成$(k![m!(k-m)!])^{p-2}$至此完美解决 总结前面太长了，这里总结一下先将要求的单项式拿出来：$$C_k^ma^{k-m}b^m$$然后对于$a$和$b$的幂次用快速幂解决对于$C_k^m$，写成$\frac{k!}{m!(k-m)!}$后，对分母用快速幂求其逆元，分子直接阶乘求 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int a, b, k, n, m;long long ans;long long fastpow(int base, int index)&#123; long long ret = 1; base %= 10007; while (index) &#123; if (index &amp; 1) ret = ret * base % 10007; base = base * base % 10007; index &gt;&gt;= 1; &#125; return ret;&#125;long long frac(int x)&#123; return x ? frac(x - 1) % 10007 * x % 10007 : 1;&#125;long long C(int x, int y)&#123; return frac(x) * fastpow(frac(y) * frac(x - y), 10005) % 10007;&#125;int main(int argc, char ** argv)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; k &gt;&gt; n &gt;&gt; m; cout &lt;&lt; fastpow(a, k - m) % 10007 * fastpow(b, m) % 10007 * C(k, m) % 10007 &lt;&lt; endl; return 0;&#125; 后记两个引理都是学长帮忙证出来的费马小定理的证明参考Concrete Mathematics，生成$p-1$的排列也是学长帮助证明的费马小定理变形参考プログラミングコンテストチャレンジブック]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[至今遇到过的坑]]></title>
    <url>%2F2018%2F09%2F23%2F%E8%87%B3%E4%BB%8A%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[正文持续更新QAQ C++的一些坑以$0$开头永远记住C++从$0$开始分配内存！ sort()函数如果你习惯了以$1$开头，设数组$a$长度为$n$，那么sort()函数的写法如下：1sort(a+1,a+n+1); string先12345678#include &lt;iostream&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; return 0;&#125; 用MinGW G++/GCC编译，完全没有问题然而用Visual Studio（MSVC++编译）就会报错你需要加一句：1#include &lt;string&gt; 注意不是string.h或cstring，而是string！ STLvector等，你以为能当数组用？一个未初始化的vector，访问其中的元素会相当漂亮地RE 位运算记住&gt;&gt;和&lt;&lt;的优先级比+-*/要低！ 数据结构的一些坑线段树记住线段树要开$4$倍空间，不然RE极其重要！ 树状数组查询$[l,r]$的时候要查$[1,l)$而非$[1,l]$！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组修改与查询]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[正文我们将修改与查询问题归为四大类 单点修改，单点查询这就不用做了，无脑开数组或map 单点修改，区间查询这里的树状数组用法较基础，模板题目：洛谷 3374 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, x, y;long long s[1000010];inline void update(int pos, int add)&#123; while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;&#125;inline long long query(int pos)&#123; long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t , update(i, t); while (q--) &#123; cin &gt;&gt; t &gt;&gt; x &gt;&gt; y; if (t == 1) update(x, y); else cout &lt;&lt; query(y) - query(x - 1) &lt;&lt; endl; &#125; return 0;&#125; 区间修改，单点查询我们学习一个叫做差分的神奇东西简单来说，对于原数组$a,a_0=0$，定义差分数组$d$，其构造法则为：$$d_i=a_i-a_{i-1}$$可以发现：$$a_i=\sum_{j=1}^id_j$$假设我们给区间$[l,r]$加上$k$，那么我们会发现$d_l$变大了$k$，$d_{r+1}$变小了$k$，其余的不变因此我们只需维护$d$数组的前缀和即可，树状数组可以很方便的维护依然送上模板题目：洛谷 3368 Code实现时要注意我们维护的是差分数组，因此在对树状数组的初始化时要注意update的元素1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, l, r, x, lst;long long s[1000010];void update(int pos, int add)&#123; while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;&#125;long long query(int pos)&#123; long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; while (q--) &#123; cin &gt;&gt; t; if (t == 1) cin &gt;&gt; l &gt;&gt; r &gt;&gt; x, update(l, x), update(r + 1, -x); else cin &gt;&gt; x, cout &lt;&lt; query(x) &lt;&lt; endl; &#125; return 0;&#125; 区间修改，区间查询我们依然要用到差分，定义与上面的相同当我们查询区间$[l,r]$时，前缀和思想是非常清晰的：$$\sum_{i=l}^ra_i=\sum_{i=1}^ra_i-\sum_{i=1}^{l-1}a_i$$对于一个单独的$\sum_{i=1}^xa_i$，我们有：$$\sum_{i=1}^xa_i=\sum_{i=1}^x\sum_{j=1}^id_j=\sum_{i=1}^x(x-i+1)d_i$$再将其进行一个神奇的转换：$$\sum_{i=1}^x(x-i+1)d_i=\sum_{i=1}^x(x+1)d_i-\sum_{i=1}^xid_i=(x+1)\sum_{i=1}^xd_i-\sum_{i=1}^xid_i$$所以我们可以维护两个树状数组，分别维护$d_i$和$id_i$即可每个询问区间的答案即是：$$\sum_{i=1}^ra_i-\sum_{i=1}^{l-1}a_i=(r+1)\sum_{i=1}^rd_i-\sum_{i=1}^rid_i-l\sum_{i=1}^{l-1}d_i+\sum_{i=1}^{l-1}id_i$$ Code维护时注意，第二个树状数组维护的是$id_i$，这意味着第一个树状数组update操作变化的值是$k$，那么第二个树状数组update操作变化的值是$ki$模板：POJ 3468千万注意数据规模可能超int，因此我选择整数运算和long long无异但范围比long long大的long double（其实没必要） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#pragma warning(disable:4996)int n, q, t, a, b, c, lst;char ch;long double s1[100010];long double s2[100010];void update(int pos, long long add)&#123; int tpos = pos; while (pos &lt;= n) s1[pos] += add, s2[pos] += tpos * add, pos += pos &amp; -pos;&#125;long long query(int pos)&#123; long long sum = 0, tpos = pos; while (pos) sum += (tpos + 1)*s1[pos] - s2[pos], pos -= pos &amp; -pos; return sum;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; for (int i = 1; i &lt;= q; i++) &#123; cin &gt;&gt; ch; if (ch == 'C') cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, update(a, c), update(b + 1, -c); else cin &gt;&gt; a &gt;&gt; b, cout &lt;&lt; query(b) - query(a - 1) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 2713」 GSS4]]></title>
    <url>%2F2018%2F09%2F16%2FSPOJ-2713%2F</url>
    <content type="text"><![CDATA[题目链接源地址：SPOJ GSS4洛谷搬运：SP2713 题解又是一道假的紫题又是一道系列毒瘤题 分析显然开方操作不能打lazy-tag，对于每个修改我们只能直接单点或区间修改既然只能这么做，我们必须考虑开方操作的优化由于开方后再开方相当于四次根号，那么开了$n$次方的数所得结果就是$2^n$次根号，这个数一定不会大到哪里去事实上，$\lfloor^{64}\sqrt{10^{18}}\rfloor=1$，因此超过$6$次开方的区间所有的数一定为$1$根据这个性质，我们有如下思想：对于将修改的区间$[L,R]$，若每个数都等于$1$（亦即区间和$=R-L+1$），这个区间无需操作，否则修改到点由于一个点最多被修改$6$次，复杂度可以接受 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;long long s[500010];long long n, q, tmp, op, ans;int x, y, cnt;void init()&#123; memset(s, 0, sizeof s);&#125;void pushup(int root)&#123; s[root] = s[root &lt;&lt; 1] + s[root &lt;&lt; 1 | 1];&#125;void build(int l, int r, int root)&#123; if (l == r) cin &gt;&gt; tmp, s[root] = tmp; else &#123; int mid = l + r &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void update(int l, int r, int root)&#123; if (s[root] &lt;= r - l + 1) return; if (l == r) s[root] = (long long)floor(sqrt(s[root])); else &#123; int mid = l + r &gt;&gt; 1; if (x &lt;= mid) update(l, mid, root &lt;&lt; 1); if (y &gt; mid) update(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void query(int l, int r, int root)&#123; if (l &gt;= x &amp;&amp; r &lt;= y) ans += s[root]; else &#123; int mid = l + r &gt;&gt; 1; if (x &lt;= mid) query(l, mid, root &lt;&lt; 1); if (y &gt; mid) query(mid + 1, r, root &lt;&lt; 1 | 1); &#125;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin.tie(0); while (cin &gt;&gt; n) &#123; cout &lt;&lt; "Case #" &lt;&lt; ++cnt &lt;&lt; ":" &lt;&lt; endl; init(); build(1, n, 1); cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (x &gt; y) swap(x, y); if (op) &#123; ans = 0; query(1, n, 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; update(1, n, 1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 1043」 GSS1]]></title>
    <url>%2F2018%2F09%2F15%2FSPOJ-1043%2F</url>
    <content type="text"><![CDATA[题目链接源地址：SPOJ GSS1洛谷搬运：SP1043源地址访问太慢了啦！ 题解查询区间最大子段和，经典的模型（可是我今天才会） 分析很显然，一个长度大于$2$的区间的最大子段和只有可能是三种情况： 左区间的最大子段和 右区间的最大子段和 左区间的右区间的最大子段和+右区间的左区间的最大子段和 对于线段树表示区间$[L,R]$的第$i$个区间，我们定义 $S(i)$表示该区间的区间和 $L(i)$表示该区间前缀最大和 $R(i)$表示该区间后缀最大和 $M(i)$表示该区间最大子段和 $left_i$表示左区间 $right_i$表示右区间 由此我们显然有： $S(i)=S(left_i)+S(right_i)$ $L(i)=\max(L(left_i)),S(left_i))+L(right_i))$ $R(i)=\max(R(right_i),S(right_i)+R(left_i))$ $M(i)=\max(M(left_i),M(right_i),R(left_i)+L(right_i))$ queryquery()函数比较特别，在此感谢Logey提供思路设当前即将查询的第$i$个区间为$[L,R]$，令$ans$表示该区间查询的结果，$rans$表示上一个访问过的区间的后缀最大和考虑到线段树是从左子树递归的，$rans$也可以理解为以$L-1$结尾的后缀最大和，即若当前区间完全被询问区间包含，那么修改$rans$的值，否则遍历左右子树，而右子树的$rans$完全可以从左子树的$rans$继承所以对于完全被询问区间包含的区间，我们有$ans=\max(M(i),rans+L(i))$随后修改以便继续遍历：$rans=\max(R(i),rans+S(i))$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, x, y, ans, rans;int a[50010];int L[200010], R[200010], M[200010], S[200010];void pushup(int root)&#123; S[root] = S[root &lt;&lt; 1] + S[root &lt;&lt; 1 | 1]; L[root] = max(L[root &lt;&lt; 1], S[root &lt;&lt; 1] + L[root &lt;&lt; 1 | 1]); R[root] = max(R[root &lt;&lt; 1 | 1], S[root &lt;&lt; 1 | 1] + R[root &lt;&lt; 1]); M[root] = max(M[root &lt;&lt; 1], max(M[root &lt;&lt; 1 | 1], R[root &lt;&lt; 1] + L[root &lt;&lt; 1 | 1]));&#125;void build(int l, int r, int root)&#123; if (l == r) L[root] = R[root] = M[root] = S[root] = a[l]; else &#123; int mid = (l + r) &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void query(int l, int r, int root)&#123; if (l &gt;= x &amp;&amp; r &lt;= y) &#123; ans = max(ans, max(M[root], rans + L[root])); rans = max(R[root], rans + S[root]); &#125; else &#123; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) query(l, mid, root &lt;&lt; 1); if (y &gt; mid) query(mid + 1, r, root &lt;&lt; 1 | 1); &#125;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); cin &gt;&gt; m; while (m--) &#123; cin &gt;&gt; x &gt;&gt; y; ans = rans = -0x7f7f7f7f; query(1, n, 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GCJ R1A 2008 C」 numbers]]></title>
    <url>%2F2018%2F09%2F02%2FGCJ-R1A-2008-C%2F</url>
    <content type="text"><![CDATA[题目链接GCJ R1A 2008 C总觉得Code Jam都需要科学方式访问是不是有些太过了 题解拿到手首先肯定不能暴力，于是我们考虑数学方法 分析对于这个式子：$(3+\sqrt{5})^n$，一眼想到二项式定理，将其展开得：$$(3+\sqrt{5})^n=C_n^03^n\sqrt{5}^0+C_n^13^{n-1}\sqrt{5}^1+\dots+C_n^{n-1}3^1\sqrt{5}^{n-1}+C_n^n3^0\sqrt{5}^n$$不难发现若幂次为偶数，则$\sqrt{5}$也会变成整数，那么我们可以将上面的式子写成如下形式：$$(3+\sqrt{5})^n=f(n)+g(n)\sqrt{5}$$$f(n)$即为展开式种所有运算结果为整数的部分的和仍然没法解决，我们再考虑另一个式子：$$(3-\sqrt{5})^n=C_n^03^n\sqrt{5}^0-C_n^13^{n-1}\sqrt{5}^1+\dots+(-1)^{n-1}C_n^{n-1}3^1\sqrt{5}^{n-1}+(-1)^nC_n^n3^0\sqrt{5}^n$$同理，可写成：$$(3-\sqrt{5})^n=f(n)-g(n)\sqrt{5}$$二式相加，得：$$(3+\sqrt{5})^n+(3-\sqrt{5})^n=2f(n)$$所以$$(3+\sqrt{5})^n=2f(n)-(3-\sqrt{5})^n$$考虑到$$0&lt;(3-\sqrt{5})^n&lt;1$$而我们要求的是整数部分，那么完全可以写成$$\lfloor(3+\sqrt{5})^n\rfloor=2f(n)-1$$ 求解$f$问题是这个$f$怎么求考虑以下递推式： \begin{align}(3+\sqrt{5})^{n+1}&amp;=(3+\sqrt{5})(3+\sqrt{5})^n\\&amp;=(3+\sqrt{5})(f(n)+g(n)\sqrt{5})\\&amp;=3f(n)+3\sqrt{5}g(n)+\sqrt{5}f(n)+5g(n)\end{align}所以\begin{align}f(n+1)=3f(n)+5g(n)\\g(n+1)=f(n)+3g(n)\end{align}由此我们可以用矩阵快速幂解决 矩阵原始矩阵：\begin{align}\begin{bmatrix}f(0)\\g(0)\end{bmatrix}=\begin{bmatrix}1\\0\end{bmatrix}\end{align}递推的矩阵：\begin{bmatrix}3&amp;5\\1&amp;3\end{bmatrix}至此问题解决 代码printf()格式化真心强大1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#pragma warning(disable:4996)using namespace std;int T, n;struct Mat&#123; int r, c; int matrix[10][10];&#125;;Mat basmat;void init()&#123; basmat.c = basmat.r = 2; basmat.matrix[0][0] = 3, basmat.matrix[0][1] = 5; basmat.matrix[1][0] = 1, basmat.matrix[1][1] = 3;&#125;Mat mul(Mat mat1, Mat mat2)&#123; Mat tmat; memset(tmat.matrix, 0, sizeof tmat.matrix); tmat.r = mat1.r; tmat.c = mat2.c; for (int i = 0; i &lt; mat1.r; i++) for (int j = 0; j &lt; mat2.c; j++) for (int k = 0; k &lt; mat1.c; k++) tmat.matrix[i][j] = (tmat.matrix[i][j] + mat1.matrix[i][k] * mat2.matrix[k][j]) % 1000; return tmat;&#125;void fastpow(int index)&#123; Mat retmat; retmat.r = retmat.c = 2; retmat.matrix[0][0] = retmat.matrix[1][1] = 1; retmat.matrix[0][1] = retmat.matrix[1][0] = 0; while (index) &#123; if (index &amp; 1) retmat = mul(retmat, basmat); basmat = mul(basmat, basmat); index &gt;&gt;= 1; &#125; printf("%03d\n", ((retmat.matrix[0][0] &lt;&lt; 1) - 1) % 1000);&#125;int main(int argc, char ** argv)&#123; freopen("C-large-practice.in", "r", stdin); freopen("C-large-practice.out", "w", stdout); scanf("%d", &amp;T); for (int TT = 1; TT &lt;= T; TT++) &#123; scanf("%d", &amp;n); init(); printf("Case #%d: ", TT); fastpow(n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>GCJ</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1306」 斐波那契公约数]]></title>
    <url>%2F2018%2F08%2F26%2F%E6%B4%9B%E8%B0%B7-1306%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 1306 题解数据范围是$10^9$，直接暴力显然不可取，因此我们考虑数学方法令$f(i)$表示斐波那契数列第$i$项 引理$$\gcd(f(n),f(n+1))=1$$ 证： \begin{align}\gcd(f(n),f(n+1))&amp;=\gcd(f(n),f(n+1)-f(n))\\&amp;=\gcd(f(n),f(n-1))\\&amp;=\gcd(f(n-2),f(n-1))\\&amp;\dots\\&amp;=\gcd(f(1),f(2))\\&amp;=1\\\end{align} 结论与证明设$n&lt;m, f(n)=a, f(n+1)=b$则 $f(n+2)=a+b,f(n+3)=a+2b,\dots,f(m)=f(m-n-1)a+f(m-n)b$$\because f(n)=a,f(n+1)=b,f(m)=f(m-n-1)a+f(m-n)b$$\therefore f(m)=f(m-n-1)\cdot f(n)+f(m-n)\cdot f(n+1)$$\therefore\gcd(f(n),f(m))=\gcd(f(n),f(m-n-1)\cdot f(n)+f(m-n)\cdot f(n+1))$$\therefore\gcd(f(n),f(m))=\gcd(f(n),f(m-n)\cdot f(n+1))$$\therefore\gcd(f(n),f(m))=\gcd(f(n),f(m-n))$$\therefore\gcd(f(n),f(m))=\gcd(f(n),f(m\,\mathrm{mod}\,n))$令$t=m\,\mathrm{mod}\,n$则$\gcd(f(n),f(m))=\gcd(f(n),f(t))=\gcd(f(t),f(n))$递归下去会发现这就是辗转相除，由此我们得到：$$\gcd(f(n),f(m))=f(\gcd(n,m))$$ 矩阵加速考虑我们需要将列向量\begin{bmatrix}f(1)\\f(0)\end{bmatrix}乘上一个矩阵$A$以转移到\begin{bmatrix}f(2)\\f(1)\end{bmatrix}实际上就是\begin{align}\begin{bmatrix}f(1)\\f(0)\end{bmatrix}\cdot\begin{bmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{bmatrix}=\begin{bmatrix}f(0)+f(1)\\f(1)\end{bmatrix}\end{align}易得：$$A=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}$$所以我们可以得到：\begin{align}\begin{bmatrix}f(n+1)\\f(n)\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^n\cdot\begin{bmatrix}f(1)\\f(0)\end{bmatrix}\end{align}化简可知$f(n)$即为乘方后矩阵的$a_{21}$过程采用矩阵快速幂 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Mat&#123; long long matrix[2][2]; int r, c;&#125;;Mat basmat;int n, m;long long gcd(long long x, long long y)&#123; return y ? gcd(y, x%y) : x;&#125;Mat mul(Mat mat1, Mat mat2)&#123; Mat tmat; memset(tmat.matrix, 0, sizeof tmat.matrix); tmat.r = mat1.r; tmat.c = mat2.c; for (int i = 0; i &lt; mat1.r; i++) for (int j = 0; j &lt; mat2.c; j++) for (int k = 0; k &lt; mat1.c; k++) tmat.matrix[i][j] = (tmat.matrix[i][j] + mat1.matrix[i][k] * mat2.matrix[k][j]) % 100000000; return tmat; &#125;void fastpow(int index)&#123; Mat retmat; retmat.matrix[0][0] = retmat.matrix[1][1] = 1; retmat.matrix[0][1] = retmat.matrix[1][0] = 0; retmat.r = 2; retmat.c = 2; while (index) &#123; if (index &amp; 1) retmat = mul(retmat, basmat); basmat = mul(basmat, basmat); index &gt;&gt;= 1; &#125; cout &lt;&lt; retmat.matrix[1][0] &lt;&lt; endl; return;&#125;void init()&#123; basmat.matrix[0][0] = basmat.matrix[0][1] = basmat.matrix[1][0] = 1; basmat.matrix[1][1] = 0; basmat.r = 2; basmat.c = 2;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); init(); cin &gt;&gt; n &gt;&gt; m; fastpow(gcd(n, m)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生日悖论的证明]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA%E7%9A%84%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[正文悖论描述若有$23$个人，则至少有两个人生日相同的概率要大于$50\%$从引起逻辑矛盾的角度来说生日悖论并非一种悖论 证明设$P(n)$表示$n$个人中至少有两个人生日相同的概率计算$P(n)$不容易，我们可以通过计算$P(n)=1-\overline{P}(n)$得到，其中$\overline{P}(n)$是该$n$人中，每个人生日都不相同的概率在此声明：不考虑双胞胎、闰年等特殊情况假设$n&gt;365$，则根据鸽巢原理，得：$$\overline{P}(n)=0,P(n)=1$$假设$n\leq 365$，根据生日两两不相等，得：\begin{align}\overline{P}(n)&amp;=\frac{365}{365}\cdot(1-\frac{1}{365})\cdot(1-\frac{2}{365})\dots(1-\frac{n-1}{365})\\&amp;=\frac{365}{365}\cdot\frac{364}{365}\dots\frac{365-n+1}{365}\\&amp;=\frac{365!}{365^n(365-n)!}\end{align}故$$P(n)=1-\overline{P}(n)=1-\frac{365!}{365^n(365-n)!}$$用Maple 2018输出（数据大到爆炸），我们可以看到：$$P(10)=11.69\%,P(23)=50.73\%,P(60)=99.41\%$$ 至此该命题得证]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu apt-get错误]]></title>
    <url>%2F2018%2F08%2F20%2FUbuntu-apt-get%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[正文Problem在使用apt-get命令时，我意外的发现了以下错误： E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 网上查过很多人的博客，大体思路是找进程并杀之然而我查进程时竟发现没有apt-get进程于是我继续寻找，终于找到了正解： Solution1234sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/locksudo dpkg --configure -asudo apt-get update 问题即顺利解决]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 1698」Just a Hook]]></title>
    <url>%2F2018%2F08%2F19%2FHDU-1698%2F</url>
    <content type="text"><![CDATA[题外话弃用cin（除了读long long的时候），改回scanf 题目链接HDU 1698 题解区间修改+区间求和，果断线段树区间修改注意不能退化成单点修改，需使用lazy-tag（即val数组） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;#pragma warning(disable:4996)int CASE, n, q, x, y, z;int sum[400010];int val[400010];void pushup(int root)&#123; sum[root] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1];&#125;void pushdown(int root, int len)&#123; if (val[root]) &#123; val[root &lt;&lt; 1] = val[root &lt;&lt; 1 | 1] = val[root]; sum[root &lt;&lt; 1] = val[root] * (len - (len &gt;&gt; 1)); sum[root &lt;&lt; 1 | 1] = val[root] * (len &gt;&gt; 1); val[root] = 0; &#125;&#125;void build(int l, int r, int root)&#123; val[root] = 0; if (l == r) sum[root] = 1; else &#123; int mid = (l + r) &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void update(int l, int r, int root)&#123; if (l &gt;= x &amp;&amp; r &lt;= y) sum[root] = z * (r - l + 1), val[root] = z; else &#123; pushdown(root, r - l + 1); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(l, mid, root &lt;&lt; 1); if (y &gt; mid) update(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;int main(int argc, char ** argv)&#123; scanf("%d", &amp;CASE); for (int i = 1; i &lt;= CASE; i++) &#123; scanf("%d%d", &amp;n, &amp;q); build(1, n, 1); while (q--) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); update(1, n, 1); &#125; printf("Case %d: The total value of the hook is %d.\n", i, sum[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 1166」 敌兵布阵]]></title>
    <url>%2F2018%2F08%2F07%2FHDU-1166%2F</url>
    <content type="text"><![CDATA[题外话永远不要迷信快读！或许你认为手写read()很快，实际上在HDU上惨不忍睹！目前原因未知，知道的dalao欢迎email本蒟蒻目测是getchar()与换行符的锅 题目链接HDU 1166 题解明显线段树裸题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define local#ifdef local#pragma warning(disable:4996)#endifusing namespace std;int T, n, x, y, ans;int a[200010];int sum[200010];int add[200010];string st;void pushup(int root)&#123; sum[root] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1];&#125;void build(int l, int r, int root)&#123; if (l == r) sum[root] = a[l]; else &#123; int mid = (l + r) &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void update(int l, int r, int root)&#123; if (l == r) sum[root] += y; else &#123; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(l, mid, root &lt;&lt; 1); else update(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void query(int l, int r, int root)&#123; if (l &gt;= x &amp;&amp; r &lt;= y) &#123; ans += sum[root]; return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) query(l, mid, root &lt;&lt; 1); if (y &gt; mid) query(mid + 1, r, root &lt;&lt; 1 | 1);&#125;void init()&#123; memset(sum, 0, sizeof sum); memset(add, 0, sizeof add); build(1, n, 1);&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; T; for (int T_T = 1; T_T &lt;= T; T_T++) &#123; printf("Case %d:\n", T_T); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; init(); while (cin &gt;&gt; st) &#123; ans = 0; if (st == "End") break; cin &gt;&gt; x &gt;&gt; y; if (st == "Sub") y *= -1; if (st == "Query") query(1, n, 1), printf("%d\n", ans); else update(1, n, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio 忽略错误]]></title>
    <url>%2F2018%2F07%2F28%2FVisual-Studio-%E5%BF%BD%E7%95%A5%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[正文问题用Visual Studio写程序时，OI界选手都知道12freopen("file","r",stdin);freopen("file","w,"stdout); 是比赛时必不可少的然而你用VS编译时会报错，显示freopen不安全，要用freopen_s然而不会用怎么办？我们选择手动忽略错误 解决1#pragma warning(disable:4996) 这句话用于忽略报freopen错的C4996错误信息其余错误信息同理]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器的一般食用方法]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%80%E8%88%AC%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正文 首先你得下一个编译器（在线版或离线版安装），途径如下： 群文件里 网上（推荐是官网下） 若在线版，则运行并安装，记安装路径为X:\Y\ Windows用户 32位选x86（也可能叫i386-win32之类的） 64位选x86_64或x86均可 Linux用户apt-get之类的基本可以关掉本文档了 若离线版，则解压至X:\Y\ 在安装目录下找到一个叫做bin的文件夹，里面通常会有名叫g++.exe之类的文件 按Windows徽标键，输入path，选择“编辑系统环境变量” 单击“环境变量(N)”，在下面“系统变量(S)”里面寻找变量名为Path的变量 双击该变量 Windows 10用户单击新建(N)，将X:\Y\bin粘贴进去，确定-确定-确定 其他Windows用户在Path已有的路径后面加个英文分号“;”（注意一定是英文分号），后面粘贴X:\Y\bin，确定-确定-确定 Windows徽标键+R，输入cmd，输入g++ -v，看看有没有诸如“gcc version 8.1.0 (x86_64-win32-seh-rev0, Built by MinGW-W64 project)”的信息文件 如果有，恭喜你成功配置了编译器 如果没有，重启试试看，有些系统需要重启才可生效 一般重启后会生效 没生效的话在群里询问吧]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder」 ABC 103]]></title>
    <url>%2F2018%2F07%2F23%2FAtCoder-ABC-103%2F</url>
    <content type="text"><![CDATA[题外话永远记住日本时间比中国早1个小时！这篇比较水，除了T3 题目链接AtCoder ABC 103 题解T1纯暴力不解释 代码1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a, b, c;#define X abs(a-b)#define Y abs(b-c)#define Z abs(a-c)int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; min(X + Y, min(X + Z, Y + Z)) &lt;&lt; endl; return 0;&#125; T2纯暴力，字符串的函数需要熟悉一些 代码123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;string S, T;int main(int argc, char ** argv)&#123; getline(cin, S); getline(cin, T); for (int i = S.length(); i; i--) &#123; char ch = S[S.length() - 1]; S.erase(S.length() - 1, 1); S.insert(S.begin(), ch); if (S == T) &#123; cout &lt;&lt; "Yes\n"; return 0; &#125; &#125; cout &lt;&lt; "No\n"; return 0;&#125; T3这题真的是给Beginner做的？虽然代码比较短小精悍这题就是要我们证明对于序列${a_1,a_2,\dots,a_n}$，存在$x\equiv(a_k-1)(\mathrm{mod}\,a_k),1\leqslant k\leqslant n$当然，稍微想想会会发现$\prod_{k=1}^na_k-1$即为满足上述条件的$x$既然存在$x$，则最大的$f$值就显而易见是$\sum_{k=1}^n(a_k-1)=\sum_{k=1}^na_k-n$那么就可以相当完美地解决这道题 代码123456789101112#include &lt;iostream&gt;using namespace std;int n, ans, a;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a, ans += a; cout &lt;&lt; ans - n &lt;&lt; endl; return 0;&#125; T4上来就想到DP，想了一会发现是贪心，然后我就跪在了sort()上……STL的东西最好还是了解怎么回事再用！贪心的思路很好想，具体看代码 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Edge&#123; int st, ed;&#125;;Edge a[100010];int n, m, ans;bool cmp(Edge x, Edge y)&#123; if (x.ed == y.ed) return x.st &lt; y.st; else return x.ed &lt; y.ed;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i].st &gt;&gt; a[i].ed; sort(a + 1, a + m + 1, cmp); int Cur = 0; for (int i = 1; i &lt;= m; i++) &#123; if (a[i].st &gt;= Cur) &#123; ans++; Cur = a[i].ed; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 后记本篇博文相当水……当然也不是我故意的为了肝后面一篇重磅的数学博文，OI只能稍稍搁置一下了顺带说一句绝对不要对后面一篇博文抱有什么能看得懂的幻想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>AtCoder</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1281」 书的复制]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%B4%9B%E8%B0%B7-1281%2F</url>
    <content type="text"><![CDATA[题外话写这篇博文的目的有两个，一是好久没有写关于OI的博文，二是某大佬说最好写一下提醒别人别被数据坑了……毕竟我被这题的神奇数据坑了2个多小时 题目链接洛谷 1281话说洛谷换新的url了 题解用一句非常精辟的话概括题意（不是我想出来的）：寻找一种分配方案，使抄写页数最多的最少很明显的二分就出来了不过二分只能找出答案，根据答案推每个人的任务还需要处理鉴于题目中说“尽可能让前面的人少抄写”，故从尾至头贪心，给后面的人分配的越多越好由于是从后往前分配任务的，输出是从前往后，于是采用栈记录输出的数据，当然也可以用递归输出 坑你以为就这样完了？我那3次WA就是这么来的……事实上，对于$m=0,k=0$的情况是不用输出的……真的巨坑啊…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;int m, k;int Max;int a[100001];stack &lt;int&gt; outl;stack &lt;int&gt; outr;bool judge(int t)&#123; int sum = 0; int pseudo_peo = 1; for (int i = 1; i &lt;= m; i++) &#123; if (a[i]&gt;t) return false; if (sum + a[i] &lt;= t) sum += a[i]; else &#123; sum = a[i]; pseudo_peo++; &#125; &#125; return pseudo_peo &lt;= k;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; m &gt;&gt; k; if (!m &amp;&amp; !k) &#123; return 0; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a[i]; Max += a[i]; &#125; int l = 1, r = Max; while (l&lt;r) &#123; int mid = (l + r) / 2; if (judge(mid)) r = mid; else l = mid + 1; &#125; int ans = l; int sum = 0; int cntpeop = k - 1; r = m; for (int i = m; i; i--) &#123; if (sum + a[i] &lt;= ans &amp;&amp; i&gt;cntpeop) &#123; sum += a[i]; l = i; &#125; else &#123; outl.push(l); outr.push(r); l = r = i; sum = a[i]; cntpeop--; &#125; &#125; cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl; while (!outl.empty()) &#123; cout &lt;&lt; outl.top() &lt;&lt; " " &lt;&lt; outr.top() &lt;&lt; endl; outl.pop(); outr.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 图床]]></title>
    <url>%2F2018%2F07%2F11%2FGitHub-%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[正文 create a repository clone 到本地 将想要上传的图片push 进入图床repository，找到你刚才push的图片 左键单击查看图片 在图片上右击-在新标签页中打开图片 复制图片url 该url即可直接调用 注意：以“https://github.com/” 开头的并不是你图片的url正常情况下url应以“https://raw.githubusercontent.com/” 开头在调用时严格区分大小写，包括文件扩展名的大小写！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 添加搜索功能]]></title>
    <url>%2F2018%2F04%2F07%2FHexo-%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[题外话这个搜索功能坑了我好久…… 正文Step 11$ npm install hexo-generator-searchdb --save Step 2打开站点根目录_config.yml Step 3在文末加上 search: path: search.xml field: all format: html limit: 10000 Step 4打开NexT主题_config.yml Step 5找到local_search，将enable改为true]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 任务栏透明优化]]></title>
    <url>%2F2018%2F04%2F07%2FWindows-%E4%BB%BB%E5%8A%A1%E6%A0%8F%E9%80%8F%E6%98%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题外话这是我第一次用Menci大大开发的Moeditor写markdown文件，相比较Notepad++纯感觉无预览，使用感觉还是相当不错的。话说像我这种用GitHub当图床的也没谁了吧…… 正文初衷作为一名重度强迫症患者，说实话我很难容忍Windows任务栏与桌面的格格不入。 Step 1有问题先Google百度。先试了一下StartIsBack，发现不能设置全屏开始菜单栏，于是果断放弃。 Step 2百度不靠谱，只能上知乎。在知乎上找到了TranslucentTB。readme.md又指导我们访问AppVeyor artifacts以获取最新版（尽管是开发版）。下载&amp;使用，效果可以说是接近完美。附上效果图： 设置 显示隐藏图标-找到TranslucentTB-右击 勾选“Open at boot”，这样默认开机自启 鼠标移至Regular State-选择想要的效果 找到TranslucentTB.exe根目录，打开config.cfg 找到第二行 accent= ，等号后面的blur改为刚才你选择的效果（normal, clear, opaque, blur） 附对照表： 选项 效果 normal 系统默认 clear 全透明 opaque 不透明 blur 模糊]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 1160」 Post Office]]></title>
    <url>%2F2018%2F01%2F06%2FPOJ-1160%2F</url>
    <content type="text"><![CDATA[题外话话说原本mathjax老是出故障的\$\$突然变正常了，开心~ 题目链接POJ 1160 大意在$V$个村庄里选$P$个作为邮局，使得每个村庄到距它最近的邮局的距离和最短。 题解裸典型的区间DP。设$f(i,j)$表示前$i$个村庄内建立$j$个邮局的最小距离和，最终答案即为$f(V,P)$。可以想到，前$i$个村庄内建立$j$个邮局即为前$k$个村庄建立$j-1$个邮局、第$k+1$到第$i$个村庄建一个邮局。设$w(i,j)$表示在村庄$i$、$j$之间建立一个邮局后，该邮局与村庄$i$、$j$的最短距离和。易得：$w(i,j)=w(i,j-1)+a(j)-a((i+j)/2)$。可能有人会问，如果$i+j$为偶，则位置能确定（$(i+j)/2\in N^*$）；但若$i+j$为偶，是选$\lceil (i+j)/2 \rceil$还是$\lfloor (i+j)/2 \rfloor$呢？我们可以假设共有6个村庄，要在范围$[1..6]$内选择1个做邮局。根据上面疑问，我们分别选取$\lceil (i+j)/2 \rceil$即4与$\lfloor (i+j)/2 \rfloor$即3做比较。设每个村庄位置分别为$a_i$。 选取4。则总距离为：$$(a_4-a_1)+(a_4-a_2)+(a_4-a_3)+0+(a_5-a_4)+(a_6-a_4)=a_6+a_5+a_4-a_3-a_2-a_1$$ 选取3。则总距离为：$$(a_3-a_1)+(a_3-a_2)+0+(a_4-a_3)+(a_5-a_3)+(a_6-a_3)=a_6+a_5+a_4-a_3-a_2-a_1$$ 因此，可得当$i+j$为偶时，选$\lceil (i+j)/2 \rceil$与$\lfloor (i+j)/2 \rfloor$ 等价。计算$w$数组时可以用前缀和优化，在此不赘述。综上，不难得方程：$f(i,j)=min\lbrace f(i,j),f(k,j-1)+w(k+1,j)\rbrace$时间复杂度$O(pv^2)$ 代码 - 裸12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) &#123; for (int j = i + 1; j &lt;= v; j++) &#123; w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; &#125; &#125; memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) &#123; f[i][i] = 0; f[i][1] = w[1][i]; &#125; for (int j = 2; j &lt;= p; j++) &#123; for (int i = j + 1; i &lt;= v; i++) &#123; for (int k = j - 1; k &lt; i; k++) &#123; f[i][j] = min(f[i][j], f[k][j - 1] + w[k + 1][i]);//注意别写到括号外面去 &#125; &#125; &#125; cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;&#125; 优化在这里，我们要用到一个叫做四边形不等式的东西。 四边形不等式此问题中包含着一个常见的状态转移方程：$$f(i,j)=min\lbrace f(i,k-1)+f(k,j)+w(i,j)\rbrace$$假如对于任意$i\leq i’&lt;j\leq j’$，都有$w(i’,j)\leq w(i,j’)$，那么我们称函数$w$满足关于区间包含的单调性另外，假如有：$$w(i,j)+w(i’,j’)\leq w(i’,j)+w(i,j’)$$那么我们称函数$w$满足四边形不等式。不等式较抽象，建议画图理解。理解后，我们引出两个定理：1、若上述函数$w$同时满足区间包含单调性与四边形不等式，那么函数$f$也满足四边形不等式，即：$$f(i,j)+f(i’,j’)\leq f(i’,j)+f(i,j’),\;i\leq i’&lt;j\leq j’$$我们再定义函数$s(i,j)$表示$f(i,j)$取得最优值时对应的$k$。此时有定理：2、若上述函数$f$满足四边形不等式，则函数$s$单调，即：$$s(i,j)\leq s(i,j+1)\leq s(i+1,j+1)$$得出结论2后，我们发现：$s(i,j-1)\leq s(i,j)\leq s(i+1,j)$因此函数$f$等价于：$$f(i,j)=min\lbrace f(i,k-1)+f(k,j)+w(i,j)\rbrace,\;s(i,j-1)\leq k\leq s(i+1,j)$$ 回到问题理解四边形不等式后，我们发现：本题的$f$也满足四边形不等式（证明实在没力气了）。因此，本题可以优化成$O(vp)$。 代码 - 优化123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int s[1001][1001];int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) &#123; s[i][i] = i; for (int j = i + 1; j &lt;= v; j++) &#123; w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; &#125; &#125; memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) f[i][1] = w[1][i]; for (int i = 1; i &lt;= p; i++) s[v + 1][i] = v;//计算可能越界 for (int i = 1; i &lt;= p; i++) &#123; for (int j = v; j &gt; i; j--) &#123; for (int k = s[j][i - 1]; k &lt;= s[j + 1][i]; k++) &#123; if (f[j][i] &gt; f[k][i - 1] + w[k + 1][j]) &#123; f[j][i] = f[k][i - 1] + w[k + 1][j]; s[j][i] = k; &#125; &#125; &#125; &#125; cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>DP</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio 保存文件编码格式]]></title>
    <url>%2F2017%2F12%2F04%2FVisual-Studio-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题外话Visual Studio确实是最强的IDE，但功能太复杂了啊……每年产品的界面都不一样。2017企业版的默认保存为LINUX格式的，Windows下只能用Notepad++打开，很是苦恼。网上都说安装什么破插件。最后终于找到一篇正常的了…… 正文添加“高级保存选项” 单击“工具”|“自定义”命令，弹出“自定义”对话框。 单击“命令”标签，进入“命令”选项卡。 在“菜单栏”下拉列表中，选择“文件”选项。 单击“添加命令”按钮，弹出“添加命令”对话框。 在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”按钮，关闭“添加命令”对话框。 选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。 单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 更改保存格式更改成自己想要的编码即可。 参考解决Visual Studio 2017隐藏“高级保存选项”命令]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 2823」 Sliding Window]]></title>
    <url>%2F2017%2F11%2F26%2FPOJ-2823%2F</url>
    <content type="text"><![CDATA[题外话这题提交方式很玄学……C++交就TLE，改成G++就AC了…… 题目链接POJ 2823 题解首先我们想到暴力模拟，妥妥的TLE，加上POJ老掉牙的机器，不知道T成什么样了……既然模拟不可行，那么我们只能考虑一种新的方法。目前我们貌似没有掌握一种算法能快速算区间最大值的，因此我们只能从数据结构入手。堆？你怎么确定元素是否超出窗口边界？用struct？那还怎么用STL的priority_queue？线段树？和堆一样的问题（怎么删除超出边界的元素）。我们发现，我们需要的是一种 能支持\(O(1)\)输出队列最大值 具有队列的一切功能（进队、出队） 要实现这两个功能，我们只能请出新的角色——单调队列 单调队列上文已经说明单调队列的作用了，接下来我们要讨论如何实现单调队列。首先队列清空（这里有个坑，留待你发掘）。遇到即将入队的新元素，将它与队尾元素比较，如果大于队尾元素就不断弹出队尾元素，直到队尾元素大于即将入队的元素位置。新元素进队。保证队列元素都在规定范围内：判断队首元素是否超过边界，若超过，就不断弹出队首元素，直到队首元素在规定范围内。规定范围内的最大值就是该队列的队首元素。由于要实现两端都能出队的队列，只能挥泪告别STL，迎接手写queue了…… 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, k;int a[1000005];int q[1000005];//队列int p[1000005];//下标struct Number&#123; int pos, val;&#125;num[1000005];void SolBig()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; &#125; cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; &#125; cout &lt;&lt; endl;&#125;void SolSml()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; &#125; cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; &#125; cout &lt;&lt; endl;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; SolSml(); SolBig(); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2017」普及组复赛解题报告]]></title>
    <url>%2F2017%2F11%2F25%2FNOIP-2017%E6%99%AE%E5%8F%8A%E7%BB%84%E5%A4%8D%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题外话吐槽一下CCF的老爷机：CPU AMD Athlon(tm) II x2 240 processor，2.8GHz大概是什么价位的呢？参考报价：￥185 停产 2014-04-14（摘自中关村在线）都2017年了还不换新机子？？ 题目链接百度网盘 P1 成绩题解这题是给智商80-的人写的……不过官方好像说有精度问题（题目中明明写着“A、B、C 都是 10 的整数倍”啊）然后重测了。 代码12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;double a, b, c;int main(int argc, char ** argv)&#123; freopen("score.in", "r", stdin); freopen("score.out", "w", stdout); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; floor(a*0.2 + b*0.3 + c*0.5) &lt;&lt; endl; return 0;&#125; P2 图书管理员题解比较水啊，但注意图书编号不能只用string存，因为字符串大小和数字大小有区别。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int n, q;string st[1005];int nb[1005];int main(int argc, char ** argv)&#123; freopen("librarian.in", "r", stdin); freopen("librarian.out", "w", stdout); memset(nb, 0, sizeof(nb)); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; st[i]; for (int j = 0; j&lt;st[i].length(); j++) nb[i] = (nb[i] &lt;&lt; 3) + (nb[i] &lt;&lt; 1) + (st[i][j] ^ 48); &#125; for (int i = 0; i&lt;q; i++) &#123; bool flag = false; int tmp; int _min = 0x7f7f7f7f; string nd; cin &gt;&gt; tmp &gt;&gt; nd; for (int j = 0; j&lt;n; j++) &#123; if (st[j].length()&lt;nd.length()) continue; if (st[j].substr(st[j].length() - nd.length(), nd.length()) == nd) &#123; _min = min(_min, nb[j]); flag = true; &#125; &#125; if (!flag) cout &lt;&lt; "-1" &lt;&lt; endl; else cout &lt;&lt; _min &lt;&lt; endl; &#125; return 0;&#125; P3 棋盘题解两种解法。第一种是建图+最短路，第二种是DFS+记忆化。出于懒得写图让你们更简单地A掉这题的缘故，我决定写DFS。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define INF 0x7f7f7f7fint n, m;int a[105][105];int v[105][105];int f[105][105];void dfs(int x, int y, bool chd, int cst, int col)&#123; if (x&gt;m || y&gt;m || x &lt;= 0 || y &lt;= 0) return; if (chd&amp;&amp;a[x][y] == INF) return; else if (!chd&amp;&amp;a[x][y] == INF) &#123; cst += 2; chd = true; &#125; else if (a[x][y] != INF) &#123; if (a[x][y] != col) cst++; col = a[x][y]; chd = false; &#125; if (cst &lt; f[x][y]) f[x][y] = cst; else return; dfs(x-1, y, chd, cst, col); dfs(x, y-1, chd, cst, col); dfs(x, y+1, chd, cst, col); dfs(x+1, y, chd, cst, col);&#125;int main(int argc, char ** argv)&#123; freopen("chess.in", "r", stdin); freopen("chess.out", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; m &gt;&gt; n; memset(a, INF, sizeof(a)); memset(f, INF, sizeof(f)); for (int i = 1; i &lt;= n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cin &gt;&gt; a[x][y]; &#125; dfs(1, 1, 0, 0, a[1][1]); if (f[m][m] == INF) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; f[m][m] &lt;&lt; endl; return 0;&#125; P4 跳房子题解一眼看出是二分，check()函数用DP。设\(f(i)\)表示跳到第\(i\)个格子最大分数。显而易见，\(f(i)=max \lbrace f(j) \rbrace +s_i\)，且从第\(j\)个格子能跳到第\(i\)个格子。裸的DP能拿50分，下面考虑优化。由于计算的是一个单调区间的最大值，并且该区间不断后移，我们可以考虑用单调队列实现。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define MAXN 500005int n, d, k;int h, t;long long f[MAXN];long long x[MAXN];long long s[MAXN];long long q[MAXN];void push(int add)&#123; while (f[q[t]] &lt;= f[add] &amp;&amp; h &lt;= t) t--; q[++t] = add;&#125;bool chk(int g)&#123; memset(f, -0x7f7f7f7f, sizeof(f)); f[0] = 0; h = 1; t = 0; int p = 0; q[h] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (x[i] - x[p] &gt;= max(d - g, 1) &amp;&amp; p &lt; i) push(p++); while (x[i] - x[q[h]] &gt; d + g&amp;&amp;h &lt;= t) h++; if (h &gt; t || f[q[h]] == -0x7f7f7f7f) continue; else f[i] = f[q[h]] + s[i]; if (f[i] &gt;= k) return true; &#125; return false;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); freopen("jump.in", "r", stdin); freopen("jump.out", "w", stdout); cin &gt;&gt; n &gt;&gt; d &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; s[i]; if (!chk(x[n])) cout &lt;&lt; -1; else &#123; int l = 1, r = x[n]; while (l &lt; r) &#123; int mid = (l + r) / 2; if (chk(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」普及组复赛解题报告]]></title>
    <url>%2F2017%2F10%2F18%2FNOIP-2016%E6%99%AE%E5%8F%8A%E7%BB%84%E5%A4%8D%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接百度网盘 P1 买铅笔题解这题分外水啊……几个if就可以AC。考试时3分钟敲完……但今年懒得用if写了十几分钟…… 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, ans;int main(int argc, char ** argv)&#123; freopen("pencil.in","r",stdin); freopen("pencil.out","w",stdout); ans = 0x7f7f7f7f; cin &gt;&gt; n; for (int i = 1; i &lt;= 3; i++) &#123; int num, cost; cin &gt;&gt; num &gt;&gt; cost; ans = min(ans, (n / num + ((bool)(n - (n / num)*num)))*cost); //(bool)将int类余数强制转换成bool，若n能整除num（即不用再多买），则余数为0（false）。 //否则表达式的值就是true（非0即真），要多买一盒。 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P2 回文日期题解考试的时候敲了16KB（是的，你没看错，16KB），搞得监考老师查程序的时候差点叫出来……万幸的是AC了……解此题有两种方法。1、穷举日期（00000000~99999999），加上一堆检查，时间复杂度≈\(O(2×10^8)\)，比较险。2、穷举年份。因为每个年份存在多个日期，但只可能存在一个回文的，所以只要穷举年份，构造出回文日期，再判断是否合法即可。 代码123456789101112131415161718192021222324252627282930313233//穷举年份#include&lt;iostream&gt;using namespace std;int stime, etime, ans;const int Mon[] = &#123; 0,31,28,31,30,31,30,31,31,30,31,30,31 &#125;;bool spe(int yea)&#123; return !(yea % 4) &amp;&amp; yea % 100 || !(yea % 400);//!(X % Y)：判断X是否整除Y，别写反。也要注意!的优先级比%高&#125;int main(int argc, char ** argv)&#123; freopen("date.in", "r", stdin); freopen("date.out", "w", stdout); cin &gt;&gt; stime &gt;&gt; etime; for (int i = stime / 10000; i &lt;= etime / 10000; i++) &#123; int pres = i * 10000 + (i % 10) * 1000 + (i % 100 / 10) * 100 + (i % 1000 / 100) * 10 + i / 1000; int mon = pres % 10000 / 100; int day = pres % 100; if (spe(pres / 10000) &amp;&amp; mon == 2) if (day &lt;= 29) if (pres &gt;= stime&amp;&amp;pres &lt;= etime) &#123; ans++; continue; &#125; if (day &lt;= Mon[mon] &amp;&amp; mon &lt;= 12) if (pres &gt;= stime&amp;&amp;pres &lt;= etime) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P3 海港题解考试的时候作死，做出来70分胡改改成了25分……70分做法：按船存储数据，对于每艘船，找它和一天之前所有船的人员国籍。100分做法：按人存储数据。由于每艘船上的人的到港时间都是一样的，所以只需记录下每艘船到的时间和每个人的国籍。维护一个\(sum\)记录国籍总数，遇到一天前的船（人）就减去国籍数。详细内容见代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;int num_data;int Sear;int sum;int nati[100005];int peop[100005];struct Ship&#123; int first, last, time;&#125;ship[100005]; int Binary_search(int left, int right)//二分查找最近的超过一天的船&#123; int ans = 0; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (Sear - ship[mid].time &gt;= 86400) &#123; ans = max(ans, mid); left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return ans;&#125;int main(int argc, char ** argv)&#123; freopen("port.in", "r", stdin); freopen("port.out", "w", stdout); cin &gt;&gt; n; int lastship = 0;//上一个（记录过的）超过一天的船 for (int i = 1; i &lt;= n; i++) &#123; int Peop; cin &gt;&gt; ship[i].time &gt;&gt; Peop; Sear = ship[i].time; ship[i].first = ship[i - 1].last + 1; ship[i].last = ship[i].first + Peop - 1; for (int j = 1; j &lt;= Peop; j++) &#123; cin &gt;&gt; peop[++num_data]; if (!nati[peop[num_data]]) sum++; nati[peop[num_data]]++; &#125; int BS = Binary_search(1, i); if (BS)//存在一个（最近的）一天前的船，因此，一天前的船即为lastship+1~BS的船 &#123; for (int j = ship[lastship + 1].first; j &lt;= ship[BS].last; j++)//lastship已经记录过，因此循环从lastship+1开始 &#123; nati[peop[j]]--; if (!nati[peop[j]]) &#123; sum--; &#125; &#125; lastship = BS; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 解释看到这里相信肯定有读者有疑惑：为什么你能保证\(sum\)的值一定是当前国籍总数？注意到，我们的\(nati_i\)记录的是拥有国籍\(i\)的人的一天内的总数。当发现有船到港时间在一天前，减去该船所有人的国籍记录即可。若减下来\(nati\)数组某国人数为0，就代表了一天内没有该国人到港。由于到港时间是单调上升的，上艘船的前一天到港的船只也必定是本艘船前一天到港的，因此本艘船的数据可以沿用上一艘的记录。 P4 魔法阵题解这题拿到手先暴力……暴力完开始想正解。由于\(n\)和\(m\)都比较大，并且题目中有几个方程，肯定想到用数学方法解。当然差分约束从方程入手。为方便，记\(x_a\)为\(A\)、\(x_b\)为\(B\)，\(C\)、\(D\)同理。\(\because B−A=2(D−C),\ B-A&lt;(C-B)/3\)\(\therefore 2(D-C)&lt;(C-B)/3\)\(\therefore C-B&gt;6(D-C)\)设\(D-C=i\)则\(B-A=2i\)\(C-B&gt;6i\)\(\therefore D-A&gt;9i\)推完后，我们发现先确定\(i\)，再枚举\(D\)，就能把\(C\)求出来，同理，枚举\(A\)，就能把\(B\)求出来。维护4个数组记录每样物品分别作为\(A,B,C,D\)的次数，根据简单的乘法原理和加法原理可以算出来方案数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt; using namespace std;int x[40005];int s[40005];int a[40005];int b[40005];int c[40005];int d[40005];#define q ' 'int n, m;int main(int argc, char ** argv)&#123; freopen("magic.in", "r", stdin); freopen("magic.out", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x[i]; s[x[i]]++; &#125; for (int i = 1; i * 9 + 1 &lt;= n; i++) &#123; int sum = 0; for (int D = i * 9 + 2; D &lt;= n; D++) &#123; sum += s[D - 7 * i - 1] * s[D - 9 * i - 1]; c[D - i] += s[D] * sum; d[D] += s[D - i] * sum; &#125; sum = 0; for (int A = n - i * 9 - 1; A; A--) &#123; sum += s[A + i * 9 + 1] * s[A + i * 8 + 1]; a[A] += s[A + 2 * i] * sum; b[A + 2 * i] += s[A] * sum; &#125; &#125; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; a[x[i]] &lt;&lt; q &lt;&lt; b[x[i]] &lt;&lt; q &lt;&lt; c[x[i]] &lt;&lt; q &lt;&lt; d[x[i]] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++探索」 main函数参数]]></title>
    <url>%2F2017%2F08%2F01%2FC%2B%2B-main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[说明今天突然不想用VS了，打开Dev-C++又胡乱设置一通。突然在Dev-C++的菜单-工具-编译器属性-语法里看到这样一段：1int main(int argc, char **argv) 顿时懵了：main函数还带参数？？于是别人博客+自行摸索，总结出如下结论（注意：方便起见，讨论的将先是int main(int argc, char * argv[])，不要问我为什么）。 讨论char * argv[]先编写以下代码：123456789#include&lt;iostream&gt;using namespace std;int main(int argc, char * argv[])&#123; cout &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) cout &lt;&lt; argv[i] &lt;&lt; endl; return 0;&#125; 注意，这里直接运行会得到以下结果： 1 D:\Program\Debug\Program.exe 看的是不是云里雾里？既然输出了程序的路径，那么我们放到cmd里运行试试。1D:\Program\Debug\Program.exe 输出一样。那么，1是什么？让我们尝试运行以下指令：1D:\Program\Debug\Program.exe Sena 输出： 2 D:\Program\Debug\Program.exe Sena 似乎有点明白了？再运行以下指令：1D:\Program\Debug\Program.exe Sena Senb Senc 输出： 4 D:\Program\Debug\Program.exe Sena Senb Senc 现在很明显了：argc是命令行参数的个数，argv[]存的是命令行的参数。而argv[0]指向exe程序路径。 char ** argv可能你会说，上面更改了原来的参数，并不能说明问题。因此下面我们研究char * argv[]与char ** argv 的区别。先看char * argv[]。由于[]的优先级高于*，所以a先与[]组合，因此argv是一个数组，数组中的元素类型是char *。对于char ** argv，argv是二级指针（指针的指针），指向一级指针char *的地址。而char *本身是个指向第一个字符的指针！所以不严谨的看，char * argv[]等价于char ** argv。之所以说不严谨，是因为char *存放在常量区，而char []存放在栈中。前者赋初值后不能更改，而后者可以。编写以下代码：12345678910#include&lt;iostream&gt;using namespace std;int main(int argc, char ** argv)&#123; cout &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) cout &lt;&lt; argv[i] &lt;&lt; endl; system("pause"); return 0;&#125; 其输出与char * argv[]无异。若将第7行改为cout &lt;&lt; *argv[i] &lt;&lt; endl;的话，则输出： 1 D cmd中运行以下指令：1D:\Program\Debug\Program.exe Sena Senb Senc 输出： 4 D S S S 输出的是每个参数的首字母，因为char *本身是个指向第一个字符的指针。 总结看完本文，相信读者已经对main函数的参数有了一定的了解，同时对指针有了更深的认识。当然，由于本文并未涉及字符串的编辑，所以char * argv[]与char ** argv的区别并没有真正体现出来。这将在以后的学习过程中提及。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++关键字」 register]]></title>
    <url>%2F2017%2F08%2F01%2FC%2B%2B-register%2F</url>
    <content type="text"><![CDATA[说明众所周知，计算机在运行程序时，会读取程序存储在硬盘的数据，数据被加载在内存里面，即可执行命令。而存放在CPU寄存器里的数据存取速度比内存快得多。然而，CPU寄存器数量有限，所以不能存储太多数据。所以我们只取优化较大的变量存储到CPU寄存器里。这时候，我们就要用到register关键字。 定义register修饰符暗示编译程序相应的变量将被频繁地使用。 注意点 register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。 因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。 实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。 只有函数参数和局部变量可被声明为register。 register变量的生命周期只维持在它所声明的块中。 测试下面对比使用register关键字前后的运行速度。 代码1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;int main()&#123; LARGE_INTEGER st, ed, t; QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); for (int i = 1; i &lt;= 700; i++) for (int j = 1; j &lt;= 700; j++) for (int k = 1; k &lt;= 700; k++) ; QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time (unregistered) : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; //====================// QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); for (register int i = 1; i &lt;= 700; i++) for (register int j = 1; j &lt;= 700; j++) for (register int k = 1; k &lt;= 700; k++) ; QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time (registered) : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出：Use time (unregistered) : 0.88237 Sec.Use time (registered) : 0.855508 Sec.可以看到是有些优化的。将循环改到\(800^3\)，输出：Use time (unregistered) : 1.322 Sec.Use time (registered) : 1.19792 Sec.再改到\(1000^3\)，输出：Use time (unregistered) : 2.63044 Sec.Use time (registered) : 2.23786 Sec.改为\(350,000,000\)的一重循环，发现反例：Use time (unregistered) : 0.989227 Sec.Use time (registered) : 1.19519 Sec. 总结虽然register关键字有小幅优化（有时则相反），但对于\(O(N^3)\)的时间复杂度也力不从心。所以，优化算法才是王道！ 参考C++中register关键字]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++技巧」 计时]]></title>
    <url>%2F2017%2F07%2F31%2FC%2B%2B-%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[说明计时可以在C++里面方便地实现，可以在诸如NOIP、NOI之类的比赛中了解算法最坏运算时间。当然，如果对于自己算法的时间复杂度很有信心的话（\(O(N)\)之类的）请移步……不过如果复杂度到了\(O(N^2)\)或\(O(N \log N)\)的级别的话还是建议测一下，前提是你会敲……毕竟第2、3种方法比较复杂，考试时用的是Dev-C++又不是Visual Studio。 方法1用time()函数获取当前系统时间。time()函数返回的是time_t类型的数据，返回值是从1970年1月1日（UNIX TIME的纪元时间）到当前时刻的秒数。 代码123456789101112131415161718#include&lt;iostream&gt;#include&lt;time.h&gt;using namespace std;time_t st, ed;void work()&#123; for (int i = 1; i &lt;= 300000000; i++) ;&#125;int main()&#123; st = time(NULL); work(); ed = time(NULL); cout &lt;&lt; "Use Time : " &lt;&lt; ed - st &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Use Time : 1 Sec. 可以看到C++循环里啥都不干1秒能跑3亿次循环。 方法2（实属无聊）用SYSTEMTIME里的函数获取当前系统时间（毫秒级）。 代码12345678910111213141516171819#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;void work()&#123; for (int i = 1; i &lt;= 300000000; i++) ;&#125;int main()&#123; SYSTEMTIME st, ed; GetLocalTime(&amp;st); work(); GetLocalTime(&amp;ed); cout &lt;&lt; "Start Time : " &lt;&lt; st.wYear &lt;&lt; '/' &lt;&lt; st.wMonth &lt;&lt; '/' &lt;&lt; st.wDay &lt;&lt; ' ' &lt;&lt; st.wHour &lt;&lt; ':' &lt;&lt; st.wMinute &lt;&lt; ':' &lt;&lt; st.wSecond &lt;&lt; ':' &lt;&lt; st.wMilliseconds &lt;&lt; " Week" &lt;&lt; st.wDayOfWeek &lt;&lt; endl; cout &lt;&lt; "End Time : " &lt;&lt; ed.wYear &lt;&lt; '/' &lt;&lt; ed.wMonth &lt;&lt; '/' &lt;&lt; ed.wDay &lt;&lt; ' ' &lt;&lt; ed.wHour &lt;&lt; ':' &lt;&lt; ed.wMinute &lt;&lt; ':' &lt;&lt; ed.wSecond &lt;&lt; ':' &lt;&lt; ed.wMilliseconds &lt;&lt; " Week" &lt;&lt; ed.wDayOfWeek &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Start Time : 2017/8/1 20:55:50:369 Week2 End Time : 2017/8/1 20:55:51:209 Week2 推翻上面数据。跑3亿次循环仅需840毫秒，上面的情况只是由于测试是在起始秒的第160毫秒后计算的。用此程序测得1s最多循环次数为344,795,000（1.001s）。注意：要看CPU和内存的性能，相同机器不同时间可能结果有异。 方法3（更无聊了）用QueryPerformanceCounter()函数返回高精确度性能计数器的值（微秒级）。 代码12345678910111213141516171819#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;void work()&#123; for (int i = 1; i &lt;= 350000000; i++) ;&#125;int main()&#123; LARGE_INTEGER st, ed, t; QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); work(); QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Use time : 0.93279 Sec. 事实证明3亿5千万完全没压力（运气好的话）。 结尾其实方法远不止这3种……。NOIP的话建议第二种即可，第一种实在不敢恭维。再次注意不要迷信测出来的时间！具体运行时间要看CPU、内存的性能及人品！NOIP好运！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1553」 数字反转（升级版）]]></title>
    <url>%2F2017%2F07%2F31%2F%E6%B4%9B%E8%B0%B7-1553%2F</url>
    <content type="text"><![CDATA[题外话这题也坑了我好久……谁说分到“简单”字符串的？？？话说好像字符串的题一碰就死……然而【狡（Wei）黠（Suo）的微笑】，这题可以不用字符串。所以你没看到上面的Tags有一个STL啊？？语言歧视（笑）。欸，你没发现题解几乎和洛谷 1308一毛一样？？？ 题目链接洛谷 1553 题解本题考点是字符串的操作，如果你聪明的话也可以用stack实现。也是两种解法：一是找出特殊字符位置做相应处理，二是像我一样用stack实现（其实我也是看到别人题解才恍然大悟的）。由于第二种方法涉及到STL，所以就写第二种了（Pascal党请移步）。细节较多，请自己体会。 解释为什么可以用stack实现？原因在于stack（栈）这种线性数据结构的特性：FILO（First In Last Out）刚好符合题中反转的要求！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;sstream&gt;//stringstreamusing namespace std;stack &lt;char&gt; stac;string st;char ch, op;bool flag;int main()&#123; getline(cin, st); stringstream read(st);//用stringstream只为锻（Zhuang）炼（Bi） flag = true; while (read &gt;&gt; ch) &#123; if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; if (op != '.') stac.push(ch);//进栈 else &#123; if (!(ch == '0' &amp;&amp; flag)) stac.push(ch); if (ch != '0') flag = false; &#125; &#125; else &#123; op = ch; while (!stac.empty() &amp;&amp; stac.top() == '0')//是否为空栈 stac.pop();//出栈 if (stac.empty()) cout &lt;&lt; 0; while (!stac.empty()) &#123; cout &lt;&lt; stac.top();//取栈顶元素 stac.pop(); &#125; cout &lt;&lt; op; &#125; &#125; while (!stac.empty() &amp;&amp; stac.top() == '0') stac.pop(); if (op != '%') if (stac.empty()) cout &lt;&lt; 0; while (!stac.empty()) &#123; cout &lt;&lt; stac.top(); stac.pop(); &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1308」 统计单词数]]></title>
    <url>%2F2017%2F07%2F30%2F%E6%B4%9B%E8%B0%B7-1308%2F</url>
    <content type="text"><![CDATA[题外话这题坑了我好久……谁说分到“简单”字符串的？？？ 题目链接洛谷 1308 题解本题考点是字符串的操作。两种解法：一是读完文章再操作，二是边读边操作。由于第一种方法用的标准函数较多，就写第一种了（虽然第二种较优），有兴趣的可以尝试第二种（实际上是我懒得写第二种了）。 细节如果使用algorithm里的transform函数的话要注意函数的意义：第1、2个参数是字符串的起始、结束位置。第3个参数是开始应用转换的位置。第4个参数是执行的操作（toupper/tolower）。还有一点，如果直接写成“transform(string.begin(), string.end(), string.begin(), tolower);”这样的话提交至OJ有可能出错：“error: no matching function for call to ‘transform(std::basic_string::iterator, std::basic_string::iterator, std::basic_string::iterator, )’”这里就需要将C++的函数强制改为C的（本是同根生，相煎何太急……）：transform(string.begin(), string.end(), string.begin(), ::tolower); 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;string wrd, sen, st;int ans, wh, tmp;bool flag;//用于确定是否是第二次扫描int main()&#123; wh = 0x7f7f7f7f; getline(cin, wrd);//字符串读至行末回车 getline(cin, sen); transform(wrd.begin(), wrd.end(), wrd.begin(), ::tolower);//transform函数将所有字母转小写，包含于algorithm头文件 transform(sen.begin(), sen.end(), sen.begin(), ::tolower); int i = 0;//字符串从0开始 while (i &lt; sen.size()) &#123; if (sen[i] == ' ')//防止开头出现空格 &#123; i++; continue; &#125; st = sen.substr(i, wrd.size()); if (st == wrd &amp;&amp; (sen[i + wrd.size()] == ' ')) wh = min(wh, i), ans++, i += wrd.size();//第一次出现的序号一定最小，偷懒 else &#123; tmp = sen.find(' ', i);//从第i个位置开始找字符' ' if (tmp != -1) &#123; i = tmp + 1; continue; &#125; else &#123; if (!flag) flag = 1; else break; &#125; &#125; i++; &#125; if (!ans) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; wh &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1091」 合唱队形]]></title>
    <url>%2F2017%2F07%2F29%2F%E6%B4%9B%E8%B0%B7-1091%2F</url>
    <content type="text"><![CDATA[题外话最近都刷的什么垃圾题目啊……连我自己都不忍直视 题目链接洛谷 1091 题解在大意中已经写的很明显了，要求最少的不在原序列的元素个数。虽然读起来有些别扭，但仔细一想，可以转化成求最长符合条件的子序列的长度，再拿\(n\)减去该长度即可。再看题，符合条件的子序列是什么？满足“有且只有一个元素与其左边所有元素单调上升，与其右边所有元素单调下降”。明显是最长上升子序列和最长下降子序列的组合！我们可以把前\(i\)个元素变成一个序列并求最长上升子序列的长度，第\(i+1\)~第\(n\)个元素变成一个序列并求最长下降子序列的长度。设\(f(i)\)为取第\(i\)个元素的最长上升/下降子序列长度。得DP方程：\(f(i)=max(f(i),f(j)+1),\;a_i＜(＞)a_j,\,j&lt;i\) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n, ans;int a[1001], f[1001];void ms()&#123; memset(f, 0, sizeof(f));&#125;bool judge(int op, int x, int y)&#123; if (!op) return x &gt; y; else return x &lt; y;&#125;int longest(int op, int x)&#123; //若op=0，则求最长上升子序列长度，否则求最长下降子序列长度。 //C++中语句连起来可以写成 S1, S2, S3;的形式。 int st, ed; if (!op) st = 1, ed = x; else st = x, ed = n; ms(); for (int i = st; i &lt;= ed; i++) &#123; f[i] = 1; for (int j = st; j &lt; i; j++) &#123; if (judge(op, a[i], a[j])) f[i] = max(f[i], f[j] + 1); &#125; &#125; int tmp = -0x7f7f7f7f; for (int i = st; i &lt;= ed; i++) tmp = max(tmp, f[i]); return tmp;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) ans = max(ans, longest(0, i) + longest(1, i+1)); cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 3371」 【模板】单源最短路径]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%B4%9B%E8%B0%B7-3371%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 3371 题解图的最短路有多种解法，如Dijkstra（贪心）、Floyed（DP），还有我们即将讨论的SPFA（BFS）。说SPFA是BFS也有些牵强。SPFA与BFS最大的区别就在于BFS某个结点只会访问一次，即出队列就不会二次进队，而SPFA则允许二次进队的情况出现。貌似唯一可能让顶点二次进队的情况只有一种：负环。这也是SPFA比其它两种最短路算法更优的原因（可判负环）。此外，SPFA也有DFS的。接下来讨论SPFA的操作步骤 SPFA 初始化（数组、源点）。 每次取出队首元素\(u\)，搜索以\(u\)为起点的每一条边\(e=(u,v)\) 若符合松弛条件，松弛； 否则继续循环。 当头指针=尾指针时结束循环。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct Edge&#123; int to, wei, next;&#125;edge[500001];int head[500001], dis[10001], q[10000001];int n, m, s, num_edge, a, b, c;bool vis[10001];void add(int a, int b, int c)&#123; edge[++num_edge].to = b; edge[num_edge].wei = c; edge[num_edge].next = head[a]; head[a] = num_edge;&#125;void spfa()&#123; memset(dis, 0x7f7f7f7f, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[s] = 0; vis[s] = true; int l = 1, r = 1; q[1] = s; while (l &lt;= r) &#123; int u = q[l]; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (dis[v] &gt; dis[u] + edge[i].wei) &#123; dis[v] = dis[u] + edge[i].wei; if (!vis[v]) &#123; q[++r] = v; vis[v] = true; &#125; &#125; &#125; vis[u] = false; l++; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; spfa(); for (int i = 1; i &lt;= n; i++) &#123; if (s == i) cout &lt;&lt; 0 &lt;&lt; ' '; else if (dis[i] == 0x7f7f7f7f) cout &lt;&lt; 2147483647 &lt;&lt; ' '; else cout &lt;&lt; dis[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 3366」 【模板】最小生成树]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%B4%9B%E8%B0%B7-3366%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 3366 题解对于图\(G=(V,E)\)，最小生成树有两种较普遍的解法，即Kruskal算法和Prim算法。这里的程序采用Kruskal。接下来讨论Kruskal的操作步骤。 步骤 对于边集合\(E\)，按照边权从小到大排序。 对于\(m\)条边扫一遍。每次判断若加该边是否构成环： 若不构成，则最小生成树边数+1，权值和加上该边权值； 否则继续循环。 若最小生成树边数=图的顶点数-1，则输出权值和，否则输出orz。 这样Kruskal算法流程就结束了。下面对执行时的两个细节进行讨论。 细节 判断是否构成环。其实本步只需判断是否所加入的边\(e∈E\)的两个顶点\(u,v∈e\)是否在一集合里。想到集合，自然会想到并查集的实现。有关并查集，在此不赘述。 最小生成树的边数数一定是图（树）的顶点数-1。最小生成树的定义是：若图\(G=(V,E)\)是一个连通的无向图，则把它所有顶点\(V\)与部分边\(E’\)构成连通无环子图\(G’\)（图\(G\)的生成树），所有可能的生成树\(G’\)中边集\(E’\)中所有边的权值和最小的图\(G’\)称为图\(G\)的最小生成树。我们可以首先将图\(G’\)（最小生成树是一个图）连成一个环，最少需\(|V|\)条边。但如果仅需保证图是联通的，就有一条边是不必要的。所以最小生成树中有\(|V|-1\)条边。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int ans, n, m, num_ans, tmp;int rt[500001];struct Edge&#123; int from, to, wei;&#125;edge[8000001];bool cmp(Edge a, Edge b)&#123; return a.wei &lt; b.wei;&#125;void init()&#123; for (int i = 1; i &lt;= n; i++) rt[i] = i;&#125;int getrt(int x)&#123; if (rt[x] == x) return x; else return rt[x] = getrt(rt[x]);&#125;void _union(int x, int y)&#123; rt[y] = x;&#125;void kruskal()&#123; sort(edge + 1, edge + m + 1, cmp); for (int i = 1; i &lt;= m; i++) &#123; int fr = getrt(edge[i].from), tr = getrt(edge[i].to); if (fr == tr) continue; else &#123; _union(fr, tr); ans += edge[i].wei; num_ans++; &#125; if (num_ans == n - 1) return; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].wei; &#125; init(); kruskal(); if (num_ans == n-1) cout &lt;&lt; ans; else cout &lt;&lt; "orz"; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1020」 导弹拦截]]></title>
    <url>%2F2017%2F07%2F20%2F%E6%B4%9B%E8%B0%B7-1020%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 1020 题解这题分两问，在大意中已很明确地分析出来了。接下来，让我们分问题讨论。 第一问对于第一问，很显然是DP。设\(f(i)\)表示从\(1\)~\(i\)以\(i\)结尾（取\(i\)）的最长不上升子序列的最长长度\((i≤n)\)。由于是\(1\)~\(i\)这些导弹，所以有必要再加一层循环，判断第\(j\)发导弹是否能打。得DP方程： \(f(i)=max(f(i),f(j+1)),\;a_i≤a_j,\,j&lt;i\) 第二问第二问可以用贪心解决。一遍循环，将当前\(a_i,\,1≤i≤n\)与在数组\(ar\)中最小的不小于\(a_i\)的编号\(k\)与值记录下来，存入\(ar_k\)中。若无此值，则再加一个元素。最后统计\(ar\)数组元素个数即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int cnt = 0, _max, sum;int a[105], f[105], ar[105];int main()&#123; ios::sync_with_stdio(false);//cin、cout优化 while (cin &gt;&gt; a[++cnt]) ; cnt--; //求第一问 for (int i = 1; i &lt;= cnt; i++) &#123; f[i] = 1; for (int j = 1; j &lt; i; j++) &#123; if (a[i] &lt;= a[j]) f[i] = max(f[i], f[j] + 1); &#125; &#125; for (int i = 1; i &lt;= cnt; i++) _max = max(_max, f[i]); cout &lt;&lt; _max &lt;&lt; endl; //求第二问 for (int i = 1; i &lt;= cnt; i++) &#123; int wh = 0; _max = 0x7f7f7f7f; for (int j = 1; j &lt;= sum; j++) &#123; if (ar[j] &gt;= a[i] &amp;&amp; ar[j] &lt; _max) &#123; _max = ar[j]; wh = j; &#125; &#125; if (!wh) ar[++sum] = a[i]; else ar[wh] = a[i]; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[站点基于Hexo搭建，使用NexT.Pisces主题，使用GitHub Pages托管网页本站音乐播放器：APlayer，由DIYgod基于MIT License发布 个人初三，江苏省丹阳高级中学永远感谢Yirannn退役前的一番话语AFO = Always Firmly in OI]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Friends]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[Name Info FlyInTheSky 广东北江中学 Logey 临沂一中 redbag LG管理 skyofwar 江苏省丹阳高级中学 SiriusRen 北京邮电大学 Yirannn 吉林大学附属中学 多多良假伞 聊城一中]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
