<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数学 等差数列初步]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%95%B0%E5%AD%A6-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[引用说明本文引用的定义皆出自中文维基百科 正文定义 等差数列（又名算术数列）是数列的一种。在等差数列中，任何相邻两项的差相等。该差值称为公差。 我们设一等差数列为$\lbrace a\rbrace$ 公差公式由于等差数列相邻两项差值为$d$，可知第$a_n$与$a_m(m&lt;n)$之间相差$(n-m)$个$d$由此，我们得到：$$d=\frac{a_n-a_m}{n-m}$$ 通项公式由于等差数列相邻两项差值为$d$，可知第$a_n$与$a_m(m&lt;n)$之间相差$(n-m)$个$d$可得：$$a_n=a_m+(n-m)d$$ 等差级数 等差数列的和称为等差级数。 等差级数公式$$S_n=\frac{n(a_1+a_n)}{2}$$ 证明代数方法记等差数列$\lbrace a\rbrace$前$n$项的级数为$S_n$，可得：$S_n=(a_1+0d)+(a_1+1d)+(a_1+2d)+\dots+(a_1+(n-1)d)$$S_n=(a_n-(n-1)d)+(a_n-(n-2)d)+\dots+(a_n-d)+a_n$二式相加，得：$2S_n=na_1+na_n$$\therefore S_n=\frac{n(a_1+a_n)}{2}$ 几何方法我们可以这样想象：$a_1$表示一个长为$a_1$、宽为$1$的长方形$a_2$表示一个长为$a_2$、宽为$1$的长方形$\dots$$a_n$表示一个长为$a_n$、宽为$1$的长方形于是$S_n$便相当于这$n$个长方形的面积和把这$n$个长方形拼成一个直角梯形，根据梯形面积公式，得：$S_n=\frac{n(a_1+a_n)}{2}$ 性质所有等差数列的等差级数均可表示为$S_n=pn^2+qn$的形式。 证明对于等差数列$\lbrace a\rbrace$，我们有：\begin{align}S_n&amp;=\frac{n(a_1+a_n)}{2}\\&amp;=\frac{n(2a_1+(n-1)d)}{2}\\&amp;=\frac{2na_1+n^2d-nd}{2}\\&amp;=na_1+\frac{d}{2}n^2-\frac{d}{2}n\\&amp;=\frac{d}{2}n^2+(a_1-\frac{d}{2})n\end{align}$\therefore p=\frac{d}{2},\,q=a_1-\frac{d}{2}=a_1-p$ 命题等差中项对于任意的正整数$n&gt;1$，都有$$a_{n-1}+a_{n+1}=2a_n$$ 证明根据等差数列定义，得：$a_{n-1}=a_n-d, a_{n+1}=a_n+d$$\therefore a_{n-1}+a_{n+1}$$=a_n-d+a_n+d$$=2a_n$ 根据这个命题，我们可以推广：若有三个正整数$a, b, c$，满足$a+c=2b$，则$a, b, c$可组成一公差为$b-a$的等差数列 等差数列的积由于太菜不会，这里先略过……]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 添加搜索功能]]></title>
    <url>%2F2018%2F04%2F07%2FHexo-%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[题外话这个搜索功能坑了我好久…… 正文Step 1$ npm install hexo-generator-searchdb --save Step 2打开站点根目录_config.yml Step 3在文末加上 search: path: search.xml field: all format: html limit: 10000 Step 4打开NexT主题_config.yml Step 5找到local_search，将enable改为true]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub 图床]]></title>
    <url>%2F2018%2F04%2F07%2FGitHub-%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[正文 create a repository clone 到本地 将想要上传的图片push 进入图床repository，找到你刚才push的图片 左键单击查看图片 在图片上右击-在新标签页中打开图片 复制图片url 该url即可直接调用 注意：以“https://github.com/” 开头的并不是你图片的url。正常情况下url应以“https://raw.githubusercontent.com/” 开头。]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 任务栏透明优化]]></title>
    <url>%2F2018%2F04%2F07%2FWindows-%E4%BB%BB%E5%8A%A1%E6%A0%8F%E9%80%8F%E6%98%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题外话这是我第一次用Menci大大开发的Moeditor写markdown文件，相比较Notepad++纯感觉无预览，使用感觉还是相当不错的。话说像我这种用GitHub当图床的也没谁了吧…… 正文初衷作为一名重度强迫症患者，说实话我很难容忍Windows任务栏与桌面的格格不入。 Step 1有问题先Google百度。先试了一下StartIsBack，发现不能设置全屏开始菜单栏，于是果断放弃。 Step 2百度不靠谱，只能上知乎。在知乎上找到了TranslucentTB。readme.md又指导我们访问AppVeyor artifacts以获取最新版（尽管是开发版）。下载&amp;使用，效果可以说是接近完美。附上效果图： 设置 显示隐藏图标-找到TranslucentTB-右击 勾选“Open at boot”，这样默认开机自启 鼠标移至Regular State-选择想要的效果 找到TranslucentTB.exe根目录，打开config.cfg 找到第二行 accent= ，等号后面的blur改为刚才你选择的效果（normal, clear, opaque, blur） 附对照表： 选项 效果 normal 系统默认 clear 全透明 opaque 不透明 blur 模糊]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 1160」 Post Office]]></title>
    <url>%2F2018%2F01%2F06%2FPOJ-1160%2F</url>
    <content type="text"><![CDATA[题外话话说原本mathjax老是出故障的\$\$突然变正常了，开心~ 题目链接POJ 1160 大意在$V$个村庄里选$P$个作为邮局，使得每个村庄到距它最近的邮局的距离和最短。 题解裸典型的区间DP。设$f(i,j)$表示前$i$个村庄内建立$j$个邮局的最小距离和，最终答案即为$f(V,P)$。可以想到，前$i$个村庄内建立$j$个邮局即为前$k$个村庄建立$j-1$个邮局、第$k+1$到第$i$个村庄建一个邮局。设$w(i,j)$表示在村庄$i$、$j$之间建立一个邮局后，该邮局与村庄$i$、$j$的最短距离和。易得：$w(i,j)=w(i,j-1)+a(j)-a((i+j)/2)$。可能有人会问，如果$i+j$为偶，则位置能确定（$(i+j)/2\in N^*$）；但若$i+j$为偶，是选$\lceil (i+j)/2 \rceil$还是$\lfloor (i+j)/2 \rfloor$呢？我们可以假设共有6个村庄，要在范围$[1..6]$内选择1个做邮局。根据上面疑问，我们分别选取$\lceil (i+j)/2 \rceil$即4与$\lfloor (i+j)/2 \rfloor$即3做比较。设每个村庄位置分别为$a_i$。 选取4。则总距离为：$$(a_4-a_1)+(a_4-a_2)+(a_4-a_3)+0+(a_5-a_4)+(a_6-a_4)=a_6+a_5+a_4-a_3-a_2-a_1$$ 选取3。则总距离为：$$(a_3-a_1)+(a_3-a_2)+0+(a_4-a_3)+(a_5-a_3)+(a_6-a_3)=a_6+a_5+a_4-a_3-a_2-a_1$$ 因此，可得当$i+j$为偶时，选$\lceil (i+j)/2 \rceil$与$\lfloor (i+j)/2 \rfloor$ 等价。计算$w$数组时可以用前缀和优化，在此不赘述。综上，不难得方程：$f(i,j)=min\lbrace f(i,j),f(k,j-1)+w(k+1,j)\rbrace$时间复杂度$O(pv^2)$ 代码 - 裸#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) &#123; for (int j = i + 1; j &lt;= v; j++) &#123; w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; &#125; &#125; memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) &#123; f[i][i] = 0; f[i][1] = w[1][i]; &#125; for (int j = 2; j &lt;= p; j++) &#123; for (int i = j + 1; i &lt;= v; i++) &#123; for (int k = j - 1; k &lt; i; k++) &#123; f[i][j] = min(f[i][j], f[k][j - 1] + w[k + 1][i]);//注意别写到括号外面去 &#125; &#125; &#125; cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;&#125; 优化在这里，我们要用到一个叫做四边形不等式的东西。 四边形不等式此问题中包含着一个常见的状态转移方程：$$f(i,j)=min\lbrace f(i,k-1)+f(k,j)+w(i,j)\rbrace$$假如对于任意$i\leq i’&lt;j\leq j’$，都有$w(i’,j)\leq w(i,j’)$，那么我们称函数$w$满足关于区间包含的单调性另外，假如有：$$w(i,j)+w(i’,j’)\leq w(i’,j)+w(i,j’)$$那么我们称函数$w$满足四边形不等式。不等式较抽象，建议画图理解。理解后，我们引出两个定理：1、若上述函数$w$同时满足区间包含单调性与四边形不等式，那么函数$f$也满足四边形不等式，即：$$f(i,j)+f(i’,j’)\leq f(i’,j)+f(i,j’),\;i\leq i’&lt;j\leq j’$$我们再定义函数$s(i,j)$表示$f(i,j)$取得最优值时对应的$k$。此时有定理：2、若上述函数$f$满足四边形不等式，则函数$s$单调，即：$$s(i,j)\leq s(i,j+1)\leq s(i+1,j+1)$$得出结论2后，我们发现：$s(i,j-1)\leq s(i,j)\leq s(i+1,j)$因此函数$f$等价于：$$f(i,j)=min\lbrace f(i,k-1)+f(k,j)+w(i,j)\rbrace,\;s(i,j-1)\leq k\leq s(i+1,j)$$ 回到问题理解四边形不等式后，我们发现：本题的$f$也满足四边形不等式（证明实在没力气了）。因此，本题可以优化成$O(vp)$。 代码 - 优化#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int s[1001][1001];int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) &#123; s[i][i] = i; for (int j = i + 1; j &lt;= v; j++) &#123; w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; &#125; &#125; memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) f[i][1] = w[1][i]; for (int i = 1; i &lt;= p; i++) s[v + 1][i] = v;//计算可能越界 for (int i = 1; i &lt;= p; i++) &#123; for (int j = v; j &gt; i; j--) &#123; for (int k = s[j][i - 1]; k &lt;= s[j + 1][i]; k++) &#123; if (f[j][i] &gt; f[k][i - 1] + w[k + 1][j]) &#123; f[j][i] = f[k][i - 1] + w[k + 1][j]; s[j][i] = k; &#125; &#125; &#125; &#125; cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>POJ</tag>
        <tag>DP</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio 保存文件编码格式]]></title>
    <url>%2F2017%2F12%2F04%2FVisual-Studio-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题外话Visual Studio确实是最强的IDE，但功能太复杂了啊……每年产品的界面都不一样。2017企业版的默认保存为LINUX格式的，Windows下只能用Notepad++打开，很是苦恼。网上都说安装什么破插件。最后终于找到一篇正常的了…… 正文添加“高级保存选项” 单击“工具”|“自定义”命令，弹出“自定义”对话框。 单击“命令”标签，进入“命令”选项卡。 在“菜单栏”下拉列表中，选择“文件”选项。 单击“添加命令”按钮，弹出“添加命令”对话框。 在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”按钮，关闭“添加命令”对话框。 选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。 单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 更改保存格式更改成自己想要的编码即可。 参考解决Visual Studio 2017隐藏“高级保存选项”命令]]></content>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 2823」 Sliding Window]]></title>
    <url>%2F2017%2F11%2F26%2FPOJ-2823%2F</url>
    <content type="text"><![CDATA[题外话这题提交方式很玄学……C++交就TLE，改成G++就AC了…… 题目链接POJ 2823 题解首先我们想到暴力模拟，妥妥的TLE，加上POJ老掉牙的机器，不知道T成什么样了……既然模拟不可行，那么我们只能考虑一种新的方法。目前我们貌似没有掌握一种算法能快速算区间最大值的，因此我们只能从数据结构入手。堆？你怎么确定元素是否超出窗口边界？用struct？那还怎么用STL的priority_queue？线段树？和堆一样的问题（怎么删除超出边界的元素）。我们发现，我们需要的是一种 能支持\(O(1)\)输出队列最大值 具有队列的一切功能（进队、出队） 要实现这两个功能，我们只能请出新的角色——单调队列 单调队列上文已经说明单调队列的作用了，接下来我们要讨论如何实现单调队列。首先队列清空（这里有个坑，留待你发掘）。遇到即将入队的新元素，将它与队尾元素比较，如果大于队尾元素就不断弹出队尾元素，直到队尾元素大于即将入队的元素位置。新元素进队。保证队列元素都在规定范围内：判断队首元素是否超过边界，若超过，就不断弹出队首元素，直到队首元素在规定范围内。规定范围内的最大值就是该队列的队首元素。由于要实现两端都能出队的队列，只能挥泪告别STL，迎接手写queue了…… 代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, k;int a[1000005];int q[1000005];//队列int p[1000005];//下标struct Number&#123; int pos, val;&#125;num[1000005];void SolBig()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; &#125; cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; &#125; cout &lt;&lt; endl;&#125;void SolSml()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; &#125; cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; &#125; cout &lt;&lt; endl;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; SolSml(); SolBig(); return 0;&#125;]]></content>
      <tags>
        <tag>POJ</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2017」普及组复赛解题报告]]></title>
    <url>%2F2017%2F11%2F25%2FNOIP-2017%E6%99%AE%E5%8F%8A%E7%BB%84%E5%A4%8D%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题外话吐槽一下CCF的老爷机：CPU AMD Athlon(tm) II x2 240 processor，2.8GHz大概是什么价位的呢？ 参考报价：￥185 停产 2014-04-14（摘自中关村在线）都2017年了还不换新机子？？ 题目链接百度网盘 P1 成绩题解这题是给智商80-的人写的……不过官方好像说有精度问题（题目中明明写着“A、B、C 都是 10 的整数倍”啊）然后重测了。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;double a, b, c;int main(int argc, char ** argv)&#123; freopen("score.in", "r", stdin); freopen("score.out", "w", stdout); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; floor(a*0.2 + b*0.3 + c*0.5) &lt;&lt; endl; return 0;&#125; P2 图书管理员题解比较水啊，但注意图书编号不能只用string存，因为字符串大小和数字大小有区别。 代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int n, q;string st[1005];int nb[1005];int main(int argc, char ** argv)&#123; freopen("librarian.in", "r", stdin); freopen("librarian.out", "w", stdout); memset(nb, 0, sizeof(nb)); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; st[i]; for (int j = 0; j&lt;st[i].length(); j++) nb[i] = (nb[i] &lt;&lt; 3) + (nb[i] &lt;&lt; 1) + (st[i][j] ^ 48); &#125; for (int i = 0; i&lt;q; i++) &#123; bool flag = false; int tmp; int _min = 0x7f7f7f7f; string nd; cin &gt;&gt; tmp &gt;&gt; nd; for (int j = 0; j&lt;n; j++) &#123; if (st[j].length()&lt;nd.length()) continue; if (st[j].substr(st[j].length() - nd.length(), nd.length()) == nd) &#123; _min = min(_min, nb[j]); flag = true; &#125; &#125; if (!flag) cout &lt;&lt; "-1" &lt;&lt; endl; else cout &lt;&lt; _min &lt;&lt; endl; &#125; return 0;&#125; P3 棋盘题解两种解法。第一种是建图+最短路，第二种是DFS+记忆化。出于懒得写图让你们更简单地A掉这题的缘故，我决定写DFS。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define INF 0x7f7f7f7fint n, m;int a[105][105];int v[105][105];int f[105][105];void dfs(int x, int y, bool chd, int cst, int col)&#123; if (x&gt;m || y&gt;m || x &lt;= 0 || y &lt;= 0) return; if (chd&amp;&amp;a[x][y] == INF) return; else if (!chd&amp;&amp;a[x][y] == INF) &#123; cst += 2; chd = true; &#125; else if (a[x][y] != INF) &#123; if (a[x][y] != col) cst++; col = a[x][y]; chd = false; &#125; if (cst &lt; f[x][y]) f[x][y] = cst; else return; dfs(x-1, y, chd, cst, col); dfs(x, y-1, chd, cst, col); dfs(x, y+1, chd, cst, col); dfs(x+1, y, chd, cst, col);&#125;int main(int argc, char ** argv)&#123; freopen("chess.in", "r", stdin); freopen("chess.out", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; m &gt;&gt; n; memset(a, INF, sizeof(a)); memset(f, INF, sizeof(f)); for (int i = 1; i &lt;= n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cin &gt;&gt; a[x][y]; &#125; dfs(1, 1, 0, 0, a[1][1]); if (f[m][m] == INF) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; f[m][m] &lt;&lt; endl; return 0;&#125; P4 跳房子题解一眼看出是二分，check()函数用DP。设\(f(i)\)表示跳到第\(i\)个格子最大分数。显而易见，\(f(i)=max \lbrace f(j) \rbrace +s_i\)，且从第\(j\)个格子能跳到第\(i\)个格子。裸的DP能拿50分，下面考虑优化。由于计算的是一个单调区间的最大值，并且该区间不断后移，我们可以考虑用单调队列实现。 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define MAXN 500005int n, d, k;int h, t;long long f[MAXN];long long x[MAXN];long long s[MAXN];long long q[MAXN];void push(int add)&#123; while (f[q[t]] &lt;= f[add] &amp;&amp; h &lt;= t) t--; q[++t] = add;&#125;bool chk(int g)&#123; memset(f, -0x7f7f7f7f, sizeof(f)); f[0] = 0; h = 1; t = 0; int p = 0; q[h] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (x[i] - x[p] &gt;= max(d - g, 1) &amp;&amp; p &lt; i) push(p++); while (x[i] - x[q[h]] &gt; d + g&amp;&amp;h &lt;= t) h++; if (h &gt; t || f[q[h]] == -0x7f7f7f7f) continue; else f[i] = f[q[h]] + s[i]; if (f[i] &gt;= k) return true; &#125; return false;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); freopen("jump.in", "r", stdin); freopen("jump.out", "w", stdout); cin &gt;&gt; n &gt;&gt; d &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; s[i]; if (!chk(x[n])) cout &lt;&lt; -1; else &#123; int l = 1, r = x[n]; while (l &lt; r) &#123; int mid = (l + r) / 2; if (chk(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」普及组复赛解题报告]]></title>
    <url>%2F2017%2F10%2F18%2FNOIP-2016%E6%99%AE%E5%8F%8A%E7%BB%84%E5%A4%8D%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接百度网盘 P1 买铅笔题解这题分外水啊……几个if就可以AC。考试时3分钟敲完……但今年懒得用if写了十几分钟…… 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, ans;int main(int argc, char ** argv)&#123; freopen("pencil.in","r",stdin); freopen("pencil.out","w",stdout); ans = 0x7f7f7f7f; cin &gt;&gt; n; for (int i = 1; i &lt;= 3; i++) &#123; int num, cost; cin &gt;&gt; num &gt;&gt; cost; ans = min(ans, (n / num + ((bool)(n - (n / num)*num)))*cost); //(bool)将int类余数强制转换成bool，若n能整除num（即不用再多买），则余数为0（false）。 //否则表达式的值就是true（非0即真），要多买一盒。 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P2 回文日期题解考试的时候敲了16KB（是的，你没看错，16KB），搞得监考老师查程序的时候差点叫出来……万幸的是AC了……解此题有两种方法。1、穷举日期（00000000~99999999），加上一堆检查，时间复杂度≈\(O(2×10^8)\)，比较险。2、穷举年份。因为每个年份存在多个日期，但只可能存在一个回文的，所以只要穷举年份，构造出回文日期，再判断是否合法即可。 代码//穷举年份#include&lt;iostream&gt;using namespace std;int stime, etime, ans;const int Mon[] = &#123; 0,31,28,31,30,31,30,31,31,30,31,30,31 &#125;;bool spe(int yea)&#123; return !(yea % 4) &amp;&amp; yea % 100 || !(yea % 400);//!(X % Y)：判断X是否整除Y，别写反。也要注意!的优先级比%高&#125;int main(int argc, char ** argv)&#123; freopen("date.in", "r", stdin); freopen("date.out", "w", stdout); cin &gt;&gt; stime &gt;&gt; etime; for (int i = stime / 10000; i &lt;= etime / 10000; i++) &#123; int pres = i * 10000 + (i % 10) * 1000 + (i % 100 / 10) * 100 + (i % 1000 / 100) * 10 + i / 1000; int mon = pres % 10000 / 100; int day = pres % 100; if (spe(pres / 10000) &amp;&amp; mon == 2) if (day &lt;= 29) if (pres &gt;= stime&amp;&amp;pres &lt;= etime) &#123; ans++; continue; &#125; if (day &lt;= Mon[mon] &amp;&amp; mon &lt;= 12) if (pres &gt;= stime&amp;&amp;pres &lt;= etime) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P3 海港题解考试的时候作死，做出来70分胡改改成了25分……70分做法：按船存储数据，对于每艘船，找它和一天之前所有船的人员国籍。100分做法：按人存储数据。由于每艘船上的人的到港时间都是一样的，所以只需记录下每艘船到的时间和每个人的国籍。维护一个\(sum\)记录国籍总数，遇到一天前的船（人）就减去国籍数。详细内容见代码。 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;int num_data;int Sear;int sum;int nati[100005];int peop[100005];struct Ship&#123; int first, last, time;&#125;ship[100005]; int Binary_search(int left, int right)//二分查找最近的超过一天的船&#123; int ans = 0; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (Sear - ship[mid].time &gt;= 86400) &#123; ans = max(ans, mid); left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return ans;&#125;int main(int argc, char ** argv)&#123; freopen("port.in", "r", stdin); freopen("port.out", "w", stdout); cin &gt;&gt; n; int lastship = 0;//上一个（记录过的）超过一天的船 for (int i = 1; i &lt;= n; i++) &#123; int Peop; cin &gt;&gt; ship[i].time &gt;&gt; Peop; Sear = ship[i].time; ship[i].first = ship[i - 1].last + 1; ship[i].last = ship[i].first + Peop - 1; for (int j = 1; j &lt;= Peop; j++) &#123; cin &gt;&gt; peop[++num_data]; if (!nati[peop[num_data]]) sum++; nati[peop[num_data]]++; &#125; int BS = Binary_search(1, i); if (BS)//存在一个（最近的）一天前的船，因此，一天前的船即为lastship+1~BS的船 &#123; for (int j = ship[lastship + 1].first; j &lt;= ship[BS].last; j++)//lastship已经记录过，因此循环从lastship+1开始 &#123; nati[peop[j]]--; if (!nati[peop[j]]) &#123; sum--; &#125; &#125; lastship = BS; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 解释看到这里相信肯定有读者有疑惑：为什么你能保证\(sum\)的值一定是当前国籍总数？注意到，我们的\(nati_i\)记录的是拥有国籍\(i\)的人的一天内的总数。当发现有船到港时间在一天前，减去该船所有人的国籍记录即可。若减下来\(nati\)数组某国人数为0，就代表了一天内没有该国人到港。由于到港时间是单调上升的，上艘船的前一天到港的船只也必定是本艘船前一天到港的，因此本艘船的数据可以沿用上一艘的记录。 P4 魔法阵题解这题拿到手先暴力……暴力完开始想正解。由于\(n\)和\(m\)都比较大，并且题目中有几个方程，肯定想到用数学方法解。当然差分约束从方程入手。为方便，记\(x_a\)为\(A\)、\(x_b\)为\(B\)，\(C\)、\(D\)同理。\(\because B−A=2(D−C),\ B-A&lt;(C-B)/3\)\(\therefore 2(D-C)&lt;(C-B)/3\)\(\therefore C-B&gt;6(D-C)\)设\(D-C=i\)则\(B-A=2i\)\(C-B&gt;6i\)\(\therefore D-A&gt;9i\)推完后，我们发现先确定\(i\)，再枚举\(D\)，就能把\(C\)求出来，同理，枚举\(A\)，就能把\(B\)求出来。维护4个数组记录每样物品分别作为\(A,B,C,D\)的次数，根据简单的乘法原理和加法原理可以算出来方案数。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt; using namespace std;int x[40005];int s[40005];int a[40005];int b[40005];int c[40005];int d[40005];#define q ' 'int n, m;int main(int argc, char ** argv)&#123; freopen("magic.in", "r", stdin); freopen("magic.out", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x[i]; s[x[i]]++; &#125; for (int i = 1; i * 9 + 1 &lt;= n; i++) &#123; int sum = 0; for (int D = i * 9 + 2; D &lt;= n; D++) &#123; sum += s[D - 7 * i - 1] * s[D - 9 * i - 1]; c[D - i] += s[D] * sum; d[D] += s[D - i] * sum; &#125; sum = 0; for (int A = n - i * 9 - 1; A; A--) &#123; sum += s[A + i * 9 + 1] * s[A + i * 8 + 1]; a[A] += s[A + 2 * i] * sum; b[A + 2 * i] += s[A] * sum; &#125; &#125; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; a[x[i]] &lt;&lt; q &lt;&lt; b[x[i]] &lt;&lt; q &lt;&lt; c[x[i]] &lt;&lt; q &lt;&lt; d[x[i]] &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++探索」 main函数参数]]></title>
    <url>%2F2017%2F08%2F01%2FC%2B%2B-main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[说明今天突然不想用VS了，打开Dev-C++又胡乱设置一通。突然在Dev-C++的菜单-工具-编译器属性-语法里看到这样一段：int main(int argc, char **argv) 顿时懵了：main函数还带参数？？于是别人博客+自行摸索，总结出如下结论（注意：方便起见，讨论的将先是int main(int argc, char * argv[])，不要问我为什么）。 讨论char * argv[]先编写以下代码：#include&lt;iostream&gt;using namespace std;int main(int argc, char * argv[])&#123; cout &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) cout &lt;&lt; argv[i] &lt;&lt; endl; return 0;&#125; 注意，这里直接运行会得到以下结果： 1 D:\Program\Debug\Program.exe 看的是不是云里雾里？既然输出了程序的路径，那么我们放到cmd里运行试试。D:\Program\Debug\Program.exe 输出一样。那么，1是什么？让我们尝试运行以下指令：D:\Program\Debug\Program.exe Sena 输出： 2 D:\Program\Debug\Program.exe Sena 似乎有点明白了？再运行以下指令：D:\Program\Debug\Program.exe Sena Senb Senc 输出： 4 D:\Program\Debug\Program.exe Sena Senb Senc 现在很明显了：argc是命令行参数的个数，argv[]存的是命令行的参数。而argv[0]指向exe程序路径。 char ** argv可能你会说，上面更改了原来的参数，并不能说明问题。因此下面我们研究char * argv[]与char ** argv 的区别。先看char * argv[]。由于[]的优先级高于*，所以a先与[]组合，因此argv是一个数组，数组中的元素类型是char *。对于char ** argv，argv是二级指针（指针的指针），指向一级指针char *的地址。而char *本身是个指向第一个字符的指针！所以不严谨的看，char * argv[]等价于char ** argv。之所以说不严谨，是因为char *存放在常量区，而char []存放在栈中。前者赋初值后不能更改，而后者可以。编写以下代码：#include&lt;iostream&gt;using namespace std;int main(int argc, char ** argv)&#123; cout &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) cout &lt;&lt; argv[i] &lt;&lt; endl; system("pause"); return 0;&#125; 其输出与char * argv[]无异。若将第7行改为cout &lt;&lt; *argv[i] &lt;&lt; endl;的话，则输出： 1 D cmd中运行以下指令：D:\Program\Debug\Program.exe Sena Senb Senc 输出： 4 D S S S 输出的是每个参数的首字母，因为char *本身是个指向第一个字符的指针。 总结看完本文，相信读者已经对main函数的参数有了一定的了解，同时对指针有了更深的认识。当然，由于本文并未涉及字符串的编辑，所以char * argv[]与char ** argv的区别并没有真正体现出来。这将在以后的学习过程中提及。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++关键字」 register]]></title>
    <url>%2F2017%2F08%2F01%2FC%2B%2B-register%2F</url>
    <content type="text"><![CDATA[说明众所周知，计算机在运行程序时，会读取程序存储在硬盘的数据，数据被加载在内存里面，即可执行命令。而存放在CPU寄存器里的数据存取速度比内存快得多。然而，CPU寄存器数量有限，所以不能存储太多数据。所以我们只取优化较大的变量存储到CPU寄存器里。这时候，我们就要用到register关键字。 定义register修饰符暗示编译程序相应的变量将被频繁地使用。 注意点 register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。 因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。 实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。 只有函数参数和局部变量可被声明为register。 register变量的生命周期只维持在它所声明的块中。 测试下面对比使用register关键字前后的运行速度。 代码#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;int main()&#123; LARGE_INTEGER st, ed, t; QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); for (int i = 1; i &lt;= 700; i++) for (int j = 1; j &lt;= 700; j++) for (int k = 1; k &lt;= 700; k++) ; QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time (unregistered) : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; //====================// QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); for (register int i = 1; i &lt;= 700; i++) for (register int j = 1; j &lt;= 700; j++) for (register int k = 1; k &lt;= 700; k++) ; QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time (registered) : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出：Use time (unregistered) : 0.88237 Sec.Use time (registered) : 0.855508 Sec.可以看到是有些优化的。将循环改到\(800^3\)，输出：Use time (unregistered) : 1.322 Sec.Use time (registered) : 1.19792 Sec.再改到\(1000^3\)，输出：Use time (unregistered) : 2.63044 Sec.Use time (registered) : 2.23786 Sec.改为\(350,000,000\)的一重循环，发现反例：Use time (unregistered) : 0.989227 Sec.Use time (registered) : 1.19519 Sec. 总结虽然register关键字有小幅优化（有时则相反），但对于\(O(N^3)\)的时间复杂度也力不从心。所以，优化算法才是王道！ 参考C++中register关键字]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++技巧」 计时]]></title>
    <url>%2F2017%2F07%2F31%2FC%2B%2B-%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[说明计时可以在C++里面方便地实现，可以在诸如NOIP、NOI之类的比赛中了解算法最坏运算时间。当然，如果对于自己算法的时间复杂度很有信心的话（\(O(N)\)之类的）请移步……不过如果复杂度到了\(O(N^2)\)或\(O(N \log N)\)的级别的话还是建议测一下，前提是你会敲……毕竟第2、3种方法比较复杂，考试时用的是Dev-C++又不是Visual Studio。 方法1用time()函数获取当前系统时间。time()函数返回的是time_t类型的数据，返回值是从1970年1月1日（UNIX TIME的纪元时间）到当前时刻的秒数。 代码#include&lt;iostream&gt;#include&lt;time.h&gt;using namespace std;time_t st, ed;void work()&#123; for (int i = 1; i &lt;= 300000000; i++) ;&#125;int main()&#123; st = time(NULL); work(); ed = time(NULL); cout &lt;&lt; "Use Time : " &lt;&lt; ed - st &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Use Time : 1 Sec. 可以看到C++循环里啥都不干1秒能跑3亿次循环。 方法2（实属无聊）用SYSTEMTIME里的函数获取当前系统时间（毫秒级）。 代码#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;void work()&#123; for (int i = 1; i &lt;= 300000000; i++) ;&#125;int main()&#123; SYSTEMTIME st, ed; GetLocalTime(&amp;st); work(); GetLocalTime(&amp;ed); cout &lt;&lt; "Start Time : " &lt;&lt; st.wYear &lt;&lt; '/' &lt;&lt; st.wMonth &lt;&lt; '/' &lt;&lt; st.wDay &lt;&lt; ' ' &lt;&lt; st.wHour &lt;&lt; ':' &lt;&lt; st.wMinute &lt;&lt; ':' &lt;&lt; st.wSecond &lt;&lt; ':' &lt;&lt; st.wMilliseconds &lt;&lt; " Week" &lt;&lt; st.wDayOfWeek &lt;&lt; endl; cout &lt;&lt; "End Time : " &lt;&lt; ed.wYear &lt;&lt; '/' &lt;&lt; ed.wMonth &lt;&lt; '/' &lt;&lt; ed.wDay &lt;&lt; ' ' &lt;&lt; ed.wHour &lt;&lt; ':' &lt;&lt; ed.wMinute &lt;&lt; ':' &lt;&lt; ed.wSecond &lt;&lt; ':' &lt;&lt; ed.wMilliseconds &lt;&lt; " Week" &lt;&lt; ed.wDayOfWeek &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Start Time : 2017/8/1 20:55:50:369 Week2 End Time : 2017/8/1 20:55:51:209 Week2 推翻上面数据。跑3亿次循环仅需840毫秒，上面的情况只是由于测试是在起始秒的第160毫秒后计算的。用此程序测得1s最多循环次数为344,795,000（1.001s）。注意：要看CPU和内存的性能，相同机器不同时间可能结果有异。 方法3（更无聊了）用QueryPerformanceCounter()函数返回高精确度性能计数器的值（微秒级）。 代码#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;void work()&#123; for (int i = 1; i &lt;= 350000000; i++) ;&#125;int main()&#123; LARGE_INTEGER st, ed, t; QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); work(); QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Use time : 0.93279 Sec. 事实证明3亿5千万完全没压力（运气好的话）。 结尾其实方法远不止这3种……。NOIP的话建议第二种即可，第一种实在不敢恭维。再次注意不要迷信测出来的时间！具体运行时间要看CPU、内存的性能及人品！NOIP好运！]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1553」 数字反转（升级版）]]></title>
    <url>%2F2017%2F07%2F31%2F%E6%B4%9B%E8%B0%B7-1553%2F</url>
    <content type="text"><![CDATA[题外话这题也坑了我好久……谁说分到“简单”字符串的？？？话说好像字符串的题一碰就死……然而【狡（Wei）黠（Suo）的微笑】，这题可以不用字符串。所以你没看到上面的Tags有一个STL啊？？语言歧视（笑）。欸，你没发现题解几乎和洛谷 1308一毛一样？？？ 题目链接洛谷 1553 题解本题考点是字符串的操作，如果你聪明的话也可以用stack实现。也是两种解法：一是找出特殊字符位置做相应处理，二是像我一样用stack实现（其实我也是看到别人题解才恍然大悟的）。由于第二种方法涉及到STL，所以就写第二种了（Pascal党请移步）。细节较多，请自己体会。 解释为什么可以用stack实现？原因在于stack（栈）这种线性数据结构的特性：FILO（First In Last Out）刚好符合题中反转的要求！ 代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;sstream&gt;//stringstreamusing namespace std;stack &lt;char&gt; stac;string st;char ch, op;bool flag;int main()&#123; getline(cin, st); stringstream read(st);//用stringstream只为锻（Zhuang）炼（Bi） flag = true; while (read &gt;&gt; ch) &#123; if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; if (op != '.') stac.push(ch);//进栈 else &#123; if (!(ch == '0' &amp;&amp; flag)) stac.push(ch); if (ch != '0') flag = false; &#125; &#125; else &#123; op = ch; while (!stac.empty() &amp;&amp; stac.top() == '0')//是否为空栈 stac.pop();//出栈 if (stac.empty()) cout &lt;&lt; 0; while (!stac.empty()) &#123; cout &lt;&lt; stac.top();//取栈顶元素 stac.pop(); &#125; cout &lt;&lt; op; &#125; &#125; while (!stac.empty() &amp;&amp; stac.top() == '0') stac.pop(); if (op != '%') if (stac.empty()) cout &lt;&lt; 0; while (!stac.empty()) &#123; cout &lt;&lt; stac.top(); stac.pop(); &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1308」 统计单词数]]></title>
    <url>%2F2017%2F07%2F30%2F%E6%B4%9B%E8%B0%B7-1308%2F</url>
    <content type="text"><![CDATA[题外话这题坑了我好久……谁说分到“简单”字符串的？？？ 题目链接洛谷 1308 题解本题考点是字符串的操作。两种解法：一是读完文章再操作，二是边读边操作。由于第一种方法用的标准函数较多，就写第一种了（虽然第二种较优），有兴趣的可以尝试第二种（实际上是我懒得写第二种了）。 细节如果使用algorithm里的transform函数的话要注意函数的意义：第1、2个参数是字符串的起始、结束位置。第3个参数是开始应用转换的位置。第4个参数是执行的操作（toupper/tolower）。还有一点，如果直接写成“transform(string.begin(), string.end(), string.begin(), tolower);”这样的话提交至OJ有可能出错：“error: no matching function for call to ‘transform(std::basic_string::iterator, std::basic_string::iterator, std::basic_string::iterator, )’”这里就需要将C++的函数强制改为C的（本是同根生，相煎何太急……）：transform(string.begin(), string.end(), string.begin(), ::tolower); 代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;string wrd, sen, st;int ans, wh, tmp;bool flag;//用于确定是否是第二次扫描int main()&#123; wh = 0x7f7f7f7f; getline(cin, wrd);//字符串读至行末回车 getline(cin, sen); transform(wrd.begin(), wrd.end(), wrd.begin(), ::tolower);//transform函数将所有字母转小写，包含于algorithm头文件 transform(sen.begin(), sen.end(), sen.begin(), ::tolower); int i = 0;//字符串从0开始 while (i &lt; sen.size()) &#123; if (sen[i] == ' ')//防止开头出现空格 &#123; i++; continue; &#125; st = sen.substr(i, wrd.size()); if (st == wrd &amp;&amp; (sen[i + wrd.size()] == ' ')) wh = min(wh, i), ans++, i += wrd.size();//第一次出现的序号一定最小，偷懒 else &#123; tmp = sen.find(' ', i);//从第i个位置开始找字符' ' if (tmp != -1) &#123; i = tmp + 1; continue; &#125; else &#123; if (!flag) flag = 1; else break; &#125; &#125; i++; &#125; if (!ans) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; wh &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1091」 合唱队形]]></title>
    <url>%2F2017%2F07%2F29%2F%E6%B4%9B%E8%B0%B7-1091%2F</url>
    <content type="text"><![CDATA[题外话最近都刷的什么垃圾题目啊……连我自己都不忍直视 题目链接洛谷 1091 题解在大意中已经写的很明显了，要求最少的不在原序列的元素个数。虽然读起来有些别扭，但仔细一想，可以转化成求最长符合条件的子序列的长度，再拿\(n\)减去该长度即可。再看题，符合条件的子序列是什么？满足“有且只有一个元素与其左边所有元素单调上升，与其右边所有元素单调下降”。明显是最长上升子序列和最长下降子序列的组合！我们可以把前\(i\)个元素变成一个序列并求最长上升子序列的长度，第\(i+1\)~第\(n\)个元素变成一个序列并求最长下降子序列的长度。设\(f(i)\)为取第\(i\)个元素的最长上升/下降子序列长度。得DP方程：\(f(i)=max(f(i),f(j)+1),\;a_i＜(＞)a_j,\,j&lt;i\) 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n, ans;int a[1001], f[1001];void ms()&#123; memset(f, 0, sizeof(f));&#125;bool judge(int op, int x, int y)&#123; if (!op) return x &gt; y; else return x &lt; y;&#125;int longest(int op, int x)&#123; //若op=0，则求最长上升子序列长度，否则求最长下降子序列长度。 //C++中语句连起来可以写成 S1, S2, S3;的形式。 int st, ed; if (!op) st = 1, ed = x; else st = x, ed = n; ms(); for (int i = st; i &lt;= ed; i++) &#123; f[i] = 1; for (int j = st; j &lt; i; j++) &#123; if (judge(op, a[i], a[j])) f[i] = max(f[i], f[j] + 1); &#125; &#125; int tmp = -0x7f7f7f7f; for (int i = st; i &lt;= ed; i++) tmp = max(tmp, f[i]); return tmp;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) ans = max(ans, longest(0, i) + longest(1, i+1)); cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 3371」 【模板】单源最短路径]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%B4%9B%E8%B0%B7-3371%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 3371 题解图的最短路有多种解法，如Dijkstra（贪心）、Floyed（DP），还有我们即将讨论的SPFA（BFS）。说SPFA是BFS也有些牵强。SPFA与BFS最大的区别就在于BFS某个结点只会访问一次，即出队列就不会二次进队，而SPFA则允许二次进队的情况出现。貌似唯一可能让顶点二次进队的情况只有一种：负环。这也是SPFA比其它两种最短路算法更优的原因（可判负环）。此外，SPFA也有DFS的。接下来讨论SPFA的操作步骤 SPFA 初始化（数组、源点）。 每次取出队首元素\(u\)，搜索以\(u\)为起点的每一条边\(e=(u,v)\) 若符合松弛条件，松弛； 否则继续循环。 当头指针=尾指针时结束循环。 代码#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct Edge&#123; int to, wei, next;&#125;edge[500001];int head[500001], dis[10001], q[10000001];int n, m, s, num_edge, a, b, c;bool vis[10001];void add(int a, int b, int c)&#123; edge[++num_edge].to = b; edge[num_edge].wei = c; edge[num_edge].next = head[a]; head[a] = num_edge;&#125;void spfa()&#123; memset(dis, 0x7f7f7f7f, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[s] = 0; vis[s] = true; int l = 1, r = 1; q[1] = s; while (l &lt;= r) &#123; int u = q[l]; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (dis[v] &gt; dis[u] + edge[i].wei) &#123; dis[v] = dis[u] + edge[i].wei; if (!vis[v]) &#123; q[++r] = v; vis[v] = true; &#125; &#125; &#125; vis[u] = false; l++; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; spfa(); for (int i = 1; i &lt;= n; i++) &#123; if (s == i) cout &lt;&lt; 0 &lt;&lt; ' '; else if (dis[i] == 0x7f7f7f7f) cout &lt;&lt; 2147483647 &lt;&lt; ' '; else cout &lt;&lt; dis[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 3366」 【模板】最小生成树]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%B4%9B%E8%B0%B7-3366%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 3366 题解对于图\(G=(V,E)\)，最小生成树有两种较普遍的解法，即Kruskal算法和Prim算法。这里的程序采用Kruskal。接下来讨论Kruskal的操作步骤。 步骤 对于边集合\(E\)，按照边权从小到大排序。 对于\(m\)条边扫一遍。每次判断若加该边是否构成环： 若不构成，则最小生成树边数+1，权值和加上该边权值； 否则继续循环。 若最小生成树边数=图的顶点数-1，则输出权值和，否则输出orz。 这样Kruskal算法流程就结束了。下面对执行时的两个细节进行讨论。 细节 判断是否构成环。其实本步只需判断是否所加入的边\(e∈E\)的两个顶点\(u,v∈e\)是否在一集合里。想到集合，自然会想到并查集的实现。有关并查集，在此不赘述。 最小生成树的边数数一定是图（树）的顶点数-1。最小生成树的定义是：若图\(G=(V,E)\)是一个连通的无向图，则把它所有顶点\(V\)与部分边\(E’\)构成连通无环子图\(G’\)（图\(G\)的生成树），所有可能的生成树\(G’\)中边集\(E’\)中所有边的权值和最小的图\(G’\)称为图\(G\)的最小生成树。我们可以首先将图\(G’\)（最小生成树是一个图）连成一个环，最少需\(|V|\)条边。但如果仅需保证图是联通的，就有一条边是不必要的。所以最小生成树中有\(|V|-1\)条边。 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int ans, n, m, num_ans, tmp;int rt[500001];struct Edge&#123; int from, to, wei;&#125;edge[8000001];bool cmp(Edge a, Edge b)&#123; return a.wei &lt; b.wei;&#125;void init()&#123; for (int i = 1; i &lt;= n; i++) rt[i] = i;&#125;int getrt(int x)&#123; if (rt[x] == x) return x; else return rt[x] = getrt(rt[x]);&#125;void _union(int x, int y)&#123; rt[y] = x;&#125;void kruskal()&#123; sort(edge + 1, edge + m + 1, cmp); for (int i = 1; i &lt;= m; i++) &#123; int fr = getrt(edge[i].from), tr = getrt(edge[i].to); if (fr == tr) continue; else &#123; _union(fr, tr); ans += edge[i].wei; num_ans++; &#125; if (num_ans == n - 1) return; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].wei; &#125; init(); kruskal(); if (num_ans == n-1) cout &lt;&lt; ans; else cout &lt;&lt; "orz"; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1020」 导弹拦截]]></title>
    <url>%2F2017%2F07%2F20%2F%E6%B4%9B%E8%B0%B7-1020%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 1020 题解这题分两问，在大意中已很明确地分析出来了。接下来，让我们分问题讨论。 第一问对于第一问，很显然是DP。设\(f(i)\)表示从\(1\)~\(i\)以\(i\)结尾（取\(i\)）的最长不上升子序列的最长长度\((i≤n)\)。由于是\(1\)~\(i\)这些导弹，所以有必要再加一层循环，判断第\(j\)发导弹是否能打。得DP方程： \(f(i)=max(f(i),f(j+1)),\;a_i≤a_j,\,j&lt;i\) 第二问第二问可以用贪心解决。一遍循环，将当前\(a_i,\,1≤i≤n\)与在数组\(ar\)中最小的不小于\(a_i\)的编号\(k\)与值记录下来，存入\(ar_k\)中。若无此值，则再加一个元素。最后统计\(ar\)数组元素个数即可。 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int cnt = 0, _max, sum;int a[105], f[105], ar[105];int main()&#123; ios::sync_with_stdio(false);//cin、cout优化 while (cin &gt;&gt; a[++cnt]) ; cnt--; //求第一问 for (int i = 1; i &lt;= cnt; i++) &#123; f[i] = 1; for (int j = 1; j &lt; i; j++) &#123; if (a[i] &lt;= a[j]) f[i] = max(f[i], f[j] + 1); &#125; &#125; for (int i = 1; i &lt;= cnt; i++) _max = max(_max, f[i]); cout &lt;&lt; _max &lt;&lt; endl; //求第二问 for (int i = 1; i &lt;= cnt; i++) &#123; int wh = 0; _max = 0x7f7f7f7f; for (int j = 1; j &lt;= sum; j++) &#123; if (ar[j] &gt;= a[i] &amp;&amp; ar[j] &lt; _max) &#123; _max = ar[j]; wh = j; &#125; &#125; if (!wh) ar[++sum] = a[i]; else ar[wh] = a[i]; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[Blog基于Hexo搭建，使用NexT.Pisces主题，使用GitHub Pages托管网页。 简介个人信息目前初二，来自江苏镇江丹阳三中。 操作系统Microsoft Windows 10 EnterpriseVMWare + elementary OS IDEMicrosoft Visual Studio Enterprise 2017 编译器MinGW-GCCVC++Python 3.6 编辑器Notepad++Sublime Text 3Visual Studio Code Tags月厨东方厨OIer二次元重度依赖症患者and so on…]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
