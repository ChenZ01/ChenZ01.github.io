<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「AtCoder Beginner Contest 133」]]></title>
    <url>%2F2019%2F07%2F08%2FABC-133%2F</url>
    <content type="text"><![CDATA[神FFjet带窝上分 TasksB - Good DistanceAnalysis按题意模拟 Code12345678910111213141516171819202122232425int n, d, ans;long long a[20][20];int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; d; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= d; ++j) std::cin &gt;&gt; a[i][j]; for (int i = 1; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; long long s = 0; for (int k = 1; k &lt;= d; ++k) s += (a[i][k] - a[j][k]) * (a[i][k] - a[j][k]); if ((int)std::sqrt(s) * (int)std::sqrt(s) == s) ++ans; &#125; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; C - Remainder Minimization 2019Analysis首先有$2019 = 3 \times 673$考虑到如果$[l, r]$中有$673$的倍数与$3$的倍数答案就为$0$，若区间长度$r - l + 1 \ge 673$我们可以直接输出$0$. 否则区间长度很小，直接暴力求解 Code思路混乱的考场上区间长度搞不清 12345678910111213141516171819202122int l, r;long long ans = 0x7f7f7f7f;int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; l &gt;&gt; r; if (r - l &gt;= 673) std::cout &lt;&lt; 0 &lt;&lt; std::endl; else &#123; for (int i = l; i &lt; r; ++i) &#123; for (int j = i + 1; j &lt;= r; ++j) &#123; ans = std::min(1ll * i * 1ll * j % 2019, ans); &#125; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; &#125; return 0;&#125; D - Rain Flows into DamsAnalysis列方程$$\begin{cases} (a_1 + a_2) / 2 = A_1 &amp;(1)\\ (a_2 + a_3) / 2 = A_2 &amp;(2)\\ \cdots \\ (a_n + a_1) / 2 = A_n &amp;(n)\end{cases}$$将偶数编号方程乘上$-1$，将前$n - 1$个方程相加得到$$(a_1 - a_n) / 2 = \sum_{i = 1} ^ {n - 1}A_i$$与第$n$个方程相加得到$a_1$, 依次带入方程消元 Code1234567891011121314151617181920212223242526int n;long long a[1000010], A[1000010];int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; std::cin &gt;&gt; a[i]; &#125; long long s = 0; for (long long i = 1, minus = 1; i &lt; n; ++i) &#123; s += minus * a[i]; minus = -minus; &#125; A[1] = a[n] + s; for (int i = 2; i &lt;= n; ++i) &#123; A[i] = 2 * a[i - 1] - A[i - 1]; &#125; for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; A[i] &lt;&lt; " "; return 0;&#125; E - Virus Tree 2Analysis记节点$i$放置的方案数为$\binom{c_i}{1}$我们先考虑对根节点$1$染色, 显然有$c_1 = k$接着考虑$1$的子节点. 不难发现其第一个子节点有$c= k - 1$, 其第二个子节点有$c = k - 2$, 以此类推得到$1$的所有子节点的$c$值接下来考虑$1$的子节点的子节点. 显然对于$1$的某个子节点的第一个子节点有$c = k - 2$, 第二个有$c = k - 3$. 且我们注意到$1$的任意两个子节点的任意两个子节点不会互相影响故有结论: 对于深度大于$2$的 (根节点深度为$1$) 节点, 有最左边的节点$c$值为$k - 2$, 其兄弟节点 (父节点相同) 的$c$值递减. 不为兄弟节点的深度相同的节点由于互不影响, 再从$c = k - 2$重新对新的一部分进行求值答案即为$$\prod_i \binom{c_i}{1}$$ Code123456789101112131415161718192021222324252627282930313233int n, k, u, v;int c[100010];std::vector &lt;int&gt; g[100010];void dfs(int x, int fr)&#123; int cnt = 0; for (auto i : g[x]) if (i != fr) &#123; c[i] = k - 2 - (cnt++); dfs(i, x); &#125;&#125;int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt; n; ++i) std::cin &gt;&gt; u &gt;&gt; v, g[u].push_back(v), g[v].push_back(u); c[1] = k; for (int i = 0, lim = g[1].size(); i &lt; lim; ++i) c[g[1][i]] = k - (i + 1), dfs(g[1][i], 1); long long ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; (ans *= 1ll * c[i]) %= 1000000007; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; F - Colorful Tree咕咕咕, 等FFjet巨巨教窝QwQ]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOISC Day1]]></title>
    <url>%2F2019%2F07%2F05%2FJSOISC-Day1%2F</url>
    <content type="text"><![CDATA[T1 - lemonAnalysisMethod 1打表易发现当且仅当$n = 2 ^ k, k\in \mathbb{N}$时能成功 Method 2首先考虑$n$为非$1$奇数的情况 可以发现$(\sum_{i =1} ^ ki)\,\mathrm{mod}\,n$构成一个长度为$n$的循环节 故对于所有整数$k\in[1, n]$若$(\sum_{i =1} ^ ki)\,\mathrm{mod}\,n$重复出现则失败 由于$(\sum_{i =1} ^ ni)\,\mathrm{mod}\,n = (\sum_{i =1} ^ {n - 1}i)\,\mathrm{mod}\,n$, 除$1$以外的奇数均失败 故奇数的倍数也失败 故只有仅拥有非奇数因子的数能成功 即$$n = 2 ^ k$$ Code12345678910111213141516171819int n, cases;int main()&#123; for (read(cases); cases; --cases) &#123; int flag = 1; read(n); for (; n &gt; 1; n &gt;&gt;= 1) if (n &amp; 1) &#123; flag = 0; break; &#125; printf(flag ? "Yes\n" : "No\n"); &#125; return 0;&#125; T2 - helpersAnalysis令$p_i$表示一个人拥有$i$积分时不被淘汰的概率, $\Sigma$表示$\sum a_i$ 有$p_i = \frac{1}{2}p_{i - 1} + \frac{1}{2}p_{i + 1}$其中$p_0 = 0, p_\Sigma = 1$由于$p_i = 1 / 2 p_{i - 1} + 1 / 2 p_{i + 1}, \, p_0 = 0$, 可知$p_1 = 1 / 2p_{2}$故$p_2 = 2p_1 = 1 / 2p_{1} + 1 / 2p_{3}$故$1 / 2p_3 = 3 / 2p_1 \Rightarrow p_3 = 3p_1$我们得到$p_i = ip_1$由于$p_\Sigma = \Sigma \times p_1 = 1$, 我们有$p_1 = 1 / \Sigma$最后得到$p_i = i / \Sigma$ Code12345678910111213141516171819202122232425262728293031323334template &lt;typename T&gt;void write(T x)&#123; if (x &lt; 10) putchar(x ^ 48); else write(x / 10), putchar((x % 10) ^ 48);&#125;long long fastExp(long long base, int index = 998244351)&#123; long long res = 1; for (; index; base = base * base % 998244353, index &gt;&gt;= 1) if (index &amp; 1) res = res * base % 998244353; return res;&#125;int n;int a[10000010];long long sigma;int main()&#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]), sigma += a[i]; long long inv = fastExp(sigma); for (int i = 1; i &lt;= n; ++i) a[i] = (long long)a[i] * inv % 998244353; for (int i = 1; i &lt;= n; ++i) write(a[i]), putchar(' '); return 0;&#125; T3 - hackAnalysis考虑模拟 将当前最大权置为$0$ 按输入顺序扫每一条边 对于当前边 若属于MST, 则直接将其权赋为当前最大权 $+ 1$ 若不属于MST, 则其一定与某几条属于MST的边构成环 将其权赋为当前最大权 $+$ 所在环内没有被赋值过的边的个数 $+ 1$, 并且对环内未被赋值的边按输入顺序从当前最大权 (不算刚刚赋值的非MST边) 开始赋值 由于遍历到环中某个点就会遍历环中所有点, 对于遍历过的环进行缩点即可 Code施工中]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 2406 & 1961」 Power Strings & Period]]></title>
    <url>%2F2019%2F05%2F29%2FPOJ-2406-1961%2F</url>
    <content type="text"><![CDATA[双倍经验 Solution2406再回顾一遍$\pi$函数的定义显然，若一个串是由循环节构成的，为模式串真后缀 (停顿) 且为模式串前缀的串 (停顿) 的最长长度 (停顿) 即为模式串长减去循环节长那么做完了哇 1961把上文中 “模式串真后缀” 改为 “模式串某前缀的真后缀”，每个位置求一遍即可 Code虽然依然只跟$\pi$函数有关但还是挂个KMP的名字吧 2406123456789void KMP(std::string s)&#123; prefixFunction(s); int m = s.length() - 1; if (m % (m - pi[m]) == 0) std::cout &lt;&lt; m / (m - pi[m]) &lt;&lt; std::endl; else std::cout &lt;&lt; 1 &lt;&lt; std::endl;&#125; 1961123456789101112void KMP(std::string s)&#123; prefixFunction(s); int m = s.length() - 1; std::cout &lt;&lt; "Test case #" &lt;&lt; ++testCase &lt;&lt; std::endl; for (int i = 2; i &lt;= m; ++i) &#123; if (pi[i] &amp;&amp; i % (i - pi[i]) == 0) std::cout &lt;&lt; i &lt;&lt; " " &lt;&lt; i / (i - pi[i]) &lt;&lt; std::endl; &#125; std::cout &lt;&lt; std::endl;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 2752」 Seek the Name, Seek the Fame]]></title>
    <url>%2F2019%2F05%2F29%2FPOJ-2752%2F</url>
    <content type="text"><![CDATA[这名字好中二啊 Solution考虑到前缀函数$\pi$的定义：$\pi_q$等于 (停顿) 是模式串前缀$P_q$的真后缀 (停顿) 且是模式串$P$的最长前缀的串 (停顿) 的长度显然$\pi_{P.length}$符合题意，接下来根据$\pi$迭代即可 Code虽然只跟$\pi$函数有关但还是挂个KMP的名字吧 1234567891011121314151617181920212223242526272829303132333435int pi[400010];void prefixFunction(std::string s)&#123; memset(pi, 0, sizeof pi); int m = s.length() - 1, k = 0; for (int q = 2; q &lt;= m; ++q) &#123; while (k &amp;&amp; s[k + 1] != s[q]) k = pi[k]; if (s[k + 1] == s[q]) ++k; pi[q] = k; &#125;&#125;void KMP(std::string s)&#123; prefixFunction(s); int x = s.length() - 1; std::priority_queue &lt;int, std::vector &lt;int&gt; , std::greater &lt;int&gt; &gt; q; while (pi[x]) q.push(pi[x]), x = pi[x]; while (q.size()) std::cout &lt;&lt; q.top() &lt;&lt; " ", q.pop(); std::cout &lt;&lt; s.length() - 1&lt;&lt; std::endl;&#125;int main()&#123; std::string s = ""; while (std::cin &gt;&gt; s) s = ' ' + s, KMP(s); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO2009」 抢掠计划]]></title>
    <url>%2F2019%2F05%2F29%2FAPIO2009-%E6%8A%A2%E6%8E%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[弃Tarjan拥抱Kosaraju Solution强连通分量缩点，标记一下缩点后的哪些点有酒吧，跑最长路由于Kosaraju算法处理后的图顶点编号就是拓扑序 (好评！)，直接DP即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071constexpr static int ___maxN = 500010;int n, m, u, v, top, cntSCC, s, p;int vis[___maxN], stack[___maxN], belong[___maxN], moneyCross[___maxN], tagCross[___maxN], tag[___maxN], money[___maxN], f[___maxN];std::vector &lt;int&gt; g[___maxN], rG[___maxN];std::map &lt;int, int&gt; connected[___maxN];void dfs(int x)&#123; vis[x] = 1; for (auto i : g[x]) if (!vis[i]) dfs(i); stack[++top] = x;&#125;void rDFS(int x)&#123; vis[x] = 1, belong[x] = cntSCC; for (auto i : rG[x]) if (!vis[i]) rDFS(i);&#125;void SCC()&#123; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i); memset(vis, 0, sizeof vis); for (int i = n; i; --i) if (!vis[stack[i]]) ++cntSCC, rDFS(stack[i]);&#125;int main()&#123; read(n, m); for (int i = 1; i &lt;= m; ++i) read(u, v), g[u].push_back(v), rG[v].push_back(u); for (int i = 1; i &lt;= n; ++i) read(moneyCross[i]); read(s, p); for (int i = 1; i &lt;= p; ++i) read(u), tagCross[u] = 1; SCC(); for (int i = 1; i &lt;= n; ++i) &#123; if (!belong[i]) continue; money[belong[i]] += moneyCross[i], tag[belong[i]] |= tagCross[i]; for (auto j : g[i]) if (belong[i] != belong[j] &amp;&amp; belong[j]) connected[belong[i]][belong[j]] = 1; &#125; f[belong[s]] = money[belong[s]]; for (int i = belong[s]; i &lt;= cntSCC; ++i) &#123; for (auto j : connected[i]) &#123; u = j.first; f[u] = std::max(f[u], f[i] + money[u]); &#125; &#125; int ans = 0; for (int i = belong[s]; i &lt;= cntSCC; ++i) if (tag[i]) ans = std::max(ans, f[i]); std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>SCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2140」 稳定婚姻]]></title>
    <url>%2F2019%2F05%2F29%2FBZOJ-2140-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%2F</url>
    <content type="text"><![CDATA[大型NTR现场 Solution人物之间瞎连一通，判断二人是否在同一SCC里即可 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364constexpr static int ___maxN = 100010;int n, m, cntNode, cntSCC, top;int stack[___maxN], belong[___maxN], vis[___maxN];std::string gi, bo;std::vector &lt;int&gt; g[___maxN], rG[___maxN];std::map &lt;std::string, int&gt; map;void dfs(int x)&#123; vis[x] = 1; for (int i : g[x]) if (!vis[i]) dfs(i); stack[++top] = x;&#125;void rDFS(int x)&#123; vis[x] = 1, belong[x] = cntSCC; for (int i : rG[x]) if (!vis[i]) rDFS(i);&#125;void SCC()&#123; memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= cntNode; ++i) if (!vis[i]) dfs(i); memset(vis, 0, sizeof vis); cntSCC = 0; for (int i = cntNode; i; --i) if (!vis[stack[i]]) ++cntSCC, rDFS(stack[i]);&#125;int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; std::cin &gt;&gt; gi &gt;&gt; bo; map[gi] = ++cntNode, map[bo] = ++cntNode; g[cntNode - 1].push_back(cntNode); rG[cntNode].push_back(cntNode - 1); &#125; std::cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; std::cin &gt;&gt; gi &gt;&gt; bo; g[map[bo]].push_back(map[gi]); rG[map[gi]].push_back(map[bo]); &#125; SCC(); for (int i = 1; i &lt;= cntNode; i += 2) if (belong[i] != belong[i + 1]) std::cout &lt;&lt; "Safe" &lt;&lt; std::endl; else std::cout &lt;&lt; "Unsafe" &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>SCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」 品酒大会]]></title>
    <url>%2F2019%2F05%2F29%2FNOI2015-%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Solution显然答案具有后缀和性质考虑按$\mathrm{height}$从大到小顺序处理，每次将两个后缀所在集合合并，计算$\mathrm{hight}_t$相似的答案注意两个极小负数乘积也会极大 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109constexpr static int ___maxN = 300010;struct SuffixArray&#123; std::string st = ""; int len = 0, size = 0; int bucket[1000010], pos[1000010], sa[1000010], rank[1000010], height[1000010]; // Each array starts from 1 void radixSort() &#123; for (int i = 1; i &lt;= size; ++i) bucket[i] = 0; for (int i = 1; i &lt;= len; ++i) ++bucket[rank[i]]; for (int i = 1; i &lt;= size; ++i) bucket[i] += bucket[i - 1]; for (int i = len; i; --i) sa[bucket[rank[pos[i]]]--] = pos[i]; &#125; void getSA() &#123; for (int i = 1; i &lt;= len; ++i) rank[i] = st[i], pos[i] = i; radixSort(); for (int w = 1, p = 0; p &lt; len &amp;&amp; w &lt;= len; size = p, w &lt;&lt;= 1) &#123; p = 0; for (int i = len - w + 1; i &lt;= len; ++i) pos[++p] = i; for (int i = 1; i &lt;= len; ++i) if (sa[i] &gt; w) pos[++p] = sa[i] - w; radixSort(); std::swap(rank, pos); rank[sa[1]] = p = 1; for (int i = 2; i &lt;= len; ++i) rank[sa[i]] = pos[sa[i]] == pos[sa[i - 1]] &amp;&amp; pos[sa[i] + w] == pos[sa[i - 1] + w] ? p : ++p; &#125; &#125; void getHeight() &#123; int j = 0, k = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (k) --k; j = sa[rank[i] - 1]; while (st[i + k] == st[j + k]) ++k; height[rank[i]] = k; &#125; &#125; void main(std::string __st, int __size = 127) &#123; st = __st, len = st.length() - 1, size = __size; getSA(), getHeight(); &#125;&#125;;int n;int a[___maxN], rt[___maxN], id[___maxN], size[___maxN];long long max[___maxN], min[___maxN], setMax[___maxN], ans[___maxN], sum[___maxN];std::string st;SuffixArray SA;int cmp(const int&amp; x, const int&amp; y)&#123; return SA.height[x] &gt; SA.height[y];&#125;int getRt(int x)&#123; return rt[x] == x ? x : rt[x] = getRt(rt[x]);&#125;void unite(int x, int y, int len)&#123; x = getRt(x), y = getRt(y); rt[y] = x; sum[len] += 1ll * size[x] * size[y]; size[x] += size[y]; setMax[x] = std::max(setMax[x], std::max(setMax[y], std::max(1ll * max[x] * max[y], 1ll * min[x] * min[y]))); max[x] = std::max(max[x], max[y]); min[x] = std::min(min[x], min[y]); ans[len] = std::max(ans[len], setMax[x]);&#125;int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; st, st = ' ' + st; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i]; SA.main(st); for (int i = 1; i &lt;= n; ++i) max[i] = min[i] = a[i], ans[i] = setMax[i] = -1e18, id[i] = rt[i] = i, size[i] = 1; ans[n + 1] = ans[0] = -1e18; std::sort(id + 2, id + n + 1, cmp); for (int i = 2; i &lt;= n; ++i) unite(SA.sa[id[i]], SA.sa[id[i] - 1], SA.height[id[i]]); for (int i = n; ~i; --i) sum[i] += sum[i + 1], ans[i] = std::max(ans[i], ans[i + 1]); for (int i = 0; i &lt; n; ++i) std::cout &lt;&lt; sum[i] &lt;&lt; " " &lt;&lt; (!sum[i] ? 0 : ans[i]) &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 2348」 Euclid's Game]]></title>
    <url>%2F2019%2F05%2F24%2FPOJ-2348%2F</url>
    <content type="text"><![CDATA[还是第一次写博弈论的题目呐虽然完全口胡做法 Solution考虑到一方输一定是被迫输的，也就是只有可能这么选我们用$(a, b)$表示当前两个数 ($a &gt; b$)，令$c$为最大的使$bc &lt; a$的整数 $b = 1$。这就没得其它方法选了，继续往下做吧 $b &gt; 1$。若我们这一轮将状态变为$(a - (c - 1)b, b)$，此时变成对方无法选择，下一步对方只可能将其变成$(b, a - bc)$。然而我们可以直接在这一轮将状态变为$(b, a - bc)$。也就是说我们既可以自己将状态变成$(b, a - bc)$，也可以通过对方之手变换，故这种状态是必胜的 那么就结束啦，细节自己判去（ Code1234567891011121314151617181920212223242526272829303132333435template &lt;typename Num&gt;void read(Num&amp; x)&#123; char ch = 0; for (ch = getchar(); !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;template &lt;typename Num, typename ...List&gt;void read(Num&amp; x, List&amp; ...y)&#123; read(x), read(y...);&#125;int solve(int x, int y)&#123; int f = 1; for (; ; ) &#123; if (x &lt; y) std::swap(x, y); if (x % y == 0 || x - y &gt; y) return f; x -= y; f = !f; &#125;&#125;int main()&#123; int a = 0, b = 0; for (read(a, b); a &amp;&amp; b; read(a, b)) std::cout &lt;&lt; (solve(a, b) ? "Stan" : "Ollie") &lt;&lt; " wins" &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder Beginner Contest 126」]]></title>
    <url>%2F2019%2F05%2F20%2FABC-126%2F</url>
    <content type="text"><![CDATA[ABC的题量突然增多了……向ARC看齐了？ TasksC - Dice and CoinAnalysis从来没有做过概率题的ChenZ01表示很慌……仔细一想这不跟GCJ 2008 APAC C几乎一样么……注意一下概率均要乘上$1 / n$首先考虑点数为$d \ge K$的情况，这就不用掷第二遍了，$P(d) = 1$然后我们考虑$d &lt; K$的情况，不难发现$d\ge\lceil k / 2\rceil$时概率为$1 / 2$，其余情况$P(d) = 1 / 2 * P(2d)$ Code123456789101112131415161718192021int n, k;long double f[3000010]; int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; k; for (int i = k / 2 + k % 2; i &lt; k; ++i) f[i] = 0.5; for (int i = k; i &lt;= n; ++i) f[i] = 1; for (int i = k / 2 + k % 2 - 1; i; --i) &#123; f[i] = 0.5 * f[i * 2]; &#125; long double ans = 0; for (int i = 1; i &lt;= n; ++i) ans += f[i]; printf("%.12Lf\n", ans / (long double)n); return 0;&#125; D - Even RelationAnalysis令$1$为root，直接将其染黑/白，根据边奇偶对子节点染色即可容易验证这样构造出来的一定没问题 Code1234567891011121314151617181920212223242526272829303132333435363738394041struct Edge&#123; int v, w; Edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125;&#125;; int n;int c[100010];std::vector &lt;Edge&gt; t[100010]; void dfs(int x, int fr, int col)&#123; c[x] = col; for (auto i : t[x]) &#123; int v = i.v; if (v == fr) continue; if (i.w % 2) // Odd dfs(v, x, !col); else dfs(v, x, col); &#125;&#125; int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt; n; ++i) &#123; int u = 0, v = 0, w = 0; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; t[u].push_back(Edge(v, w)); t[v].push_back(Edge(u, w)); &#125; dfs(1, 0, 0); // Black for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; c[i] &lt;&lt; std::endl; return 0;&#125; E - 1 or 2Analysis考虑若$A_x$与$A_y$被直接或间接的fact涉及，则我们知道$A_x$则一定能知道$A_y$并查集处理即可比赛时思路比较乱就写了个连边求连通块个数的，实质就是并查集 Code这是比赛脑抽连边的版本1234567891011121314151617181920212223242526272829303132333435363738int n, m, cnt;int vis[100010];std::vector &lt;int&gt; rela[100010]; void dfs(int x)&#123; vis[x] = 1; for (auto i : rela[x]) &#123; if (!vis[i]) dfs(i); &#125;&#125; int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; int x = 0, y = 0, z = 0; std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; rela[x].push_back(y), rela[y].push_back(x); &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[i]) &#123; if (rela[i].size()) ++ans, dfs(i); else ++ans; &#125; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; F - XOR MatchingAnalysis感谢FlyInTheSky聚聚的Construction，其实本题不止一种构造方法判断完后构造即可存在性只需判断除$k$以外全部数的异或和是否为$0$ Code1234567891011121314151617181920212223242526272829// Construct [k, 0, 1, ..., k - 1, k + 1, ..., 2 ^ m, k, 2 ^ m, ..., k + 1, k - 1, ..., 2, 1, 0]int m, k; int main()&#123; std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; m &gt;&gt; k; if (k == 0) &#123; for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) std::cout &lt;&lt; i &lt;&lt; " " &lt;&lt; i &lt;&lt; " "; return 0; &#125; int s = 0; for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) if (i != k) s ^= i; if (s != k) return (std::cout &lt;&lt; -1 &lt;&lt; std::endl), 0; std::cout &lt;&lt; k &lt;&lt; " "; for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) if (i != k) std::cout &lt;&lt; i &lt;&lt; " "; std::cout &lt;&lt; k &lt;&lt; " "; for (int i = (1 &lt;&lt; m) - 1; ~i; --i) if (i != k) std::cout &lt;&lt; i &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder Beginner Contest 125」]]></title>
    <url>%2F2019%2F05%2F19%2FABC-125%2F</url>
    <content type="text"><![CDATA[TasksC - GCD on BlackboardAnalysis令$l(i) = \mathrm{gcd}_{j\le i}a_j$，$r(i) = \mathrm{gcd}_{j \ge i}a_j$，则显然答案为$\max_{i}\lbrace \gcd(l(i - 1), r(i + 1))\rbrace$ Code123456789101112131415161718192021222324252627constexpr static int ___maxN = 100010;int gcd(int x, int y)&#123; return y ? gcd(y, x % y) : x;&#125;int n, ans;int a[___maxN], l[___maxN], r[___maxN];int main()&#123; std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) l[i] = ::gcd(l[i - 1], a[i]); for (int i = n; i; --i) r[i] = ::gcd(r[i + 1], a[i]); for (int i = 1; i &lt;= n; ++i) ans = std::max(ans, ::gcd(l[i - 1], r[i + 1])); std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; D - Flipping SignsAnalysis我们发现负号可以任意移动。比如$a, -b, c$可以变为$-a, b, c$和$a, b, -c$那么我们将负号全部挪到一起，再2个2个消去，可知如果负号的个数为偶数则可以将整个数列全部变成正的否则将负号移动到绝对值最小的那个数上即可 Code123456789101112131415161718192021222324int n, cntMinus;int a[1000010];long long ans;int main()&#123; std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i], cntMinus += a[i] &lt;= 0; if (cntMinus % 2) &#123; int _min = 0x7f7f7f7f; for (int i = 1; i &lt;= n; ++i) ans += a[i] &gt; 0 ? a[i] : -a[i], _min = std::min(_min, a[i] &gt; 0 ? a[i] : -a[i]); ans -= 2 * 1ll * _min; &#125; else for (int i = 1; i &lt;= n; ++i) ans += a[i] &gt; 0 ? a[i] : -a[i]; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1165」]]></title>
    <url>%2F2019%2F05%2F17%2FCodeforces-1165%2F</url>
    <content type="text"><![CDATA[Tasks这场CF粉碎了我摆脱pupil的希望（ A - RemainderAnalysis理智分析，我们只需将第$y$bit之后的所有bit置为$0$，第$x$bit到第$y$bit之间的所有bit置为$0$即可哇别忘记第$y$bit要置为$1$哇注意特判$y = 0$的情况哇 Code123456789101112131415161718192021222324252627282930int n, x, y, ans;std::string st;int main()&#123; std::cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for (ch = getchar(); !isdigit(ch); ch = getchar()); for (; isdigit(ch); st = ch + st, ch = getchar()); st = ' ' + st; if (y == 0) &#123; if (st[1] == '0') ++ans; for (int i = 2; i &lt;= x; ++i) if (st[i] != '0') ++ans; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0; &#125; for (int i = 1; i &lt;= y; ++i) if (st[i] != '0') ++ans; if (st[y + 1] == '0') ++ans; for (int i = y + 2; i &lt;= x; ++i) if (st[i] != '0') ++ans; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; B - Polycarp TrainingAnalysis排序后模拟即可，码量比A还小哇…… Code1234567891011121314151617181920212223int n, ans = 1;int a[2000010];int main()&#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); std::sort(a + 1, a + n + 1); for (int i = 1; ; ++i) &#123; while (a[i] &lt; ans &amp;&amp; i &lt;= n) ++i; if (i &gt; n) &#123; --ans; break; &#125; ++ans; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; C - Good StringAnalysis注意到删去两个相同字符的任意一个带来的影响是一样的，模拟即可哇注意特判字符串长度为$1$的情况啊！！我就是这么被hack的 Code12345678910111213141516171819202122232425262728293031int n, ans;std::string st;int main()&#123; read(n); std::cin &gt;&gt; st; if (st.length() == 1) &#123; std::cout &lt;&lt; 1 &lt;&lt; std::endl &lt;&lt; std::endl; return 0; &#125; for (int i = 0; ;) &#123; if (st[i] == st[i + 1]) ++ans, st.erase(i, 1); else i += 2; n = st.length(); if (i == n - 1) &#123; ++ans; st.erase(i, 1); break; &#125; else if (i == n) break; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl &lt;&lt; st &lt;&lt; std::endl;; return 0;&#125; D - Almost All DivisorsAnalysis先将$\lbrace d\rbrace$排序考虑到若$\lbrace d\rbrace$为数$x$的全部非平凡约数，则定有$x = d_1\cdot d_n$接下来只需$\mathcal{O}(\sqrt{n})$验证约数是否全部存在于$\lbrace d\rbrace$中即可哇数据千万条，清空第一条。多测不清空，爆零两行泪。 Code12345678910111213141516171819202122232425262728int cases, n;int appear[1000010];long long d[1000010];int main()&#123; for (read(cases); cases; --cases) &#123; memset(appear, 0, sizeof appear); int flag = 0, cnt = 0; read(n); for (int i = 1; i &lt;= n; ++i) read(d[i]), appear[d[i]] = 1; std::sort(d + 1, d + n + 1); long long x = d[1] * d[n], limit = sqrt(x); for (int i = 2; i &lt;= limit; ++i) if (x % i == 0) if ((!appear[i] || !appear[x / i]) &amp;&amp; (flag = 1)) break; else cnt += (i != x / i) + 1; if (flag || cnt != n) std::cout &lt;&lt; -1 &lt;&lt; std::endl; else std::cout &lt;&lt; x &lt;&lt; std::endl; &#125; return 0;&#125; E - Two Arrays and Sum of FunctionsAnalysis考虑$a_i\cdot b_i$累加的次数，显然为$i\cdot(n - i + 1)$那么我们要计算的就是$\sum_{i = 1} ^ {n} a_ib_ii(n - i + 1)$，故不妨令$a_i$乘上$i(n - i + 1)$使用Rearrangement Inequality即可 Code123456789101112131415161718constexpr static int ___maxN = 200010, ___mod = 998244353;int n;long long a[___maxN], b[___maxN];long long ans;int main()&#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]), a[i] *= (long long)i * (n - i + 1); for (int i = 1; i &lt;= n; ++i) read(b[i]); std::sort(a + 1, a + n + 1), std::sort(b + 1, b + n + 1); for (int i = 1; i &lt;= n; ++i) (ans += (long long)a[i] % ___mod * b[n - i + 1] % ___mod) %= ___mod; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; F - MicrotransactionsAnalysis这里直接将F1和F2并作F令答案为$ans$，显然能得到$ans \le2\cdot \sum k_i$题目中的$\sum k_i \le 2\cdot 10^5$非常微妙，故想到二分天数由于能获得的microtransaction随天数单调不降，故可以二分judge()函数贪心选取合法的时间最靠后的促销即可哇 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253constexpr static int ___maxN = 200010;struct Data&#123; int d, t; Data(int d = 0, int t = 0) : d(d), t(t) &#123;&#125;&#125;;int cmp(const Data&amp; x, const Data&amp; y)&#123; return x.d &gt; y.d;&#125;int n, m, tot;int k[___maxN], b[___maxN];Data a[___maxN];int judge(long long x)&#123; memcpy(b, k, sizeof b); int calc = 0, curMoney = x; for (int i = 1; i &lt;= m &amp;&amp; curMoney; ++i) if (a[i].d &lt;= x) &#123; calc += std::min(b[a[i].t], std::min(curMoney, a[i].d)); int lMoney = curMoney; curMoney = std::max(0, std::min(curMoney, a[i].d) - b[a[i].t]); b[a[i].t] = std::max(b[a[i].t] - std::min(lMoney, a[i].d), 0); &#125; for (int i = 1; i &lt;= n; ++i) calc += 2 * b[i]; return calc &lt;= x;&#125;int main()&#123; read(n, m); for (int i = 1; i &lt;= n; ++i) read(k[i]), tot += k[i]; for (int i = 1; i &lt;= m; ++i) read(a[i].d, a[i].t); std::sort(a + 1, a + m + 1, cmp); int l = 1, r = tot * 2; while (l &lt;= r) &#123; long long mid = l + r &gt;&gt; 1; if (judge(mid)) r = mid - 1; else l = mid + 1; &#125; std::cout &lt;&lt; l &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>二分</tag>
        <tag>不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2016」 找相同字符]]></title>
    <url>%2F2019%2F05%2F07%2FHAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Solution考虑容斥将两个串用分隔符拼在一起，则求该串的相同子串个数减去两个串各自相同的子串个数 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;struct SuffixArray&#123; std::string st = ""; int len = 0, size = 0; int bucket[1000010], pos[1000010], sa[1000010], rank[1000010], height[1000010]; // Each array starts from 1 void radixSort() &#123; for (int i = 1; i &lt;= size; ++i) bucket[i] = 0; for (int i = 1; i &lt;= len; ++i) ++bucket[rank[i]]; for (int i = 1; i &lt;= size; ++i) bucket[i] += bucket[i - 1]; for (int i = len; i; --i) sa[bucket[rank[pos[i]]]--] = pos[i]; &#125; void getSA() &#123; for (int i = 1; i &lt;= len; ++i) rank[i] = st[i], pos[i] = i; radixSort(); for (int w = 1, p = 0; p &lt; len &amp;&amp; w &lt;= len; size = p, w &lt;&lt;= 1) &#123; p = 0; for (int i = len - w + 1; i &lt;= len; ++i) pos[++p] = i; for (int i = 1; i &lt;= len; ++i) if (sa[i] &gt; w) pos[++p] = sa[i] - w; radixSort(); std::swap(rank, pos); rank[sa[1]] = p = 1; for (int i = 2; i &lt;= len; ++i) rank[sa[i]] = pos[sa[i]] == pos[sa[i - 1]] &amp;&amp; pos[sa[i] + w] == pos[sa[i - 1] + w] ? p : ++p; &#125; &#125; void getHeight() &#123; int j = 0, k = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (k) --k; j = sa[rank[i] - 1]; while (st[i + k] == st[j + k]) ++k; height[rank[i]] = k; &#125; &#125; void main(std::string __st, int __size = 127) &#123; memset(sa, 0, sizeof sa); memset(height, 0, sizeof height); memset(bucket, 0, sizeof bucket); memset(pos, 0, sizeof pos); memset(rank, 0, sizeof rank); st = __st, len = st.length() - 1, size = __size; getSA(), getHeight(); &#125;&#125;;std::string a, b;SuffixArray SA;long long ans;long long f[2000010];void solve(int op, std::string st)&#123; SA.main(' ' + st); std::stack &lt;long long&gt; stack; memset(f, 0, sizeof f); int n = st.length(); for (int i = 1; i &lt;= n; ++i) &#123; while (stack.size() &amp;&amp; SA.height[stack.top()] &gt;= SA.height[i]) stack.pop(); if (!stack.size()) f[i] = SA.height[i] * (i - 1); else f[i] = f[stack.top()] + SA.height[i] * (i - stack.top()); stack.push(i); ans += 1ll * op * f[i]; &#125;&#125;int main()&#123; std::cin &gt;&gt; a &gt;&gt; b; solve(1, a + '!' + b); solve(-1, a); solve(-1, b); std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>SA</tag>
        <tag>单调栈</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2013」 差异]]></title>
    <url>%2F2019%2F05%2F07%2FAHOI2013-%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[Solution显然$\sum_{1\le i&lt;j\le n}\mathrm{len}(T_i) + \mathrm{len}(T_j) = (n - 1)n(n + 1) / 2$，故我们只需求每对后缀的$\mathrm{lcp}$即可观察到$\mathrm{lcp}$的前缀和具有单调性，故单调栈维护即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;struct SuffixArray&#123; std::string st = ""; int len = 0, size = 0; int bucket[1000010], pos[1000010], sa[1000010], rank[1000010], height[1000010]; // Each array starts from 1 void radixSort() &#123; for (int i = 1; i &lt;= size; ++i) bucket[i] = 0; for (int i = 1; i &lt;= len; ++i) ++bucket[rank[i]]; for (int i = 1; i &lt;= size; ++i) bucket[i] += bucket[i - 1]; for (int i = len; i; --i) sa[bucket[rank[pos[i]]]--] = pos[i]; &#125; void getSA() &#123; for (int i = 1; i &lt;= len; ++i) rank[i] = st[i], pos[i] = i; radixSort(); for (int w = 1, p = 0; p &lt; len &amp;&amp; w &lt;= len; size = p, w &lt;&lt;= 1) &#123; p = 0; for (int i = len - w + 1; i &lt;= len; ++i) pos[++p] = i; for (int i = 1; i &lt;= len; ++i) if (sa[i] &gt; w) pos[++p] = sa[i] - w; radixSort(); std::swap(rank, pos); rank[sa[1]] = p = 1; for (int i = 2; i &lt;= len; ++i) rank[sa[i]] = pos[sa[i]] == pos[sa[i - 1]] &amp;&amp; pos[sa[i] + w] == pos[sa[i - 1] + w] ? p : ++p; &#125; &#125; void getHeight() &#123; int j = 0, k = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (k) --k; j = sa[rank[i] - 1]; while (st[i + k] == st[j + k]) ++k; height[rank[i]] = k; &#125; &#125; void main(std::string __st, int __size = 127) &#123; st = __st, len = st.length() - 1, size = __size; getSA(), getHeight(); &#125;&#125;;struct Data&#123; int val, pos; Data(int val = 0, int pos = 0) : val(val), pos(pos) &#123;&#125;&#125;;std::string st;SuffixArray SA;long long f[1000010];int main()&#123; std::cin &gt;&gt; st; int n = st.length(), del = 0; st = ' ' + st; SA.main(st); long long ans = (long long)(n + 1) * n * (n - 1) / 2; std::stack &lt;Data&gt; stack; for (int i = 1; i &lt;= n; ++i) &#123; while (stack.size() &amp;&amp; stack.top().val &gt;= SA.height[i]) stack.pop(); if (stack.size()) f[i] = f[stack.top().pos] + (i - stack.top().pos) * SA.height[i]; else f[i] = i * SA.height[i]; stack.push(Data(SA.height[i], i)); &#125; for (int i = 1; i &lt;= n; ++i) ans -= 2 * f[i]; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>SA</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2019」 骗分过样例]]></title>
    <url>%2F2019%2F05%2F07%2FJSOI2019-%E9%AA%97%E5%88%86%E8%BF%87%E6%A0%B7%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Overview本题的题意即为给定所有输入输出文件，让选手猜测每个点要实现的目的与方法经观察，Case 1-7与$19$的幂次有关，Case 8-16与区间内的数和函数有关同时经提示、联想与对数据的观察，不难得出：?表示某数未知，wa表示溢出，p表示质数（prime number），u表示Möbius函数（$\mu$），g表示原根（primitive root，常记为$g$）初步的观察对于解题有着极大的帮助。观察过后，我们开始对每个Case进行分析 SolutionCase 1-3经观察可发现要求输出$19$的幂次对$998244353$取模的结果 Method 1使用高精度乘法 Method 2使用欧拉定理$$a^{\varphi(n)}\equiv 1(\mathrm{mod}\,n)\quad \text{if}\,\gcd(a, n) = 1$$在使用快读的时候将输入数据对$\varphi(998244353) = 998244352$取模即可 Case 4经观察可发现要求输出$19$的幂次对某一质数$p$取模的结果观察下发的software4.ans可得到大致范围$p\in(1.1\times10^6, 1.2\times10^6)$，故枚举得到$p = 1145141$ Case 5要求同Case 4一样，经观察可得出大致范围$p\in(5.2\times10^{18}, 5.3\times10^{18})$，故需要更优的解法设输入数据中某两个数为$x_1, x_2$，其对应的值为$y_1, y_2$，则在模$p$意义下有$19^{x_1}\equiv y_1, 19^{x_2}\equiv y_2$。稍作变形可得到$$y_1\cdot19^{x_2 - x_1}\equiv y_2(\mathrm{mod}\,p)$$故$p | y_1\cdot19^{x_2 - x_1} - y_2$。根据software5.in和software5.ans中的两组指数相近的情况再经简单枚举可得出$p = 5211600617818708273$ Case 6-7经观察可发现要求输出$19$的幂次对$p = 998244353$取模的结果，但中间运算溢出导致出现错误结果考虑19的某次方对$p$取模且溢出的结果可看做在区间$(-p, p)$内随机选择了一个数。根据生日悖论，存在多个指数对应相同的结果的概率是相当大的。故我们断定：必然会存在$1 &lt; x_1 &lt; x_2$使得输出的结果相同。即从$x_1$开始每$x_2 - x_1$个数构成相同的循环节预处理后$\mathcal{O}(1)$解决一个询问 Case 8-10经观察可发现要求判断指定区间内每个数为质数还是合数 Method 1由于区间长度不大于1000000，考虑直接对每个数Miller-Rabin测试 Method 2考虑筛法对于Case 8，直接线性筛对于Case 9，考虑到任意合数$a\in[10^6, 10^{12}]$必有质因子$p\in(1, 10^6)$，故先筛出$10^6$以内的质数，再用这些质数筛出所求区间内的合数对于Case 10，类似Case 9 + 打表解决 Case 11-13经观察可发现要求输出指定区间内每个数的Möbius函数考虑先筛出$10^6$以内所有质数及所有数的Möbius函数。对于小于等于$10^6$的询问$\mu(x)$直接输出否则先将$x$的所有小于等于$10^6$的质因子全部除去并同时统计$\mu(x)$，设最后我们得到了$x_0$。显然$x_0$要么等于1，要么由最多两个大于$10^6$的质数组成。设当前统计到的$\mu(x)$为$\mu_P(x)$对于$x_0$， 判断其是否为质数 若是，则输出$-\mu_P(x)$ 否则继续第2步 判断其是否为完全平方数 若是，则输出$0$ 否则其一定有两个与之前筛出的不同的质因子，则输出$\mu_P(x)\times(-1)\times(-1) = \mu_P(x)$ 实现时注意Miller-Rabin的基选取问题，经尝试仅需选取24251 Case 14-15经观察可发现要求判断指定区间内每个数是否是指定质数$p$的原根对于$p = 998244353$，由欧拉定理可知，若$x^t\equiv1(\mathrm{mod}\,p), t &lt; \varphi(p)$，则定有$t|\varphi(p)$。故若对于$p$的任意质因子$p_i$，都有$x^{p_i}\not\equiv1(\mathrm{mod}\,p)$，则$x$是$p$的一个原根。每个数验证即可对于$p = 13123111$，由于$\varphi(p)$的质因子较多，故不能按以上方法实现考虑先求出某一原根$g$。令$x = g^k\,\mathrm{mod}\,p$，则若$x$为原根，就有$$g^{k\varphi(p)}\equiv1(\mathrm{mod}\,p)$$且$\varphi(p)$是最小的使$g^{kt}\equiv1(\mathrm{mod}\,p)$的正整数$t$。而$g^{\varphi(p)}\equiv1(\mathrm{mod}\,p)$，故$k\perp\varphi(p)$预处理出每个$x$的$k$与每个数是否与$\varphi(p)$互质即可 Case 16已知$p\in[10^9, 2\times10^9]$，要求判断指定区间内每个数是否是质数$p$的原根由于不同质数在同一区间内原根的分布情况是混乱的，故不是解的$p$一定会很快被排除。故只需筛出所有可能的质数代入求解即可 Code过长，还是不放了]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI2011」 Race]]></title>
    <url>%2F2019%2F04%2F14%2FIOI2011-Race%2F</url>
    <content type="text"><![CDATA[Solution考虑DSU on Tree维护一个std::map，保存每个长度对应的最小深度，每个节点查询答案 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;map&gt;constexpr static int ___maxN = 200010;char ch;template &lt;typename T&gt;void read(T&amp; x)&#123; for (ch = getchar(); !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;int n, k, u, v, w, dfn, ans = 0x7f7f7f7f;int hS[___maxN], sze[___maxN], id[___maxN], nid[___maxN], depth[___maxN];long long dis[___maxN];std::vector &lt;int&gt; to[___maxN], wei[___maxN];std::map &lt;long long, int&gt; map;void getHS(int x, int fr)&#123; sze[x] = 1, id[x] = ++dfn, nid[dfn] = x, depth[x] = depth[fr] + 1; int __max = 0, __size = to[x].size(); for (int i = 0; i &lt; __size; ++i) &#123; int tmp = to[x][i]; if (tmp != fr) &#123; dis[tmp] = dis[x] + wei[x][i]; getHS(tmp, x); sze[x] += sze[tmp]; if (sze[tmp] &gt; __max) __max = sze[tmp], hS[x] = tmp; &#125; &#125;&#125;void update(int x, int y)&#123; int z = dis[x]; if (y == -1) map[z] = 0; else &#123; if (!map[z]) map[z] = depth[x]; else map[z] = std::min(map[z], depth[x]); &#125;&#125;void dfs(int x, int fr, int keep)&#123; for (auto i : to[x]) if (i != fr &amp;&amp; i != hS[x]) dfs(i, x, 0); if (hS[x]) dfs(hS[x], x, 1); for (auto i : to[x]) if (i != fr &amp;&amp; i != hS[x]) &#123; for (int j = 0; j &lt; sze[i]; ++j) &#123; int nxt = nid[id[i] + j], req = k + 2 * dis[x] - dis[nxt]; if (map.count(req) &amp;&amp; map[req]) ans = std::min(ans, map[req] + depth[nxt] - 2 * depth[x]); &#125; for (int j = 0; j &lt; sze[i]; ++j) update(nid[id[i] + j], 1); &#125; update(x, 1); if (map.count(dis[x] + k) &amp;&amp; map[dis[x] + k]) ans = std::min(ans, map[dis[x] + k] - depth[x]); if (!keep) for (int i = 0; i &lt; sze[x]; ++i) update(nid[id[x] + i], -1);&#125;int main()&#123; read(n), read(k); for (int i = 1; i &lt; n; ++i) read(u), read(v), read(w), to[u].push_back(v), to[v].push_back(u), wei[u].push_back(w), wei[v].push_back(w); getHS(0, 0); dfs(0, 0, 0); std::cout &lt;&lt; (ans == 0x7f7f7f7f ? -1 : ans) &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DSU on Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1009」 F - Dominant Indices]]></title>
    <url>%2F2019%2F04%2F04%2FCodeforces-1009-F%2F</url>
    <content type="text"><![CDATA[132个点真TM好评 Solution题意即为找到每个子树含有最多节点的那一层的深度，若有则输出第一个这玩意还是裸的吧 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;constexpr static int ___maxN = 1000010;char ch;template &lt;typename T&gt;void read(T&amp; x)&#123; for (x = 0, ch = getchar(); !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;int n, maxD, cHS, u, v;int ans[___maxN], sze[___maxN], depth[___maxN], hS[___maxN], cnt[___maxN];std::vector &lt;int&gt; t[___maxN];void getHS(int x, int fr)&#123; sze[x] = 1, depth[x] = depth[fr] + 1; for (auto i : t[x]) if (i != fr) &#123; getHS(i, x), sze[x] += sze[i]; if (sze[hS[x]] &lt; sze[i]) hS[x] = i; &#125;&#125;void add(int x, int fr, int y)&#123; cnt[depth[x]] += y; if (cnt[depth[x]] &gt; cnt[maxD] || cnt[depth[x]] == cnt[maxD] &amp;&amp; depth[x] &lt; maxD) maxD = depth[x]; for (auto i : t[x]) if (i != fr &amp;&amp; i != cHS) add(i, x, y);&#125;void dfs(int x, int fr, int keep)&#123; for (auto i : t[x]) if (i != fr &amp;&amp; i != hS[x]) dfs(i, x, 0); if (hS[x]) dfs(hS[x], x, 1), cHS = hS[x]; add(x, fr, 1); ans[x] = maxD - depth[x], cHS = 0; if (!keep) add(x, fr, -1), maxD = 0;&#125;int main()&#123; read(n); for (int i = 1; i &lt; n; ++i) read(u), read(v), t[v].push_back(u), t[u].push_back(v); getHS(1, 0), dfs(1, 0, 1); for (int i = 1; i &lt;= n; ++i) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DSU on Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 570」 D - Tree Requests]]></title>
    <url>%2F2019%2F04%2F04%2FCodeforces-570-D%2F</url>
    <content type="text"><![CDATA[Solution判断重排后是否回文有个显而易见的方式：若该串中的任意两种或以上字符存在奇数个则不回文由于只有26个字母，考虑用二进制来压缩信息，用异或$\oplus$更新信息显然，若每个二进制位被更新偶数次则为$0$，被更新奇数次则为$1$那么只需判断状态是否是$2$的次幂或$0$即可，注意$1$也是可行的，可用!(x &amp; (x - 1))判断 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;int n, m, u, v, curChild;int sze[500010], bigChild[500010], depth[500010], letter[500010], cnt[500010], ans[500010];char ch;std::vector &lt;int&gt; g[500010];std::vector &lt;std::pair &lt;int, int&gt; &gt; query[500010];template &lt;typename T&gt;void read(T&amp; x)&#123; for (x = 0, ch = getchar(); !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;void getBigChild(int x, int fr = 0)&#123; sze[x] = 1, depth[x] = depth[fr] + 1; for (auto i : g[x]) getBigChild(i, x), sze[x] += sze[i], bigChild[x] = sze[i] &gt; sze[bigChild[x]] ? i : bigChild[x];&#125;void add(int x)&#123; cnt[depth[x]] ^= (1 &lt;&lt; letter[x]); for (auto i : g[x]) if (i != curChild) add(i);&#125;void dfs(int x, int keep = 0)&#123; for (auto i : g[x]) if (i != bigChild[x]) dfs(i, 0); if (bigChild[x]) dfs(bigChild[x], 1), curChild = bigChild[x]; add(x), curChild = 0; for (auto i : query[x]) ans[i.second] = !(cnt[i.first] &amp; (cnt[i.first] - 1)); if (!keep) add(x);&#125;int main()&#123; read(n), read(m); for (int i = 2; i &lt;= n; ++i) read(u), g[u].push_back(i); for (ch = getchar(); !isalpha(ch); ch = getchar()); for (int i = 1; i &lt;= n; ++i) letter[i] = ch - 'a', ch = getchar(); for (int i = 1; i &lt;= m; ++i) read(u), read(v), query[u].push_back(std::make_pair(v, i)); depth[1] = 1; getBigChild(1); dfs(1); for (int i = 1; i &lt;= m; ++i) printf(ans[i] ? "Yes\n" : "No\n"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DSU on Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2015」 概率论]]></title>
    <url>%2F2019%2F03%2F16%2FTJOI2015-%E6%A6%82%E7%8E%87%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Solution令$g(i)$表示有$i$个节点的不同形态的树的个数令$f(i)$表示有$i$个节点的不同形态的树的叶子节点的总个数那么答案即为$f(i) / g(i)$ $g$不难想到，有$$g(n) = \sum_{i}g(i)g(n - i - 1) + [n = 0]$$看出来这玩意是个卷积哇令$G(z)$为$g$的OGF，两边同时乘上$z ^ n$，有\begin{align}G(z) &amp;= \sum_{n}g(n)z ^ n \notag \\&amp;= \sum_{i, n}g(i)g(n - i - 1)z ^ n + \sum_{n = 0}z ^ n \notag \\&amp;= \sum_ig(i)z ^ i\sum_ng(n - i - 1)z ^ {n - i} + 1 \notag \\&amp;= G(z) \cdot zG(z) + 1 \notag\end{align}解得$$G(z) = \frac{1\pm\sqrt{1 - 4z}}{2z}$$因为$G(0) = 1$，对两式分别求极限\begin{align}\lim_{z\to 0^+}\frac{1+\sqrt{1 - 4z}}{2z} = +\infty \notag \\\lim_{z\to 0^+}\frac{1-\sqrt{1 - 4z}}{2z} = 1\notag\end{align}故取$G(z) = \frac{1-\sqrt{1 - 4z}}{2z}$由二项式定理，得\begin{align}\sqrt{1 - 4z} &amp;= \sum_{i \ge 0}\tbinom{1 / 2}{i}(-4z) ^ i\notag\\&amp;= 1 + \sum_{i \ge 1}\frac{1}{2i}\tbinom{-1 / 2}{i - 1}(-4z) ^ i\notag\end{align}由于$$\tbinom{-1/2}{n} = \tbinom{-1}{4} ^ n\tbinom{2n}{n}$$故\begin{align}\frac{1 - \sqrt{1 - 4z}}{2z} &amp;= \sum_{i \ge 1}\frac{1}{i}\tbinom{-1 / 2}{i - 1}(-4z) ^ {i - 1}\notag \\&amp;=\sum_{n \ge 0}\tbinom{-1 / 2}{n}\frac{(-4z) ^ n}{n + 1}\notag \\&amp;=\sum_{n \ge 0}\tbinom{2n}{n}\frac{z ^ n}{n + 1}\notag\end{align}故$$g(n) = [z ^ n]G(z) = \tbinom{2n}{n}\frac{1}{n + 1}$$ $f$搞完$g$来搞$f$哇依然不难想到$$f(n) = 2\sum_{i = 0}^{n - 1}f(i)g(n - i - 1)$$令$F(z)$为$f$的OGF，推导略，得$$F(z) = 2zF(z)G(z) + z = z(1 - 4z) ^ {- 1 / 2}$$观察到$$(zG(z))’ = \frac{1}{\sqrt{1 - 4z}} = \frac{F(z)}{z}$$故$$f(n) = ng(n - 1)$$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OGF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder Beginner Contest 121」 D - XOR World]]></title>
    <url>%2F2019%2F03%2F11%2FABC-121-D%2F</url>
    <content type="text"><![CDATA[这回连C都省掉了 Analysis观察异或运算$\oplus$的性质 $\forall n = 2k, k\in \mathbb{N}, n \oplus (n + 1) = 1$ $\forall n \in \mathbb{N}, n \oplus n = 0$ 因此有$F(A, B) = F(0, A - 1) \oplus F(0, B)$将$F(0, n)$写成如下形式\begin{align}F(0, n) &amp;= 0 \oplus 1\oplus 2\oplus 3\dots (n - 1)\oplus n \notag \\&amp;= (0 \oplus 1) \oplus (2 \oplus 3)\dots \notag \\\end{align}判断$n$的奇偶计算即可 Code12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;long long a, b;long long f(long long x)&#123; if (x &amp; 1) return (x + 1) / 2 % 2; else return (x / 2 % 2) ^ x;&#125;int main()&#123; std::cin &gt;&gt; a &gt;&gt; b; std::cout &lt;&lt; (f(a - 1) ^ f(b)) &lt;&lt; "\n"; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder Beginner Contest 120」]]></title>
    <url>%2F2019%2F03%2F08%2FABC-120%2F</url>
    <content type="text"><![CDATA[Tasks我估计以后ABC的A和B都会被我省掉 C - UnificationAnalysis考虑到如果一个序列存在$0$和$1$，怎么搞都能消掉它们那么答案就是$0$和$1$的个数取最小值即可 Code123while (isdigit(ch = getchar())) a[++n] = ch ^ 48, cntZero += a[n] == 0, cntOne += a[n];std::cout &lt;&lt; std::min(cntOne, cntZero) * 2 &lt;&lt; "\n"; D - Decayed BridgesAnalysis考虑离线倒着做令第$i$个bridge collapses后的答案为$f(i)$，显然有$f(m) = \frac{n(n - 1)}{2}$倒着考虑，假设一开始bridge全没了，我们一个个加上，则$f(i)$即为加了$i$到$m$这么多边后的答案接下来加bridge $e_i = (a_i, b_i)$，存在两种情况 本来这两个就连通，$f(i) = f(i + 1)$ 这两个不连通，$f(i) = f(i + 1) - N_1 \cdot N_2$，其中$N_1, N_2$分别表示两个island所处连通块的大小 Union-Find Set实现，注意long long Code1234567891011121314151617181920212223242526272829303132int getRoot(int x)&#123; return x == root[x] ? x : root[x] = getRoot(root[x]);&#125;int main()&#123; std::ios::sync_with_stdio(0); std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) std::cin &gt;&gt; a[i] &gt;&gt; b[i]; for (int i = 1; i &lt;= n; ++i) root[i] = i, size[i] = 1; ans[m + 1] = n * (n - 1) / 2; for (int i = m; i &gt; 1; --i) &#123; int x = getRoot(a[i]), y = getRoot(b[i]); if (x == y) ans[i] = ans[i + 1]; else &#123; ans[i] = ans[i + 1] - size[x] * size[y]; size[x] += size[y]; size[y] = 0; root[y] = x; &#125; &#125; for (int i = 2; i &lt;= m + 1; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; "\n"; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流 24 题」 最长递增子序列]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Solution注意，本题中递增子序列非严格递增 AnalysisTask 1显然的经典DP令$f(i)$表示选择$a_i$作为递增子序列的最后一个数所能得到的最长长度，易得$$f(i) = \max_{j &lt; i, a_j \le a_i}\lbrace f(j)\rbrace + 1$$长度$\max\lbrace f(i)\rbrace$记作$s$ Task 2我们考虑子序列是怎么生成的：设当前序列的结尾是$a_i$，往后拓展序列时，我们会选择$a_i \le a_j, i &lt; j$的$a_j$于是我们将所有$a_i \le a_j, i &lt; j$的点对$(i, j)$连边，形成的图记作$G$对于所有入度为$0$的点 从Super Source向其连边，容量均为$1$。表示可以从这个点开始进行子序列的选择 从这个点进行BFS，找出$G$中从该点经$s - 1$个点能到达的全部点，打上标记。表示该点与搜索出的点能形成$s$个点组成的路径，即能构造出长度为$s$的子序列 接着对于打上标记的点，向Super Sink连边，容量均为$1$跑一遍最大流即可 Task 3这就简单了，将Super Source向$1$的边与$n$向Super Sink的容量设为$+\infty$即可 Find the BugWA了，不过分还比较高一定是哪里出问题了……没错！一个点可以作为向Super Sink连边的点，同时也可以向后面的点连边，这就会导致流量变大怎么解决？跳过中间的组成序列的那些点！我们只关心一个序列的开头和结尾，将其连边即可Super Source/Sink的连边规则不变 Extra丧心病狂的$n = 1$的点，特判即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;struct Edge&#123; int from, to, capa, next; Edge(int from = 0, int to = 0, int capa = 0, int next = 0) : from(from), to(to), capa(capa), next(next) &#123;&#125;&#125;;int n, len, s, t, cntEdge = -1, cur;int a[510], tag[510], indeg[510], num[1010], d[510], head[1000010];Edge edge[1000010];std::vector &lt;int&gt; zeroDeg;std::vector &lt;int&gt; g[510];std::map &lt;int, int&gt; map;void getLen()&#123; int f[510]; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = 1; for (int j = 1; j &lt; i; ++j) if (a[i] &gt;= a[j] &amp;&amp; f[i] &lt;= f[j]) f[i] = f[j] + 1; len = std::max(len, f[i]); &#125; std::cout &lt;&lt; len &lt;&lt; "\n";&#125;void addEdge(int x, int y, int z)&#123; edge[++cntEdge] = Edge(x, y, z, head[x]), head[x] = cntEdge; edge[++cntEdge] = Edge(y, x, 0, head[y]), head[y] = cntEdge;&#125;void findNode(int x, int y)&#123; if (y == len) &#123; map[x] = 1; addEdge(cur, x, 1); return; &#125; for (auto i : g[x]) findNode(i, y + 1);&#125;void buildNetwork()&#123; for (auto i : zeroDeg) addEdge(s, i, 1), cur = i, findNode(i, 1); for (auto&amp; i : map) addEdge(i.first, t, 1);&#125;void bfs()&#123; std::queue &lt;int&gt; q; q.push(t), ++num[d[t] = 1]; while (q.size()) &#123; int x = q.front(); q.pop(); for (int i = head[x]; ~i; i = edge[i].next) &#123; int to = edge[i].to; if (!d[to] &amp;&amp; !edge[i].capa) ++num[d[to] = d[x] + 1], q.push(to); &#125; &#125;&#125;int dfs(int x, int aug)&#123; if (!aug || x == t) return aug; int res = 0, f = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; int to = edge[i].to; if (d[x] == d[to] + 1 &amp;&amp; (f = dfs(to, std::min(aug, edge[i].capa)))) &#123; aug -= f, res += f, edge[i].capa -= f, edge[i ^ 1].capa += f; if (!aug) return res; &#125; &#125; if (!(--num[d[x]])) d[s] = n + 3; ++num[++d[x]]; return res;&#125;void maxFlow()&#123; memset(d, 0, sizeof d); memset(num, 0, sizeof num); int res = 0; bfs(); while (d[s] &lt;= n + 2) res += dfs(s, 0x7f7f7f7f); std::cout &lt;&lt; (res == 0x7f7f7f7f ? 1 : res) &lt;&lt; "\n";&#125;void rebuildNetwork()&#123; for (int i = 0; i &lt;= cntEdge; i += 2) &#123; edge[i].capa = 1, edge[i ^ 1].capa = 0; if (edge[i].from == n &amp;&amp; edge[i].to == t) edge[i].capa = 0x7f7f7f7f; else if (edge[i].from == 0 &amp;&amp; edge[i].to == 1) edge[i].capa = 0x7f7f7f7f; &#125;&#125;int main()&#123; memset(head, -1, sizeof head); std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n; s = 0, t = n + 1; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i]; getLen(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) if (a[i] &gt;= a[j]) ++indeg[i], g[j].push_back(i); if (!indeg[i]) zeroDeg.push_back(i); &#125; buildNetwork(); maxFlow(); rebuildNetwork(); maxFlow(); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流 24 题」 软件补丁]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E8%BD%AF%E4%BB%B6%E8%A1%A5%E4%B8%81%2F</url>
    <content type="text"><![CDATA[SolutionAnalysis$n \le 20$……状压！这题目最短路建模挺好想的毕竟我这种状压都没写过的人都会写令第$i$位$0/1$ 对于搜索状态，表示当前无/有错误$i$ 对于补丁，表示否/是引进新错误$i$ 然后跑一遍SPFA，边跑边建边……不用存边…… Attention字符串不要用getchar()读，Windows和Linux的**问题！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;int n, m;int b1[110], b2[110], f1[110], f2[110], a[110], f[(1 &lt;&lt; 20) + 10], vis[(1 &lt;&lt; 20) + 10];std::string A, B;void SPFA()&#123; std::queue &lt;int&gt; q; q.push((1 &lt;&lt; n) - 1); f[(1 &lt;&lt; n) - 1] = 0; while (q.size()) &#123; int x = q.front(), y = 0; q.pop(); vis[x] = 0; for (int i = 1; i &lt;= m; ++i) &#123; if ((b1[i] &amp; x) == b1[i] &amp;&amp; (b2[i] &amp; x) == 0) &#123; y = ((x | f1[i]) ^ f1[i]) | f2[i]; if (f[x] + a[i] &lt; f[y]) &#123; f[y] = f[x] + a[i]; if (!vis[y]) vis[y] = 1, q.push(y); &#125; &#125; &#125; &#125; std::cout &lt;&lt; (f[0] == 0x7f7f7f7f ? 0 : f[0]) &lt;&lt; "\n";&#125;int main()&#123; std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n &gt;&gt; m; memset(f, 0x7f7f7f7f, sizeof f); for (int i = 1; i &lt;= m; ++i) &#123; std::cin &gt;&gt; a[i] &gt;&gt; A &gt;&gt; B; for (int j = 0; j &lt; n; ++j) &#123; if (A[j] == '+') b1[i] |= 1 &lt;&lt; j; else if (A[j] == '-') b2[i] |= 1 &lt;&lt; j; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (B[j] == '-') f1[i] |= 1 &lt;&lt; j; else if (B[j] == '+') f2[i] |= 1 &lt;&lt; j; &#125; &#125; SPFA(); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>状压</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流 24 题」 负载平衡]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Digression本题可以用一种奇特的初中奥数方法乱搞，有兴趣读者可以去洛谷上看题解 SolutionAnalysis一下想到费用流哇设$\overline{a}$为输入数据的平均数，则对于每个仓库只可能有两种情况（不考虑相等）：$a_i &lt; \overline{a}$或$a_i &gt; \overline{a}$我们考虑 $a_i &lt; \overline{a}$即仓库$i$需要有流量汇入，且流量为$\overline{a} - a_i$ $a_i &gt; \overline{a}$即仓库$i$需要有流量流出，且流量为$a_i - \overline{a}$ 于是建立Super Sink从每个需汇入点连边，Super Source向每个需流出点连边，容量皆为$|\overline{a} - a_i|$相邻的仓库别忘连边哇 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cmath&gt;struct Edge&#123; int to, capa, cost, next; Edge (int to = 0, int capa = 0, int cost = 0, int next = 0) : to(to), capa(capa), cost(cost), next(next) &#123;&#125;&#125;;int n, cntEdge = -1, minCost, s, t, tot;int head[100010], dis[100010], vis[100010], a[110];Edge edge[100010];void addEdge(int u, int v, int capa, int cost)&#123; edge[++cntEdge] = Edge(v, capa, cost, head[u]), head[u] = cntEdge; edge[++cntEdge] = Edge(u, 0, -cost, head[v]), head[v] = cntEdge;&#125;int SPFA()&#123; memset(vis, 0, sizeof vis); memset(dis, 0x7f7f7f7f, sizeof dis); dis[t] = 0, vis[t] = 1; std::deque &lt;int&gt; q; q.push_back(t); while (q.size()) &#123; int x = q.front(); q.pop_front(); for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i ^ 1].capa &amp;&amp; dis[edge[i].to] &gt; dis[x] - edge[i].cost) &#123; dis[edge[i].to] = dis[x] - edge[i].cost; if (!vis[edge[i].to]) &#123; vis[edge[i].to] = 1; if (q.size() &amp;&amp; dis[edge[i].to] &lt; dis[q.front()]) q.push_front(edge[i].to); else q.push_back(edge[i].to); &#125; &#125; &#125; vis[x] = 0; &#125; return dis[s] &lt; 0x7f7f7f7f;&#125;int dfs(int x, int aug)&#123; vis[x] = 1; if (x == t) return aug; int f = 0, res = 0; for (int i = head[x]; ~i; i = edge[i].next) &#123; if (edge[i].capa &amp;&amp; !vis[edge[i].to] &amp;&amp; dis[x] - edge[i].cost == dis[edge[i].to]) &#123; f = dfs(edge[i].to, std::min(aug, edge[i].capa)); minCost += f * edge[i].cost; edge[i].capa -= f, edge[i ^ 1].capa += f, aug -= f, res += f; if (!aug) break; &#125; &#125; return res;&#125;void costFlow()&#123; while (SPFA()) &#123; vis[t] = 1; while (vis[t]) memset(vis, 0, sizeof vis), dfs(s, 0x7f7f7f7f); &#125; std::cout &lt;&lt; minCost &lt;&lt; "\n";&#125;int main()&#123; std::ios::sync_with_stdio(0); std::cin.tie(0); memset(head, -1, sizeof head); std::cin &gt;&gt; n; s = 0, t = n + 1; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i], tot += a[i], addEdge(i, i == n ? 1 : i + 1, 0x7f7f7f7f, 1), addEdge(i, i == 1 ? n : i - 1, 0x7f7f7f7f, 1); tot /= n; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt;= tot) addEdge(s, i, a[i] - tot, 0); else addEdge(i, t, tot - a[i], 0); costFlow(); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流 24 题」 搭配飞行员]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E6%90%AD%E9%85%8D%E9%A3%9E%E8%A1%8C%E5%91%98%2F</url>
    <content type="text"><![CDATA[SolutionAnalysis这道题的建模还是很好建的正驾驶和副驾驶配对就从正驾驶往副驾驶连一条边然后建立Super Source往正驾驶连边和Super Sink从副驾驶连边跑一遍最大流即可毒瘤你谷要求输出方案，只需检查跑完最大流后的网络的边的流量即可，下面的代码检查的是反向边流量 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;struct Edge&#123; int v, w, next; Edge(int v = 0, int w = 0, int next = 0) : v(v), w(w), next(next) &#123;&#125;&#125;;int cntEdge = -1, n, m, t, s = 0, a, b, ans;int head[1000010], d[1000010], num[1000010], u[1000010];Edge edge[1000010];void addEdge(int u, int v, int w)&#123; edge[++cntEdge] = Edge(v, w, head[u]), head[u] = cntEdge;&#125;void bfs()&#123; std::queue &lt;int&gt; q; q.push(t), ++num[d[t] = 1]; while (q.size()) &#123; int x = q.front(); q.pop(); for (int i = head[x]; i != -1; i = edge[i].next) &#123; int y = edge[i].v; if (!d[y] &amp;&amp; !edge[i].w) ++num[d[y] = d[x] + 1], q.push(y); &#125; &#125;&#125;int dfs(int cur, int aug)&#123; if (!aug || cur == t) return aug; int ret = 0, f = 0; for (int i = head[cur]; i != -1; i = edge[i].next) &#123; int y = edge[i].v; if (d[cur] == d[y] + 1 &amp;&amp; (f = dfs(y, std::min(aug, edge[i].w)))) &#123; augPair[cur][y] = 1; aug -= f, ret += f, edge[i].w -= f, edge[i ^ 1].w += f; if (!aug) return ret; &#125; &#125; if (!(--num[d[cur]])) d[s] = n + 3; ++num[++d[cur]]; return ret;&#125;int main()&#123; std::ios::sync_with_stdio(0); std::cin.tie(0); memset(head, -1, sizeof head); std::cin &gt;&gt; m &gt;&gt; n; t = n + 1; for (int i = 1; i &lt;= m; ++i) addEdge(s, i, 1), addEdge(i, s, 0); for (int i = m + 1; i &lt;= n; ++i) addEdge(i, t, 1), addEdge(t, i, 0); while (std::cin &gt;&gt; a &gt;&gt; b &amp;&amp; a != -1) addEdge(a, b, 1), addEdge(b, a, 0); bfs(); while (d[s] &lt;= n + 2) ans += dfs(s, 0x7f7f7f7f); std::cout &lt;&lt; ans &lt;&lt; "\n"; for (int i = n * 2; i &lt;= cntEdge; i += 2) if (edge[i ^ 1].w) std::cout &lt;&lt; edge[i ^ 1].v &lt;&lt; " " &lt;&lt; edge[i].v &lt;&lt; "\n"; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces Global Round 1」]]></title>
    <url>%2F2019%2F02%2F10%2FCodeforces-Global-Round-1%2F</url>
    <content type="text"><![CDATA[Digression由于本人太菜，G和H就咕咕咕了 TasksA - ParityAnalysis首先想到直接求哇！过大怎么办，取模哇！模数？19260817事实证明19260817还是很给力地过了7个pretest的，1e9+7只过了3个好啦不扯了讲正解这题还用讲？只用统计奇数的奇数次幂和$a_k$的奇偶性就行了哇 Code123456789101112131415161718192021222324int main()&#123; read(b), read(k); for (int i = 1; i &lt;= k; ++i) read(a[i]); if (b % 2 == 0) &#123; if (a[k] % 2) std::cout &lt;&lt; "odd" &lt;&lt; std::endl; else std::cout &lt;&lt; "even" &lt;&lt; std::endl; return 0; &#125; for (int i = 1; i &lt;= k; ++i) if (a[i] % 2 == 0) continue; else ++ans; if (ans % 2) std::cout &lt;&lt; "odd" &lt;&lt; std::endl; else std::cout &lt;&lt; "even" &lt;&lt; std::endl; return 0;&#125; B - TapeAnalysis出门向下走拿到这题我都觉得吃惊，结束以后才发现评论区里有人放ABC的链接了（雾 Code1234567891011121314int main()&#123; read(n), read(m), read(k); for (int i = 1; i &lt;= n; ++i) read(a[i]); ans = a[n] - a[1] + 1; for (int i = 1; i &lt; n; ++i) b[i] = a[i + 1] - a[i] - 1; std::sort(b + 1, b + n); for (int i = n - 1; i &gt; n - k; --i) ans -= b[i]; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125; C - Meaningless OperationsAnalysis嗯，真meaningless…首先明确一点，答案最多不超过把$a$转成二进制后所有位全变成$1$的数 $a$不能写成$2^k-1$的形式转成二进制后，构造新的数$b$，其比$a$少一位，各位等于$a$的对应位取非比如$a(2)=100010110$，构造$b(2)=11101001$不难发现此时$a$按位与$a \&amp; b=0$，按位异或$a \oplus b=a ^ c - 1$，其中$c$为$a$转二进制后的位数而$\gcd(0, a ^ c - 1) = a ^ c - 1$这就达到上限了哇，肯定最大哇 $a$能写成$2^k-1$的形式我们观察到$a \le 2 ^ {25} - 1$，因此你懂的官方tutorial如是说： or it’s possible to calculate answers for all $a = 2^{x−1}$ beforehand 但我们关心or之前的，因此来搞搞正解我们发现此时$a\&amp;b$就是$b$哇，$a\oplus b$就是$a - b$哇然$\forall a, b\in \mathbb{N^+}, \gcd(a, a + b) = \gcd(a, b)$因此$\gcd(a \&amp; b, a \oplus b) = \gcd(a, b)$那就找最大的约数哇！ Code这里给的是「beforehand」的高级解法哇（雾 12345678910111213141516171819202122232425const int table[] = &#123;0, 0, 1, 1, 5, 1, 21, 1, 85, 73, 341, 89, 1365, 1, 5461, 4681, 21845, 1, 87381, 1, 349525, 299593, 1398101, 178481, 5592405, 1082401, 22369621, 19173961&#125;;int deal(int x)&#123; int judge = 1, sav = x, bt = 0, w = 0; while (sav) judge &amp;= sav, sav &gt;&gt;= 1, (bt &lt;&lt;= 1) |= 1, w += 1; if (judge) // power of 2 - 1 &#123; return table[w]; &#125; else &#123; return bt; &#125;&#125;int main()&#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; deal(a[i]) &lt;&lt; std::endl; return 0;&#125; D - Jongmah从这里我就跪了… Analysis很聪明的做法哇我们规定$t[a, b, c]$表示$t$个$[a, b, c]$这样的triple (没有指明$t$则为$1$)，并且还可以套用结合律（雾那么我们想，$3[x, x + 1, x + 2]$与$[x, x, x], [x + 1, x + 1, x + 1], [x + 2, x + 2, x + 2]$等价那么假使最优解里面有$k[x, x + 1, x + 2]$，我们一定能换成$(k\,\mathrm{mod}\,3)[x, x + 1, x + 2]$和$(k - k\,\mathrm{mod}\,3)([x, x, x], [x + 1, x + 1, x + 1], [x + 2, x + 2, x + 2])$因此这样换过之后，最优解里面肯定没有$k[x, x + 1, x + 2], k &gt; 2$那么我们可以设计DP状态了哇设$f(i, j, k)$表示选择到$i$这个数且$j[i - 2, i - 1, i], k[i - 1, i, i + 1]$往后推就行了哇$m$要$+1$哇！！！ Code1234567891011121314151617181920212223int main()&#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) read(x), ++a[x]; ++m; for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt; 3; ++j) for (int k = 0; k &lt; 3; ++k) &#123; int p = a[i] - j - k, q = a[i + 1] - k, r = a[i + 2]; for (int l = 0; l &lt; 3; ++l) &#123; if (p &gt;= l &amp;&amp; q &gt;= l &amp;&amp; r &gt;= l) f[i + 1][k][l] = std::max(f[i + 1][k][l], f[i][j][k] + l + (p - l) / 3); &#125; &#125; for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt; 3; ++j) for (int k = 0; k &lt; 3; ++k) ans = std::max(ans, f[i][j][k]); std::cout &lt;&lt; ans &lt;&lt; std::endl;&#125; E - Magic StonesAnalysis很聪明的做法哇构造差分数组$\lbrace d_{n - 1}\rbrace : d_i = c_{i + 1} - c_i$我们看看操作一次后$d$数组会怎么样，假设synchronize了$c_j$，也就是$c_j’ = c_{j + 1} + c_{j - 1} - c_j$$d_j’ = c_{j + 1} - c_j’ = c_{j + 1} - c_{j + 1} - c_{j - 1} + c_j = c_j - c_{j - 1} = d_{j - 1}$$d_{j - 1}’ = c_j’ - c_{j - 1} = c_{j + 1} + c_{j - 1} - c_j - c_{j - 1} = c_{j + 1} - c_j = d_j$唔…就是交换了$d_j, d_{j - 1}$哇那么直接比较$\lbrace c_n\rbrace$的差分数组和$\lbrace t_n\rbrace$是否元素相同就行了哇 Code1234567891011121314151617181920212223int main()&#123; read(n); for (int i = 1; i &lt;= n; ++i) read(s[i]); for (int i = 1; i &lt;= n; ++i) read(t[i]); for (int i = 1; i &lt; n; ++i) ds[i] = s[i + 1] - s[i], dt[i] = t[i + 1] - t[i]; if (s[1] != t[1] || s[n] != t[n]) std::cout &lt;&lt; "No" &lt;&lt; std::endl; else &#123; std::sort(ds + 1, ds + n), std::sort(dt + 1, dt + n); for (int i = 2; i &lt; n; ++i) if (ds[i] != dt[i]) &#123; std::cout &lt;&lt; "No" &lt;&lt; std::endl; return 0; &#125; std::cout &lt;&lt; "Yes" &lt;&lt; std::endl; &#125;&#125; F - Nearest LeafAnalysis : Brute给每个叶节点重标号，给每个节点建一棵线段树哇MLE on test 8代码就不放了 Analysis : Standard考虑离线哇把Segment-Tree的Code Style彻底颠覆了C++ 11和C++ 17的新语法真心好评哇 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;const long long INF = 1152921504606846976;int n, q;int p[500010], w[500010];class Node&#123;public: long long val = 0, tag = 0; void apply(int l, int r, long long v) &#123; val += v, tag += v; &#125;&#125;;struct SegmentTree&#123; std::vector &lt;Node&gt; tree; int n; Node unite(const Node&amp; l, const Node&amp; r) &#123; Node res; res.val = std::min(l.val, r.val); return res; &#125; SegmentTree(int n) : n(n) &#123; tree.resize(n &lt;&lt; 2); &#125; void pull(int root) &#123; tree[root] = unite(tree[root &lt;&lt; 1], tree[root &lt;&lt; 1 | 1]); &#125; void push(int l, int r, int root) &#123; int mid = l + r &gt;&gt; 1; if (tree[root].tag) tree[root &lt;&lt; 1].apply(l, mid, tree[root].tag), tree[root &lt;&lt; 1 | 1].apply(mid + 1, r, tree[root].tag), tree[root].tag = 0; &#125; void build(int l, int r, int root, const std::vector &lt;long long&gt;&amp; v) &#123; if (l == r) tree[root].apply(l, r, v[l]); else &#123; int mid = l + r &gt;&gt; 1; build(l, mid, root &lt;&lt; 1, v); build(mid + 1, r, root &lt;&lt; 1 | 1, v); pull(root); &#125; &#125; Node query(int l, int r, int root, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[root]; else &#123; int mid = l + r &gt;&gt; 1; push(l, r, root); if (qr &lt;= mid) return query(l, mid, root &lt;&lt; 1, ql, qr); else if (ql &gt; mid) return query(mid + 1, r, root &lt;&lt; 1 | 1, ql, qr); else return unite(query(l, mid, root &lt;&lt; 1, ql, qr), query(mid + 1, r, root &lt;&lt; 1 | 1, ql, qr)); &#125; &#125; void modify(int l, int r, int root, int ql, int qr, const long long&amp; v) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) tree[root].apply(l, r, v); else &#123; int mid = l + r &gt;&gt; 1; push(l, r, root); if (ql &lt;= mid) modify(l, mid, root &lt;&lt; 1, ql, qr, v); if (qr &gt; mid) modify(mid + 1, r, root &lt;&lt; 1 | 1, ql, qr, v); pull(root); &#125; &#125;&#125;;int main()&#123; std::ios::sync_with_stdio(0); std::cin &gt;&gt; n &gt;&gt; q; std::vector &lt;int&gt; p(n), w(n); std::vector &lt;long long&gt; dist(n); std::vector &lt;bool&gt; leaf(n, 1); std::vector &lt;std::vector &lt;std::pair&lt;int, int&gt; &gt; &gt; adj(n); for (int i = 1; i &lt; n; ++i) std::cin &gt;&gt; p[i] &gt;&gt; w[i], --p[i], leaf[p[i]] = 0, dist[i] = dist[p[i]] + w[i], adj[p[i]].emplace_back(i, w[i]); for (int i = 0; i &lt; n; ++i) if (!leaf[i]) dist[i] = INF; SegmentTree T(n); T.build(0, n - 1, 1, dist); std::vector &lt;std::vector &lt;std::tuple&lt;int, int, int&gt; &gt; &gt; asks(n); std::vector &lt;long long&gt; ans(q); ans.resize(q); for (int i = 0; i &lt; q; ++i) &#123; int v, l, r; std::cin &gt;&gt; v &gt;&gt; l &gt;&gt; r; --v, --l, --r; asks[v].emplace_back(l, r, i); &#125; std::vector &lt;int&gt; low(n), hig(n); std::function &lt;void(int)&gt; dfs = [&amp;](int x) &#123; low[x] = hig[x] = x; for (auto p : adj[x]) &#123; int y = p.first; dfs(y), low[x] = std::min(low[x], low[y]), hig[x] = std::max(hig[x], hig[y]); &#125; &#125;; dfs(0); long long cur = 0; std::function&lt;void(int)&gt; solve = [&amp;](int x) &#123; for (auto p : asks[x]) ans[std::get&lt;2&gt;(p)] = T.query(0, n - 1, 1, std::get&lt;0&gt;(p), std::get&lt;1&gt;(p)).val + cur; for (auto p : adj[x]) &#123; int y = p.first; cur += p.second; T.modify(0, n - 1, 1, low[y], hig[y], -2 * p.second); solve(y); T.modify(0, n - 1, 1, low[y], hig[y], 2 * p.second); cur -= p.second; &#125; &#125;; solve(0); for (int i = 0; i &lt; q; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; "\n"; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DP</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder Beginner Contest 117」]]></title>
    <url>%2F2019%2F02%2F03%2FABC-117%2F</url>
    <content type="text"><![CDATA[Digression远坂凛生日快乐！到现在仍然对中日时差表示困惑，网站上写的是北京时间还是东京时间我也弄不清…… TasksA - Entrance ExaminationAnalysis输出$T/X$即可 Code1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstdio&gt;char ch;template &lt;typename T&gt;void read(T&amp; x)&#123; x = 0; ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;double n, m;int main()&#123; read(n), read(m); printf("%.10f\n", n / m); return 0;&#125; B - PolygonAnalysis根据给出的Theorem，最长边$l_i\leq \sum l - l_i$，故$l_j&lt;\sum l - l_j(j\ne i)$ Code某些函数略12345678910111213141516int n, s, ans = 1;int a[1000010];int main()&#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]), s += a[i]; for (int i = 1; i &lt;= n; ++i) ans &amp;= (a[i] &lt; s - a[i]); if (ans) printf("Yes\n"); else printf("No\n"); return 0;&#125; C - StreamlineAnalysis从C题开始比较有意思首先我们一定会把这$n$个pieces放在某一个$X_i$上显然当$n\geq m$时，答案为$0$接下来我们考虑放置一个piece对于答案的影响：放置一个piece必定会使我们少走一段$X_i - X_{i - 1}$的距离（即某两个相邻coordinates中间那段距离就不用再走了）故考虑贪心，将所有$X_i - X_{i - 1}$排序 Code这里特意把read()放出来，因为坐标可能为负123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;char ch;template &lt;typename T&gt;void read(T&amp; x)&#123; x = 0; ch = getchar(); int minus = 0; for (; !isdigit(ch); minus |= (ch == '-'), ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar()); if (minus) x = -x;&#125;int n, m, ans, s;int a[1000010], d[1000010];int main()&#123; read(n), read(m); for (int i = 1; i &lt;= m; ++i) read(a[i]); if (n &gt;= m) &#123; printf("0\n"); return 0; &#125; std::sort(a + 1, a + m + 1); for (int i = 1; i &lt; m; ++i) d[i] = a[i + 1] - a[i], s += d[i]; std::sort(d + 1, d + m); for (int i = m - 1, cnt = 1; i &amp;&amp; cnt &lt; n; --i, ++cnt) ans += d[i]; printf("%d\n", s - ans); return 0;&#125; D - XXORAnalysis先将$\lbrace A_n\rbrace$全部转二进制，位数不足补前导零，设最大位数为$l$，$x$同题意，$A_{ij}$表示第$i$个数二进制表示的第$j$位（$0$或$1$），从$0$位开始std::bitset大法吼啊然后考虑异或运算的性质：对于二进制的某一位，异或$0$不变，异或$1$取反那么：若改变$A$中全部元素的第$j$位比不改变更优，则$x$的第$j$位为$1$，否则为$0$显然改变更优的充要条件为$\sum{A_{ij}} &lt; n - \sum{A_{ij}}$又：若确定$x$的第$j$位为$1$，则$x$会增加$2 ^ j$，同时答案增加$2^j\cdot(n-2\cdot\sum A_{ij})$也就是说：我们有至多$\log_2k$个选择，每个选择会贡献$2^j\cdot(n-2\cdot\sum A_{ij})$，并使$x$增加$2^j$这不是01背包吗！！？然而$K$过大，否决由于$\log_2k$不大，考虑暴搜TLE……一看只T了3个点，剪枝！设当前搜到第$dep$个选择，总贡献为$val$，总增量为$cost$考虑到$\sum_{i = 1} ^ j 2 ^ i= 2 ^ {j + 1} - 1$，我们发现若当前搜到的$val$加上$2^{dep + 1}$仍不如当前最优解的话可直接剪去若搜索顺序为$0$到$l$则剪枝无法进行，故顺序应为$l$到$0$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061long long n, k, rec, s, ans, szeK;long long a[100010], tot[100010], cst[100010], f[1010010];std::bitset &lt;110&gt; b[100010];void dfs(int dep, long long val, long long cost)&#123; if (dep &lt; 0) &#123; ans = std::max(ans, val); return; &#125; if (val + f[dep + 1] &lt; ans) return; if (cst[dep] &amp;&amp; cost + cst[dep] &lt;= k) dfs(dep - 1, val + tot[dep], cost + cst[dep]); dfs(dep - 1, val, cost);&#125;int getSize(long long x)&#123; int ret = 0; while (x) ++ret, x &gt;&gt;= 1; return ret;&#125;int main()&#123; f[0] = 1; for (int i = 1; i &lt;= 60; ++i) f[i] = f[i - 1] * 2; read(n), read(k); for (int i = 1; i &lt;= n; ++i) read(a[i]), s += a[i]; std::sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) b[i] = a[i]; for (int i = b[n].size() - 1; ~i; --i) if (b[n][i]) &#123; rec = i; break; &#125; if (getSize(k) - 1 &gt; rec) rec = getSize(k) - 1; for (long long i = rec; ~i; --i) &#123; for (int j = 1; j &lt;= n; ++j) tot[i] += b[j][i]; &#125; for (int i = 0; i &lt;= rec; ++i) &#123; if (tot[i] &lt; n - tot[i]) tot[i] = f[i] * (n - 2 * tot[i]), cst[i] = f[i]; else tot[i] = 0; &#125; dfs(rec, 0, 0); std::cout &lt;&lt; s + ans &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2010」 古代猪文 - CRT + Lucas]]></title>
    <url>%2F2018%2F12%2F04%2FSDOI2010-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87%2F</url>
    <content type="text"><![CDATA[Link洛谷 2480 Solution题意即求$$G ^ {\sum_{d | n}C_n^d}\,\mathrm{mod}\,999911659$$ Step 1推广费马小定理可得$$G^{\sum_{d | n}C_n^d\,\mathrm{mod}\,999911659} = G^{\sum_{d | n}C_n^d\,\mathrm{mod}\,999911658}\,\mathrm{mod}\,999911659$$ Step 2快速幂很好办，那么唯一的难点就是指数——模数不为质数，不能直接用Lucas Theorem再看一眼我们要求的指数$$\sum_{d | n}C_n^d\,\mathrm{mod}\,999911658$$对于$d$我们采用$O(\sqrt{n})$的方式暴力枚举，然后呢……似乎我们已经走入穷途末路了…… Step 3方便起见令$s = \sum_{d | n}C_n^d, x = s \,\mathrm{mod}\,999911659$分解$999911658 = 2 \cdot 3 \cdot 4679 \cdot 35617$令$a_1 = s\,\mathrm{mod}\, 2, a_2 = s\,\mathrm{mod}\, 3, a_3 = s\,\mathrm{mod}\, 4679, a_4 = s\,\mathrm{mod}\, 35617$我们可以得到\begin{cases}x \equiv a_1 (\mathrm{mod}\, 2)\\x \equiv a_2 (\mathrm{mod}\, 3)\\x \equiv a_3 (\mathrm{mod}\, 4679)\\x \equiv a_3 (\mathrm{mod}\, 35617)\end{cases}求解出$x$即为指数 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;#define MOD 999911659template &lt;class T&gt;void Read(T &amp;x)&#123; x = 0; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;long long n, g;long long frac[50010];void init(long long p)&#123; frac[0] = 1; for (register long long i = 1; i &lt;= p; ++i) frac[i] = frac[i - 1] * i % p;&#125;inline long long fastpow(long long base, long long index, long long p)&#123; register long long ret = 1; while (index) &#123; if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; &#125; return ret;&#125;inline long long inv(long long x, long long p)&#123; return fastpow(x, p - 2, p);&#125;inline long long C(long long x, long long y, long long p)&#123; if (x &lt; y) return 0; else return frac[x] * inv(frac[y], p) * inv(frac[x - y], p) % p;&#125;inline long long Lucas(long long x, long long y, long long p)&#123; if (x &lt; y) return 0; else if (x &lt; p &amp;&amp; y &lt; p) return C(x, y, p); else return Lucas(x % p, y % p, p) * Lucas(x / p, y / p, p) % p;&#125;inline long long CRT(vector &lt;long long&gt; &amp;a, vector &lt;long long&gt; &amp;b)&#123; register long long ret = 0, m = MOD - 1; for (register int i = 0; i &lt; 4; ++i) ret = (ret + a[i] * (m / b[i]) % m * inv(m / b[i], b[i]) % m) % m; return (ret % m + m) % m;&#125;inline long long sum(long long p)&#123; vector &lt;long long&gt; a(4), b(4); b[0] = 2, b[1] = 3, b[2] = 4679, b[3] = 35617; for (register int j = 0; j &lt; 4; ++j) &#123; init(b[j]); for (register int i = 1; i * i &lt;= n; ++i) &#123; if (!(n % i)) &#123; a[j] = (a[j] + Lucas(n, i, b[j])) % b[j]; if (i * i != n) a[j] = (a[j] + Lucas(n, n / i, b[j])) % b[j]; &#125; &#125; &#125; return CRT(a, b) % p;&#125;int main()&#123; Read(n), Read(g); if (!(g % MOD)) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; fastpow(g, sum(MOD), MOD)&lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2013」 随机数生成器 - BSGS]]></title>
    <url>%2F2018%2F12%2F04%2FSDOI2013-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Link洛谷 3306 Solution大力推式子 \begin{align}X_{i + 1} &amp;\equiv aX_i + b(\mathrm{mod}\,p)\notag\\X_{i + 1} + \frac{b}{a} &amp;\equiv aX_i + b + \frac{b}{a}(\mathrm{mod}\,p)\notag\\aX_{i + 1} + b &amp;\equiv a^2X_i + ab + b(\mathrm{mod}\,p)\notag\\X_{i + 2} &amp;\equiv a^2X_i + ab + b(\mathrm{mod}\,p)\notag\\\end{align} 那么我们得到 \begin{align}X_2 &amp;\equiv aX_1 + b(\mathrm{mod}\,p)\notag\\X_3 &amp;\equiv a ^ 2X_1 + ab + b(\mathrm{mod}\,p)\notag\\X_4 &amp;\equiv a ^ 3X_1 + a ^ 2b + ab + b(\mathrm{mod}\,p)\notag\\\dots\notag\\X_i &amp;\equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)\notag\\\end{align} 也就是我们要判断如下方程是否有整数解，若有则求解 $$t \equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)$$ 继续化化化 \begin{align}t &amp;\equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)\notag\\t &amp;\equiv a ^ {i - 1}X_1 + b\frac{1 - a ^ {i - 1}}{1 - a}(\mathrm{mod}\,p)\notag\\t &amp;\equiv a ^ {i - 1}X_1 + \frac{b}{1 - a} - \frac{b}{1 - a} \cdot a^{i - 1}(\mathrm{mod}\,p)\notag\\t &amp;\equiv a ^ {i - 1}(X_1 - \frac{b}{1 - a}) + \frac{b}{1 - a}(\mathrm{mod}\,p)\notag\\a ^ {i - 1} &amp;\equiv \frac{t - \frac{b}{1 - a}}{X_1 - \frac{b}{1 - a}}(\mathrm{mod}\,p)\notag\\\end{align} 大功告成，用BSGS求解出$i - 1$的值，由于$t$是第$i$项，答案加一即可 Detail 1对于$X_1 = t$时，直接输出$1$ Detail 2对于$a = 0$时，$X_i = b$ Detail 3对于$a = 1$时，有$X_i \equiv X_1 + b(i - 1)(\mathrm{mod}\,p)$那么求解$t - X_1 \equiv b(i - 1)(\mathrm{mod}\,p)$的系数$i - 1$即可注意当答案就是$p$的时候不要再模$p$了 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;template &lt;class I&gt;inline void Read(I &amp;x)&#123; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());&#125;long long NUMOFCASES, a, b, p, x, t, X, Y;long long fastpow(long long base, int index, int MOD)&#123; register long long ret = 1; while (index) &#123; if (index &amp; 1) ret = ret * base % MOD; base = base * base % MOD; index &gt;&gt;= 1; &#125; return ret;&#125;long long gcd(long long a, long long b)&#123; return b ? gcd(b, a % b) : a;&#125;long long inv(long long x, int MOD)&#123; return fastpow(x, MOD - 2, MOD);&#125;long long bsgs(long long a, long long b, int MOD)&#123; a %= MOD, b %= MOD; std::map&lt;long long, long long&gt; map; register long long m = ceil(sqrt(MOD)), t = 1; for (register int i = 0; i &lt; m; ++i) &#123; if (!map.count(t)) map[t] = i; t = t * a % MOD; &#125; register long long k = inv(t, MOD), w = b; for (int i = 0; i &lt; m; ++i) &#123; if (map.count(w)) return i * m + map[w]; w = w * k % MOD; &#125; return -1;&#125;int main()&#123; Read(NUMOFCASES); for (; NUMOFCASES; --NUMOFCASES) &#123; Read(p), Read(a), Read(b), Read(x), Read(t); if (x == t) cout &lt;&lt; 1 &lt;&lt; endl; else if (a == 1) &#123; t = (t - x + p) % p; if (t % gcd(b, p)) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; (t * inv(b, p) + 1 == p ? t * inv(b, p) + 1 : (t * inv(b, p) + 1) % p) &lt;&lt; endl; &#125; else if (a == 0) &#123; if (b == t) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; long long ans = bsgs(a, ((t - b * inv(1 - a, p)) % p + p) % p * inv(((x - b * inv(1 - a, p)) % p + p) % p , p), p) % p; if (ans == -1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans + 1 &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2009」 猜数字]]></title>
    <url>%2F2018%2F11%2F16%2FTJOI2009-%E7%8C%9C%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Link洛谷 3868 Solution经典的Chinese Remainder Theorem例题然而我并不是被CRT卡的，细节较多考虑将方程组变形\begin{cases}x\equiv a_1(\mathrm{mod}\,b_1)\\x\equiv a_2(\mathrm{mod}\,b_2)\\\dots\\x\equiv a_k(\mathrm{mod}\,b_k)\end{cases}直接用CRT实现即可 Detail 1乘法会爆long long，须用快速龟速乘 Detail 2快读注意判负数 Detail 3$a_i$可能为负，为了方便实现，在使用时转为模$b_i$等价类的最小正元素 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;inline void Read(long long &amp;x)&#123; x = 0; register char ch = getchar(); register int flag = 0; while (!isdigit(ch)) flag = (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if (flag) x = -x;&#125;long long mul(long long a, long long b, long long MOD)&#123; long long ret = 0; while (a) &#123; if (a &amp; 1) (ret += b) %= MOD; (b += b) %= MOD; a &gt;&gt;= 1; &#125; return ret;&#125;long long k, s = 1, n;long long a[110], b[110];void exgcd(long long a, long long b, long long &amp;x, long long &amp;y)&#123; if (!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x;&#125;int main()&#123; Read(k); for (int i = 1; i &lt;= k; ++i) Read(a[i]); for (int i = 1; i &lt;= k; ++i) Read(b[i]), s *= b[i]; for (int i = 1; i &lt;= k; ++i) &#123; register long long m = s / b[i], x, y; exgcd(m, b[i], x, y); (n += mul(mul((a[i] % b[i] + b[i]) % b[i], m, s), x, s)) %= s; &#125; cout &lt;&lt; (n + s) % s &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2017初中组」 alter]]></title>
    <url>%2F2018%2F10%2F27%2FAHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84-alter%2F</url>
    <content type="text"><![CDATA[Link洛谷 3718 Solution由于对于一个答案我们很容易验证是否可行，考虑二分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int n, k, t;string st;int check(int x)&#123; int len = 1, cnt = 0; for (int i = 1; i &lt; st.length(); ++i) &#123; if (st[i] == st[i - 1]) ++len; else len = 1; if (len &gt; x) &#123; ++cnt, len = 0; if (x &lt; 2) st[i] = st[i] == 'N' ? 'F' : 'N', ++len; &#125; &#125; if (cnt &lt;= k) return 1; else return 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; st; int l = 1, r = n; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2006」 保安站岗]]></title>
    <url>%2F2018%2F10%2F26%2FSDOI2006-%E4%BF%9D%E5%AE%89%E7%AB%99%E5%B2%97%2F</url>
    <content type="text"><![CDATA[Link洛谷 2458 Solution对于某个节点，其被覆盖的情况有三种： 被其父节点覆盖 被自己覆盖 被其子节点覆盖 那么我们可按以下方式转移：设$f(0/1/2,i)$表示节点$i$被父节点/本身/子节点覆盖且其子树全被覆盖的最小代价，设$j$为其子节点，易得方程$$f(0,i)=\sum\min\lbrace f(1,j),f(2,j)\rbrace$$$$f(1,i)=\sum\min\lbrace f(0,j),f(1,j),f(2,j)\rbrace$$$$f(2,i)=f(1,k)+\sum_{j\neq k}\min\lbrace f(1,j),f(2,j)\rbrace,f(1,k)=\min\lbrace f(1,j)\rbrace$$ $f(2,i)$转移的细节依然令$j$为$i$的一个子节点思路即取一个最优的子节点强制性的使用它的$f(1,j)$来转移，其余的取最优方案有个细节千万注意：并非$f(1,j)$最小的$j$为最优，反例即为该点的$f(2,j)$远小于该点的$f(1,j)$值也就是我们强制选择的点就是$f(1,j)-f(2,j)$最小的点以$x$记录上述值，$y$记录是否选过$f(1,j)&lt;f(2,j)$的点（$j$本身覆盖优于$j$的子节点覆盖）若$y=0$，那么我们必须加上一个最小的$f(1,j)-f(2,j)$，否则代表我们已经选过最优的这种点了，不作改动 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, numi, ordi, soni;int w[1510], f[3][1510];vector &lt;int&gt; tree[1510];void dfs(int cur, int fr)&#123; int x = 0x7f7f7f7f, y = 0; f[1][cur] = w[cur]; for (int i = 0; i &lt; tree[cur].size(); ++i) &#123; int to = tree[cur][i]; if (to != fr) &#123; dfs(to, cur), f[0][cur] += min(f[1][to], f[2][to]), f[1][cur] += min(f[0][to], min(f[1][to], f[2][to])); if (f[1][to] &lt; f[2][to]) ++y; else x = min(x, f[1][to] - f[2][to]); f[2][cur] += min(f[1][to], f[2][to]); &#125; &#125; if (!y) f[2][cur] += x;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; ordi &gt;&gt; w[ordi] &gt;&gt; numi; for (; numi; --numi) cin &gt;&gt; soni, tree[ordi].push_back(soni), tree[soni].push_back(ordi); &#125; dfs(1, 0); cout &lt;&lt; min(f[1][1], f[2][1]) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HEOI2015」 兔子与樱花]]></title>
    <url>%2F2018%2F10%2F23%2FHEOI2015-%E5%85%94%E5%AD%90%E4%B8%8E%E6%A8%B1%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[Link洛谷 4107 Solution假设当前节点为$i$，则其某个子节点$j$被删除且不违背最大载重的话一定满足$$c_i+c_j-1\leq m$$而且只需满足这个条件即可那么我们为了删除尽可能多的点，易想到贪心解决 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, m, tmp, son, ans;int c[2000010], k[2000010];vector &lt;int&gt; tree[2000010];bool cmp(const int &amp;x, const int &amp;y)&#123; return c[x] &lt; c[y];&#125;void dfs(int root)&#123; int sze = tree[root].size(); if (!sze) return; for (int i = 0; i &lt; sze; ++i) dfs(tree[root][i]); sort(tree[root].begin(), tree[root].end(), cmp); for (register int i = 0; i &lt; sze; ++i) &#123; if (c[root] + c[tree[root][i]] - 1 &lt;= m) c[root] += c[tree[root][i]] - 1, ++ans; else break; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; c[i]; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; tmp; c[i] += tmp; while (tmp--) cin &gt;&gt; son, tree[i].push_back(son); &#125; dfs(0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Extra洛谷提交时记得开O2]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2011」 计算器]]></title>
    <url>%2F2018%2F10%2F04%2FSDOI2011-%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Link洛谷 2485 Solution1裸的快速幂取模 2令$d=\gcd(a,n)$ 一个推论当且仅当$d|b$时，方程$ax\equiv b(\mathrm{mod}\,n)$对于未知量$x$有解 一个定理假设对某些整数$x’$和$y’$，有$d=ax’+ny’$。若$d|b$，则方程$ax\equiv b(\mathrm{mod}\,n)$的有一个解的值为$x_0$，这里$$x_0=x’(b/d)\,\mathrm{mod}\,n$$ 证明根据$x’$的性质，即：$$ax\equiv d(\mathrm{mod}\,n)$$可得：\begin{align}ax_0&amp;\equiv ax’(b/d)(\mathrm{mod}\,n)\notag\\&amp;\equiv d(b/d)(\mathrm{mod}\,n)\notag\\&amp;\equiv b(\mathrm{mod}\,n)\notag\end{align}因此$x_0$是方程$ax\equiv b(\mathrm{mod}\,n)$的一个解 解决那么对于询问2，用扩欧求方程$ax’+ny’=d$即可注意根据上面的一个推论，当$d$不整除$b$时该方程无解 3我们引入一个概念—— 离散对数若$g$是$\mathrm{Z}_n^*$的一个原根且$a$是$\mathrm{Z}_n^*$中的任意元素，则存在一个$z$，使得$g^z\equiv a(\mathrm{mod}\,n)$，则将$z$称为对模$n$到基$g$上的$a$的一个离散对数或指数说人话，也就是对于给定的$a,b,p$，存在一个$x$，使得$$a^x\equiv b(\mathrm{mod}\,p)$$则称$x$为$b$在模$p$意义下以$a$为底的离散对数 很显然本题就是让我们求$y$的离散对数，常用方法叫做BSGS——Baby Step-Giant Step BSGS拿出我们要解的关于$x$的方程：$$a^x\equiv b(\mathrm{mod}\,p)$$令$m=\lceil \sqrt{p}\rceil$。根据费马小定理，有$a^{p-1}\equiv 1(\mathrm{mod}\,p)$故若方程有解，则必存在一个$0\leq x&lt;p-1$根据除法的定义，令$x=im+j$，方程可化为： \begin{align}a^x&amp;\equiv b(\mathrm{mod}\,p)\notag\\a^{im+j}&amp;\equiv b(\mathrm{mod}\,p)\notag\\a^j&amp;\equiv b\cdot a^{-im}(\mathrm{mod}\,p)\notag\\a^j&amp;\equiv b\cdot (a^{-m})^i(\mathrm{mod}\,p)\notag\end{align}得到这玩意，我们就只需找到一组$i,j$使得最后一个式子成立即可那么我们先枚举$j$，递推出左边$a^j\,\mathrm{mod}\,p$的所有取值，并将其按照$(a^j\,\mathrm{mod}\,p)\mapsto j$的映射关系插入到哈希表中之后求出$a^m\,\mathrm{mod}\,p$的乘法逆元，枚举$i$，递推出所有的$b\cdot(a^{-m})^i$，每得到一个值后在哈希表内查找该值。若存在，取出对应的$j$，$x=im+j$即为一个解 Extra注意取模的时候可能有负数，并且应该先模$p$，具体见代码注释的那一行，卡了我35分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;long long T, K, y, z, p, gcd, X, Y;map &lt;long long, long long&gt; mp;inline long long fastpow(long long base, long long index)&#123; long long ret = 1; while (index) &#123; if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; &#125; return ret;&#125;inline void exgcd(long long a, long long b, long long &amp;d, long long &amp;x, long long &amp;y)&#123; if (!b) d = a, x = 1, y = 0; else exgcd(b, a % b, d, y, x), y -= a / b * x;&#125;inline long long inv(long long x)&#123; return fastpow(x, p - 2);&#125;inline long long bsgs(long long a, long long b)&#123; if (!a) return b ? -1 : 1; mp.clear(); long long m = ceil(sqrt(p)), t = 1; for (long long i = 0; i &lt; m; i++) &#123; if (!mp.count(t)) mp[t] = i; t = t * a % p; &#125; long long k = inv(t), w = b; for (long long i = 0; i &lt; m; i++) &#123; if (mp.count(w)) return i * m + mp[w]; w = w * k % p; &#125; return -1;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; T &gt;&gt; K; while (T--) &#123; cin &gt;&gt; y &gt;&gt; z &gt;&gt; p; if (K == 1) &#123; cout &lt;&lt; fastpow(y, z) &lt;&lt; endl; &#125; else if (K == 2) &#123; exgcd(y, p, gcd, X, Y); if (z % gcd) cout &lt;&lt; "Orz, I cannot find x!" &lt;&lt; endl; else &#123; cout &lt;&lt; (X * z / gcd % p + p) % p &lt;&lt; endl;//Important &#125; &#125; else &#123; long long ans = bsgs(y % p, z % p); if (ans == -1) cout &lt;&lt; "Orz, I cannot find x!" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 后记BSGS部分参考Menci的博客]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组修改与查询]]></title>
    <url>%2F2018%2F09%2F23%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[我们将修改与查询问题归为四大类 单点修改，单点查询这就不用做了，无脑开数组或map 单点修改，区间查询这里的树状数组用法较基础，模板题目：洛谷 3374 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, x, y;long long s[1000010];inline void update(int pos, int add)&#123; while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;&#125;inline long long query(int pos)&#123; long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t , update(i, t); while (q--) &#123; cin &gt;&gt; t &gt;&gt; x &gt;&gt; y; if (t == 1) update(x, y); else cout &lt;&lt; query(y) - query(x - 1) &lt;&lt; endl; &#125; return 0;&#125; 区间修改，单点查询我们学习一个叫做差分的神奇东西简单来说，对于原数组$a,a_0=0$，定义差分数组$d$，其构造法则为：$$d_i=a_i-a_{i-1}$$可以发现：$$a_i=\sum_{j=1}^id_j$$假设我们给区间$[l,r]$加上$k$，那么我们会发现$d_l$变大了$k$，$d_{r+1}$变小了$k$，其余的不变因此我们只需维护$d$数组的前缀和即可，树状数组可以很方便的维护依然送上模板题目：洛谷 3368 Code实现时要注意我们维护的是差分数组，因此在对树状数组的初始化时要注意update的元素1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, l, r, x, lst;long long s[1000010];void update(int pos, int add)&#123; while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;&#125;long long query(int pos)&#123; long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; while (q--) &#123; cin &gt;&gt; t; if (t == 1) cin &gt;&gt; l &gt;&gt; r &gt;&gt; x, update(l, x), update(r + 1, -x); else cin &gt;&gt; x, cout &lt;&lt; query(x) &lt;&lt; endl; &#125; return 0;&#125; 区间修改，区间查询我们依然要用到差分，定义与上面的相同当我们查询区间$[l,r]$时，前缀和思想是非常清晰的：$$\sum_{i=l}^ra_i=\sum_{i=1}^ra_i-\sum_{i=1}^{l-1}a_i$$对于一个单独的$\sum_{i=1}^xa_i$，我们有：$$\sum_{i=1}^xa_i=\sum_{i=1}^x\sum_{j=1}^id_j=\sum_{i=1}^x(x-i+1)d_i$$再将其进行一个神奇的转换：$$\sum_{i=1}^x(x-i+1)d_i=\sum_{i=1}^x(x+1)d_i-\sum_{i=1}^xid_i=(x+1)\sum_{i=1}^xd_i-\sum_{i=1}^xid_i$$所以我们可以维护两个树状数组，分别维护$d_i$和$id_i$即可每个询问区间的答案即是：$$\sum_{i=1}^ra_i-\sum_{i=1}^{l-1}a_i=(r+1)\sum_{i=1}^rd_i-\sum_{i=1}^rid_i-l\sum_{i=1}^{l-1}d_i+\sum_{i=1}^{l-1}id_i$$ Code维护时注意，第二个树状数组维护的是$id_i$，这意味着第一个树状数组update操作变化的值是$k$，那么第二个树状数组update操作变化的值是$ki$模板：POJ 3468千万注意数据规模可能超int，因此我选择整数运算和long long无异但范围比long long大的long double（其实没必要） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#pragma warning(disable:4996)int n, q, t, a, b, c, lst;char ch;long double s1[100010];long double s2[100010];void update(int pos, long long add)&#123; int tpos = pos; while (pos &lt;= n) s1[pos] += add, s2[pos] += tpos * add, pos += pos &amp; -pos;&#125;long long query(int pos)&#123; long long sum = 0, tpos = pos; while (pos) sum += (tpos + 1)*s1[pos] - s2[pos], pos -= pos &amp; -pos; return sum;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; for (int i = 1; i &lt;= q; i++) &#123; cin &gt;&gt; ch; if (ch == 'C') cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, update(a, c), update(b + 1, -c); else cin &gt;&gt; a &gt;&gt; b, cout &lt;&lt; query(b) - query(a - 1) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GCJ R1A 2008」 C - numbers]]></title>
    <url>%2F2018%2F09%2F02%2FGCJ-R1A-2008-C%2F</url>
    <content type="text"><![CDATA[题目链接GCJ R1A 2008 C总觉得Code Jam都需要科学方式访问是不是有些太过了 题解拿到手首先肯定不能暴力，于是我们考虑数学方法 分析对于这个式子：$(3+\sqrt{5})^n$，一眼想到二项式定理，将其展开得：$$(3+\sqrt{5})^n=C_n^03^n\sqrt{5}^0+C_n^13^{n-1}\sqrt{5}^1+\dots+C_n^{n-1}3^1\sqrt{5}^{n-1}+C_n^n3^0\sqrt{5}^n$$不难发现若幂次为偶数，则$\sqrt{5}$也会变成整数，那么我们可以将上面的式子写成如下形式：$$(3+\sqrt{5})^n=f(n)+g(n)\sqrt{5}$$$f(n)$即为展开式中所有运算结果为整数的部分的和仍然没法解决，我们再考虑另一个式子：$$(3-\sqrt{5})^n=C_n^03^n\sqrt{5}^0-C_n^13^{n-1}\sqrt{5}^1+\dots+(-1)^{n-1}C_n^{n-1}3^1\sqrt{5}^{n-1}+(-1)^nC_n^n3^0\sqrt{5}^n$$同理，可写成：$$(3-\sqrt{5})^n=f(n)-g(n)\sqrt{5}$$二式相加，得：$$(3+\sqrt{5})^n+(3-\sqrt{5})^n=2f(n)$$所以$$(3+\sqrt{5})^n=2f(n)-(3-\sqrt{5})^n$$考虑到$$0&lt;(3-\sqrt{5})^n&lt;1$$而我们要求的是整数部分，那么完全可以写成$$\lfloor(3+\sqrt{5})^n\rfloor=2f(n)-1$$ 求解$f$问题是这个$f$怎么求考虑以下递推式： \begin{align}(3+\sqrt{5})^{n+1}&amp;=(3+\sqrt{5})(3+\sqrt{5})^n\notag\\&amp;=(3+\sqrt{5})(f(n)+g(n)\sqrt{5})\notag\\&amp;=3f(n)+3\sqrt{5}g(n)+\sqrt{5}f(n)+5g(n)\notag\end{align}所以\begin{align}f(n+1)=3f(n)+5g(n)\notag\\g(n+1)=f(n)+3g(n)\notag\end{align}由此我们可以用矩阵快速幂解决 矩阵原始矩阵：\begin{align}\begin{bmatrix}f(0)\\g(0)\notag\end{bmatrix}=\begin{bmatrix}1\\0\end{bmatrix}\end{align}递推的矩阵：\begin{bmatrix}3&amp;5\\1&amp;3\end{bmatrix}至此问题解决 代码printf()格式化真心强大1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#pragma warning(disable:4996)using namespace std;int T, n;struct Mat&#123; int r, c; int matrix[10][10];&#125;;Mat basmat;void init()&#123; basmat.c = basmat.r = 2; basmat.matrix[0][0] = 3, basmat.matrix[0][1] = 5; basmat.matrix[1][0] = 1, basmat.matrix[1][1] = 3;&#125;Mat mul(Mat mat1, Mat mat2)&#123; Mat tmat; memset(tmat.matrix, 0, sizeof tmat.matrix); tmat.r = mat1.r; tmat.c = mat2.c; for (int i = 0; i &lt; mat1.r; i++) for (int j = 0; j &lt; mat2.c; j++) for (int k = 0; k &lt; mat1.c; k++) tmat.matrix[i][j] = (tmat.matrix[i][j] + mat1.matrix[i][k] * mat2.matrix[k][j]) % 1000; return tmat;&#125;void fastpow(int index)&#123; Mat retmat; retmat.r = retmat.c = 2; retmat.matrix[0][0] = retmat.matrix[1][1] = 1; retmat.matrix[0][1] = retmat.matrix[1][0] = 0; while (index) &#123; if (index &amp; 1) retmat = mul(retmat, basmat); basmat = mul(basmat, basmat); index &gt;&gt;= 1; &#125; printf("%03d\n", ((retmat.matrix[0][0] &lt;&lt; 1) - 1) % 1000);&#125;int main(int argc, char ** argv)&#123; freopen("C-large-practice.in", "r", stdin); freopen("C-large-practice.out", "w", stdout); scanf("%d", &amp;T); for (int TT = 1; TT &lt;= T; TT++) &#123; scanf("%d", &amp;n); init(); printf("Case #%d: ", TT); fastpow(n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[The Cruel World High School Grade 1 永远感谢Yirannn 我们所可以自慰的，想来想去，也还是所谓对于将来的希望。 希望是附丽于存在的，有存在，便有希望，有希望，便是光明。 所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Friends]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[按照字典序排序 Name M_sea Chhokmah FFjet FlyInTheSky LJC00118 Logey memset0 redbag SiriusRen Studying Father Yirannn]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
