<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「HDU 1166」 敌兵布阵]]></title>
    <url>%2F2018%2F08%2F07%2FHDU-1166%2F</url>
    <content type="text"><![CDATA[题外话永远不要迷信快读！或许你认为手写read()很快，实际上在HDU上惨不忍睹！目前原因未知，知道的dalao欢迎email本蒟蒻目测是getchar()与换行符的锅 题目链接HDU 1166 题解明显线段树裸题 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define local#ifdef local#pragma warning(disable:4996)#endifusing namespace std;int T, n, x, y, ans;int a[200010];int sum[200010];int add[200010];string st;void pushup(int root)&#123; sum[root] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1];&#125;void build(int l, int r, int root)&#123; if (l == r) sum[root] = a[l]; else &#123; int mid = (l + r) &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void update(int l, int r, int root)&#123; if (l == r) sum[root] += y; else &#123; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(l, mid, root &lt;&lt; 1); else update(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); &#125;&#125;void query(int l, int r, int root)&#123; if (l &gt;= x &amp;&amp; r &lt;= y) &#123; ans += sum[root]; return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) query(l, mid, root &lt;&lt; 1); if (y &gt; mid) query(mid + 1, r, root &lt;&lt; 1 | 1);&#125;void init()&#123; memset(sum, 0, sizeof sum); memset(add, 0, sizeof add); build(1, n, 1);&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; T; for (int T_T = 1; T_T &lt;= T; T_T++) &#123; printf("Case %d:\n", T_T); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; init(); while (cin &gt;&gt; st) &#123; ans = 0; if (st == "End") break; cin &gt;&gt; x &gt;&gt; y; if (st == "Sub") y *= -1; if (st == "Query") query(1, n, 1), printf("%d\n", ans); else update(1, n, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio 忽略错误]]></title>
    <url>%2F2018%2F07%2F28%2FVisual-Studio-%E5%BF%BD%E7%95%A5%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[正文问题用Visual Studio写程序时，OI界选手都知道freopen("file","r",stdin);freopen("file","w,"stdout); 是比赛时必不可少的然而你用VS编译时会报错，显示freopen不安全，要用freopen_s然而不会用怎么办？我们选择手动忽略错误 解决#pragma warning(disable:4996) 这句话用于忽略报freopen错的C4996错误信息其余错误信息同理]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器的一般食用方法]]></title>
    <url>%2F2018%2F07%2F28%2F%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%80%E8%88%AC%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正文 首先你得下一个编译器（在线版或离线版安装），途径如下： 群文件里 网上（推荐是官网下） 若在线版，则运行并安装，记安装路径为X:\Y\ Windows用户 32位选x86（也可能叫i386-win32之类的） 64位选x86_64或x86均可 Linux用户apt-get之类的基本可以关掉本文档了 若离线版，则解压至X:\Y\ 在安装目录下找到一个叫做bin的文件夹，里面通常会有名叫g++.exe之类的文件 按Windows徽标键，输入path，选择“编辑系统环境变量” 单击“环境变量(N)”，在下面“系统变量(S)”里面寻找变量名为Path的变量 双击该变量 Windows 10用户单击新建(N)，将X:\Y\bin粘贴进去，确定-确定-确定 其他Windows用户在Path已有的路径后面加个英文分号“;”（注意一定是英文分号），后面粘贴X:\Y\bin，确定-确定-确定 Windows徽标键+R，输入cmd，输入g++ -v，看看有没有诸如“gcc version 8.1.0 (x86_64-win32-seh-rev0, Built by MinGW-W64 project)”的信息文件 如果有，恭喜你成功配置了编译器 如果没有，重启试试看，有些系统需要重启才可生效 一般重启后会生效 没生效的话在群里询问吧]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[至今遇到过的坑]]></title>
    <url>%2F2018%2F07%2F26%2F%E8%87%B3%E4%BB%8A%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[正文持续更新QAQ C++的一些坑以$0$开头永远记住C++从$0$开始分配内存！ sort()函数如果你习惯了以$1$开头，设数组$a$长度为$n$，那么sort()函数的写法如下：sort(a+1,a+n+1); string先#include &lt;iostream&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; return 0;&#125; 用MinGW G++/GCC编译，完全没有问题然而用Visual Studio（MSVC++编译）就会报错你需要加一句：#include &lt;string&gt; 注意不是string.h或cstring，而是string！ STLvector等，你以为能当数组用？一个未初始化的vector，访问其中的元素会相当漂亮地RE]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学 数论初步]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%95%B0%E5%AD%A6-%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[正文我知道看到之前两篇“初步”，发现这又是一个“初步”你很可能想打人……不过，数论确实是信息学竞赛的一个重要内容那么，先从简单的讲起吧—— 基础概念集合 In mathematics, a set is a collection of distinct objects, considered as an object in its own right. 集合是有某种特定性质的具体的或抽象的对象汇总成的集体，其本身被视为一个对象，构成集合的对象也被称为元素我们下面所要用到的主要是整数集$\mathrm{Z}=\lbrace \dots,-2,-1,0,1,2,\dots \rbrace$和自然数集$\mathrm{N}=\lbrace 0,1,2,\dots \rbrace$ 整除性与约数符号$d|a$读作$d$整除$a$，含义是存在某个整数$k$，使得$a=kd$，任何整数均可整除$0$若$a&gt;0$且$d|a$，则$|d|\leqslant |a|$若$d|a$，则称$a$是$d$的倍数若$d|a$且$d\geqslant 0$，则称$d$是$a$的约数。注意，$d|a$当且仅当$-d|a$，即$a$的任何约数的相反数同样可以整除$a$注：《算法导论》中文译本作“负数”，个人觉得不妥；英文原著作”negative”，其想表达的应是“相反数”因此，不失一般性，可规定约数为负数任何正整数$a$均可被平凡约数（$\pm 1,\pm a$）整除，整数$a$的非平凡约数称为$a$的因子注：《算法导论》中文译本作“平凡约数$1$和其自身$a$所整除”，但后文举例因子时并未算上$a$，故下此对平凡约数的定义，下文与《算法导论》的说法也略有出入 质数与合数若一个整数$a&gt;1$且只能被其平凡约数所整除，则这个数是质数（素数）；若一个整数$a&gt;1$且不是质数，则称之为合数我们称整数$1$为基本单位，其非质数亦非合数。同样，$0$和所有负整数既不是质数也不是合数 除法定理、余数与等模除法定理对于任何整数$a$和任何正整数$n$，存在唯一整数$q$和$r$，满足$0\leqslant r&lt;n$且$a=qn+r$称$q=\lfloor\frac{a}{n}\rfloor$为除法的商，值$r=a\,\mathrm{mod}\,n$为除法的余数。$n|a$当且仅当$a\,\mathrm{mod}\,n=0$（即$r=0$） 余数这里提一下，$\mathrm{mod}$作为高级语言中不可或缺的运算符（亦在某些语言中写作%），所表达的意义也不同（甚至与数学上的定义不同）例如，在Pyhton中，-7 % 4 输出是： 1 而在C++中，cout &lt;&lt; (-7 % 4) &lt;&lt; endl; 输出是： -3 事实上，在这两门语言中，$a\,\mathrm{mod} b$的意义不同：C++中的意义是“求余”，Python中的意义是“取模”计算商的时候，求余向$0$方向舍入，取模则向$-\infty$方向舍入也可以这样说，取余运算结果符号与$a$一致，求模运算结果符号与$b$一致将$\mathrm{mod}$推广至任意实数：$$x\,\mathrm{mod}\,y=x-y\lfloor\frac{x}{y}\rfloor,y\neq 0$$若$a\,\mathrm{mod}\,n=b\,\mathrm{mod}\,n$，则记$a\equiv b(\mathrm{mod}\,n)$，并称模$n$时$a$等价于$b$ 模$n$等价类根据整数模$n$的余数，我们可将所有整数划分成$n$个等价类。包含整数$a$的模$n$等价类为：$$[a]_n=\lbrace a+kn:k\in \mathrm{Z}\rbrace$$所有这些等价类的集合是：$$\mathrm{Z}_n=\lbrace [a]_n:0\leqslant a\leqslant n-1\rbrace$$ 公约数与最大公约数若$d|a,d|b$，则称$d$为$a$与$b$的公约数。公约数的一条重要性质是：$d|a$且$d|b$蕴涵着$d|(a+b)$且$d|(a-b)$更一般地，对于任意整数$x$和$y$，有：$d|a$且$d|b$蕴涵着$d|(ax+by)$并且，如果$a|b$，那么$|a|\leqslant|b|$，或者$b=0$，而这说明：$a|b$且$b|a$蕴涵着$a=\pm b$两个不同时为$0$的整数$a$与$b$的公约数中最大的称为其最大公约数，记作$\gcd(a,b)$ 最大公约数的性质$$\gcd(a,b)=\gcd(b,a)\\gcd(a,b)=\gcd(-a,b)\\gcd(a,b)=\gcd(|a|,|b|)\\gcd(a,0)=|a|$$ 互质数若$\gcd(a,b)=1$，则$a$与$b$称为互质数对于整数$n_1,n_2,\dots,n_k$，若$\forall i\neq j$都有$\gcd(n_i,n_j)=1$，则称整数$n_1,n_2,\dots,n_k$两两互质 唯一分解定理下面进入本博文第一个重头戏 引理对所有质数$p$和所有整数$a,b$若$p|ab$，则$p|a$或$p|b$（或两者皆成立）从本引理可知，任意一个合数的质因子分解式是唯一的 唯一分解定理合数$a$仅能以一种方式写成如下乘积形式：$$a=p_1^{e_1}p_2^{e_2}\dots p_r^{e_r}$$其中$p_i$为质数，$p_1&lt;p_2&lt;\dots&lt;p_r$，且$e_i$为正整数 Attention接下来我们仅对非负整数进行讨论 欧几里得算法对任意非负整数$a$和任意正整数$b$，$$\gcd(a,b)=\gcd(b,a\,\mathrm{mod}\,b)$$ 证明：根据上文，设$a\geqslant b$得：$a=bq+r,\,r=a-bq$设$d|a,d|b$，且$a=sd,b=td$$\therefore r=sd-tdq=d(stq)$$\because d,s,t\in N$$\therefore d|r$$\therefore a,b$的任何公约数皆可被$r$整除，包括最大公约数因此算法正确性得证 程序实现long long gcd(long long _parametera,long long _parameterb)&#123; return _parameterb?gcd(_parameterb,_parametera%_parameterb):_parametera;&#125; 扩展欧几里得算法特别地，我们推广该算法用于计算出满足下列条件的整系数$x$和$y$：$$d=\gcd(a,b)=ax+by$$注意，$x$与$y$可能为非正数先上伪代码，返回三元组$(d,x,y)$：EXTENDED-EUCLID(a,b)if b==0 return(a,1,0)else (d&apos;,x&apos;,y&apos;)=EXTENDED-EUCLID(b,a mod b) (d,x,y)=(d&apos;,y&apos;,x&apos;-⌊a/b⌋y&apos;) return(d,x,y) 我知道这相当丑，于是还有一份C++的int extended_euclid(int a, int b, int &amp;x, int &amp;y)&#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = extended_euclid(b, a%b, x, y); int t = x; x = y; y = t - a / b * y; return d;&#125; 证明令$b=0$，易得$\gcd(a,b)=a$，此时$x=1,y=0$当$ab\neq 0$时，首先计算满足$d’=\gcd(b,a\,\mathrm{mod}\,b)$和$$d’=bx’+(a\,\mathrm{mod}\,b)y’$$的$(d’,x’,y’)$。在此情况下，根据欧几里得算法，有$d=\gcd(a,b)=d’=\gcd(b,a\,\mathrm{mod}\,b)$由此，我们又得到：$$d=bx’+(a-b\lfloor\frac{a}{b}\rfloor)y’=ay’+b(x’-\lfloor\frac{a}{b}\rfloor y’)$$因此，当$x=y’,y=x’-\lfloor\frac{a}{b}\rfloor y’$时即可满足等式$d=ax+by$扩欧的正确性得证 有限群群$(S,\oplus)$是一个集合$S$和定义在$S$上的二元运算$\oplus$，该运算满足下列性质： 封闭性：对所有$a,b\in S$，有$a\oplus b\in S$ 单位元：存在一个元素$e\in S$，称为群的单位元，满足对所有$a\in S$，$e\oplus a=a\oplus e=a$ 结合律：对所有$a,b,c\in S$，有$(a\oplus b)\oplus c=a\oplus(b\oplus c)$ 逆元：对每个$a\in S$，存在唯一的元素$b\in S$，称为$a$的逆元，满足$a\oplus b=b\oplus a=e$例如，对于群$(\mathrm{Z},+)$，$0$是单位元，$a$的逆元为$-a$若群$(S,\oplus)$满足交换律，即对所有$a,b\in S$，有$a\oplus b=b\oplus a$，则它是一个交换群若群$(S,\oplus)$满足$|S|&lt;\infty$，则它是一个有限群 由模加法与模乘法所定义的群通过对模$n$运用加法与乘法运算，可以得到两个有限交换群，其中$n$是正整数。这些群基于上文定义的整数模$n$所形成的等价类现在，我们需要合适的二元运算来定义$\mathrm{Z}_n$上的群，该运算可以通过重新定义普通的加法运算与乘法运算得到也就是说，若$a\equiv a’(\mathrm{mod}\,n)$且$b\equiv b’(\mathrm{mod}\,n)$，那么$$a+b\equiv a’+b’(\mathrm{mod}\,n)\\ab\equiv a’b’(\mathrm{mod}\,n)$$因此，定义模$n$加法与模$n$乘法如下（分别用$+_n$和$\cdot_n$表示）：$$[a]_n+_n[b]_n=[a+b]_n\\ [a]_n\cdot_n[b]_n=[ab]_n$$运用该模$n$加法的定义，定义模$n$加法群$(\mathrm{Z}_n,+_n)$，其规模为$|\mathrm{Z}_n|=n$同理，运用模$n$乘法的定义，定义模$n$乘法群$(\mathrm{Z}_n^*,\cdot_n)$，该群中的元素是$\mathrm{Z}_n$中与$n$互质的元素组成的集合$\mathrm{Z}_n^*$:$$\mathrm{Z}_n^*=\lbrace[a]_n\in\mathrm{Z}_n:\gcd(a,n)=1\rbrace$$ 子群类似于子集，若$(S,\oplus)$是一个群，$S’\subseteq S$，并且$(S’,\oplus)$也是一个群，则$(S’,\oplus)$称为$(S,\oplus)$的子群对每一个群$S$的子群$S’$，若$S’\neq S$，则子群$S’$称为群$S$的真子群 拉格朗日定理若$(S,\oplus)$是一个有限群，$(S’,\oplus)$是$(S,\oplus)$的一个子群，则$|S’|$是$|S|$的一个约数 由一个元素生成的子群由$a$生成的子群用$\langle a\rangle$或$(\langle a\rangle,\oplus)$来表示，其定义如下：$$\langle a\rangle=\lbrace a^{(k)}:k\geqslant 1\rbrace$$称$a$生成子群$\langle a\rangle$，$a$是$\langle a\rangle$的生成元 模$n$乘法逆元设$a$是$\mathrm{Z}_n^*$中的一个元素，令$d=\gcd(a,n)$，可知$d=1$因为$a\in\mathrm{Z}_n^*$且$$ax+ny=1$$或者等价地，$$ax\equiv 1(\mathrm{mod}\,n)$$因此，$[x]_n$是$[a]_n$对模$n$乘法的逆元 说实话，看《算法导论》的时候这一段真没看懂模$n$乘法群的元素是怎么回事。为此我去请教某dalao，终于得到了一个通俗易懂的解释可能存在不严谨之处，还请指出！很显然$1$是该模$n$乘法群的单位元。在模$n$群里找$a$的逆元$x$，则可得$ax\equiv 1(\mathrm{mod}\,n)$这相当于$ax-kn=1$，说明了$a$和$n$互质因此只有与$n$互质的$a$才有逆元下文将$a$的乘法逆元记作$a^{-1}$ 欧拉函数$\mathrm{Z}_n^*$的规模表示为 $$\varphi(n)=n\prod_{p|n}(1-\frac{1}{p})$$ 其中$p$是质数（若$n$为质数，则也包括$n$）若$p$为质数，则$\mathrm{Z}_p^*=\lbrace 1,2,\dots\,p-1\rbrace$，且$$\varphi(p)=p(1-\frac{1}{p})=p-1$$若$n$为合数，则$\varphi(n)&lt;n-1$，尽管它可以表示为 $$\varphi(n)&gt;\frac{n}{e^{\gamma}\ln\ln n+\frac{3}{\ln\ln n}}$$ （我当然不会，《算法导论》上抄的）其中$n\geqslant3$，此时$\gamma=0.5772156649\dots$是欧拉常数 莫比乌斯函数莫比乌斯函数$\mu(n)$对所有整数$n\geqslant 1$由整式$$\sum_{d|n}\mu(d)=[n=1]$$来定义。$[n=1]$表示若$n=1$为$1$，否则为$0$ 快速幂平时计算$n^k$时，通常我们的算法都是$O(n)$直接计算事实上，根据初中数学的知识，我们知道：若$k$为奇数，则$n^k=(n^{\lfloor\frac{k}{2}\rfloor})^2\cdot n$若$k$为偶数，则$n^k=(n^{\frac{k}{2}})^2$（终于来个简单点的了啊） 代码实现long long fast_power(int _base, int _index)&#123; long long _pow = 1; while (_index) &#123; if (_index &amp; 1) _pow *= _base; _base *= _base; _index &gt;&gt;= 1; &#125; return _pow;&#125; 下面是模$n$快速幂的做法 long long fast_power_modulo(int _base, int _index, int _modulus)&#123; long long _pow_mod = 1; _base %= _modulus; while (_index) &#123; if (_index &amp; 1) _pow_mod = _pow_mod * _base%_modulus; _base = _base * _base%_modulus; _index &gt;&gt;= 1; &#125; return _pow_mod;&#125; 应用求解模线性方程现在来考虑求解下列方程的问题：$$ax\equiv b(\mathrm{mod}\,n)$$其中$a&gt;0$，$n&gt;0$其等价于$ax+ny=b$，称为二元一次不定方程 两个推论当且仅当$d|b$时，上述方程对于未知量$x$有解，这里$d=\gcd(a,n)$上述方程或者对模$n$有$d$个不同的解，或者无解，这里$d=\gcd(a,n)$这两个推论本蒟蒻并不打算证明，因为我不会啊涉及到群和子群，我就是不会啊比较深入 求解若$\gcd(a,n)=1$，则$x$有唯一解$x\equiv a^{-1}b(\mathrm{mod}\, n)$否则，设$d=\gcd(a,n),a=a’d,n=n’d,b=b’d$则有$a’x+n’y=b’$，即$a’x\equiv b’(\mathrm{mod}\,n)$这里$\gcd(a’,n’)=1$，因此有$x\equiv(a’)^{-1}b’(\mathrm{mod}\,n’)$你要问我为什么？下次再说吧 戛然而止这篇博文太长了……Hexo崩溃了好几次而且一篇博文讲太多东西也难以接受，同时鉴于篇幅也难免有所简略因此这篇博文剩余的以及不明确的内容，将由下面两篇数学博文补充！真的好累啊]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AtCoder」 ABC 103]]></title>
    <url>%2F2018%2F07%2F23%2FAtCoder-ABC-103%2F</url>
    <content type="text"><![CDATA[题外话永远记住日本时间比中国早1个小时！这篇比较水，除了T3 题目链接AtCoder ABC 103 题解T1纯暴力不解释 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a, b, c;#define X abs(a-b)#define Y abs(b-c)#define Z abs(a-c)int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; min(X + Y, min(X + Z, Y + Z)) &lt;&lt; endl; return 0;&#125; T2纯暴力，字符串的函数需要熟悉一些 代码#include &lt;iostream&gt;using namespace std;string S, T;int main(int argc, char ** argv)&#123; getline(cin, S); getline(cin, T); for (int i = S.length(); i; i--) &#123; char ch = S[S.length() - 1]; S.erase(S.length() - 1, 1); S.insert(S.begin(), ch); if (S == T) &#123; cout &lt;&lt; "Yes\n"; return 0; &#125; &#125; cout &lt;&lt; "No\n"; return 0;&#125; T3这题真的是给Beginner做的？虽然代码比较短小精悍这题就是要我们证明对于序列${a_1,a_2,\dots,a_n}$，存在$x\equiv(a_k-1)(\mathrm{mod}\,a_k),1\leqslant k\leqslant n$当然，稍微想想会会发现$\prod_{k=1}^na_k-1$即为满足上述条件的$x$既然存在$x$，则最大的$f$值就显而易见是$\sum_{k=1}^n(a_k-1)=\sum_{k=1}^na_k-n$那么就可以相当完美地解决这道题 代码#include &lt;iostream&gt;using namespace std;int n, ans, a;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a, ans += a; cout &lt;&lt; ans - n &lt;&lt; endl; return 0;&#125; T4上来就想到DP，想了一会发现是贪心，然后我就跪在了sort()上……STL的东西最好还是了解怎么回事再用！贪心的思路很好想，具体看代码 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Edge&#123; int st, ed;&#125;;Edge a[100010];int n, m, ans;bool cmp(Edge x, Edge y)&#123; if (x.ed == y.ed) return x.st &lt; y.st; else return x.ed &lt; y.ed;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i].st &gt;&gt; a[i].ed; sort(a + 1, a + m + 1, cmp); int Cur = 0; for (int i = 1; i &lt;= m; i++) &#123; if (a[i].st &gt;= Cur) &#123; ans++; Cur = a[i].ed; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 后记本篇博文相当水……当然也不是我故意的为了肝后面一篇重磅的数学博文，OI只能稍稍搁置一下了顺带说一句绝对不要对后面一篇博文抱有什么能看得懂的幻想]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>Math</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1281」 书的复制]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%B4%9B%E8%B0%B7-1281%2F</url>
    <content type="text"><![CDATA[题外话写这篇博文的目的有两个，一是好久没有写关于OI的博文，二是某大佬说最好写一下提醒别人别被数据坑了……毕竟我被这题的神奇数据坑了2个多小时 题目链接洛谷 1281话说洛谷换新的url了 题解用一句非常精辟的话概括题意（不是我想出来的）：寻找一种分配方案，使抄写页数最多的最少很明显的二分就出来了不过二分只能找出答案，根据答案推每个人的任务还需要处理鉴于题目中说“尽可能让前面的人少抄写”，故从尾至头贪心，给后面的人分配的越多越好由于是从后往前分配任务的，输出是从前往后，于是采用栈记录输出的数据，当然也可以用递归输出 坑你以为就这样完了？我那3次WA就是这么来的……事实上，对于$m=0,k=0$的情况是不用输出的……真的巨坑啊…… 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;int m, k;int Max;int a[100001];stack &lt;int&gt; outl;stack &lt;int&gt; outr;bool judge(int t)&#123; int sum = 0; int pseudo_peo = 1; for (int i = 1; i &lt;= m; i++) &#123; if (a[i]&gt;t) return false; if (sum + a[i] &lt;= t) sum += a[i]; else &#123; sum = a[i]; pseudo_peo++; &#125; &#125; return pseudo_peo &lt;= k;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; m &gt;&gt; k; if (!m &amp;&amp; !k) &#123; return 0; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a[i]; Max += a[i]; &#125; int l = 1, r = Max; while (l&lt;r) &#123; int mid = (l + r) / 2; if (judge(mid)) r = mid; else l = mid + 1; &#125; int ans = l; int sum = 0; int cntpeop = k - 1; r = m; for (int i = m; i; i--) &#123; if (sum + a[i] &lt;= ans &amp;&amp; i&gt;cntpeop) &#123; sum += a[i]; l = i; &#125; else &#123; outl.push(l); outr.push(r); l = r = i; sum = a[i]; cntpeop--; &#125; &#125; cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl; while (!outl.empty()) &#123; cout &lt;&lt; outl.top() &lt;&lt; " " &lt;&lt; outr.top() &lt;&lt; endl; outl.pop(); outr.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>洛谷</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学 定积分初步]]></title>
    <url>%2F2018%2F07%2F14%2F%E6%95%B0%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[正文引入前两篇数学博文研究了曲边梯形面积和等差数列，各有一个悬而未决的问题。曲边梯形面积探究我们还未深入，等差数列我们未推导出求积公式。此次探究将全部解决！ AttentionAttention!本博客较之前的两篇数学博客，定义要多得多，且较为抽象，请带好纸笔画图！但是理解完本博客，你就完成了数学的伟大跨越！ 导数平均变化率对于一条直线，其斜率可很好的描述其倾斜程度斜率$k=\frac{\Delta y}{\Delta x}=\tan \theta$相似的，我们也可以用这种方式计算一条曲线的倾斜程度，该比值称为这段曲线的平均变化率在此给出平均变化率的准确定义：一般地，函数$f(x)$在区间$[x_1,x_2]$上的平均变化率为$$\frac{f(x_2)-f(x_1)}{x_2-x_1}$$平均变化率为负代表曲线图像下降 割线、切线设$P(x,f(x))$为曲线$C$上一点，$Q$为曲线$C$上不同于$P$的一点，这时，直线$PQ$称为曲线$C$的割线可以想象，当点$Q$无限逼近点$P$时，直线$PQ$最终将成为在点$P$处最逼近曲线的直线$l$，这条直线$l$称为曲线在点$P$处的切线计算割线斜率$$k=\frac{f(x+\Delta x)-f(x)}{(x+\Delta x)-x}=\frac{f(x+\Delta x)-f(x)}{\Delta x}$$当$PQ$逼近$l$时，即$\Delta x\to 0$时，$\frac{f(x+\Delta x)-f(x)}{\Delta x}$无限趋近于点$P$处的切线的斜率 引申——瞬时速度物理学中，运动物体位移与所用时间的比称为平均速度，现在我们所要计算的是该物体的瞬时速度我们完全可以想象，假设时间间隔为$\Delta t$，那么要求瞬时速度，只需求$\Delta t\to 0$的时间内物体的速度继续给出准确定义：一般地，如果当$\Delta t\to 0$时，运动物体位移$S(t)$的平均变化率$\frac{S(t+\Delta t)-S(t)}{\Delta t}$无限趋近于一个常数，那么这个常数称为物体在$t=t_0$时的瞬时速度 导数刚刚的问题涉及到了函数在某一点处的瞬时变化率——导数设函数$y=f(x)$在区间$(a,b)$上有定义，$x_0\in(a,b)$，若$\Delta x\to 0$时，比值$$\frac{\Delta y}{\Delta x}=\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x} $$无限趋近于一个常数$A$，则称$f(x)$在$x=x_0$处可导，并称该常数$A$为函数$f(x)$在$x=x_0$处的导数，记作$f’(x_0)$导数$f’(x_0)$的几何意义就是曲线$y=f(x)$在点$P(x_0,f(x_0))$处的切线的斜率，$x_0$即为切点的横坐标若$f(x)$对于区间$(a,b)$内任一点都可导，则$f(x)$在各点的导数也随着自变量$x$的变化而变化，因而也是自变量$x$的函数该函数称为$f(x)$的导函数，记作$f’(x)$$f(x)$在$x=x_0$处的导数$f’(x_0)$就是导函数$f’(x)$在$x=x_0$处的函数值 定积分理解完毕，我们回忆曲边梯形面积直线$x=0,x=1,y=0$和曲线$y=x^2$围成的曲边梯形面积$S=\frac{1}{3}$我们将其分为$n$份，每份长度为$\Delta x=\frac{1}{n}$一般地，设函数$f(x)$在区间$[a,b]$上有定义。将区间$[a,b]$等分成$n$个小区间，每个小区间长度为$\Delta x(\Delta x=\frac{b-a}{n})$，在每个小区间上取一点，依次为$x_1,x_2,\dots,x_i,\dots\,x_n$作和$$S_n=f(x_1)\Delta x+f(x_2)\Delta x+\dots+f(x_i)\Delta x+\dots+f(x_n)\Delta x$$如果当$\Delta x\to 0$（亦即$n\to +\infty$）时，$S_n\to S$（常数），那么称常数$S$为函数$f(x)$在区间$[a,b]$上的定积分，记为$$S=\int^{b}_{a}f(x)\mathrm{d}x$$（知道我用$\LaTeX$打这玩意多么费劲么）其中，$f(x)$称为被积函数，$[a,b]$称为积分区间,$a$称为积分下限,$b$称为积分上限按定积分的定义，曲边梯形面积$S$就是曲边对应的函数$y=x^2$在区间$[0,1]$上的定积分，即 $$S=\int^{1}_{0}x^2\mathrm{d}x$$ 这时，我们假设被积函数$f(x)$在区间$[a,b]$上非负当$f(x)$在区间$[a,b]$上可取负值时，定积分的几何意义是什么呢这里图就略过了，直接给出定义：一般地，定积分的几何意义是在区间$[a,b]$上曲线与$x$轴所围图形面积的代数和（即$x$轴上方的面积减去$x$轴下方的面积） 微积分基本定理先摆出定理：对于被积函数$f(x)$，如果$F’(x)=f(x)$，那么 $$\int^{b}_{a}f(x)\mathrm{d}x=F(b)-F(a)=F(x)\vert ^b_a$$ 即 $$\int^{b}_{a}F’(x)\mathrm{d}x=F(b)-F(a)=F(x)\vert ^b_a$$ 接下来我们来验证，用曲边梯形的面积求法上文的曲边梯形实则是一个曲边三角形，让我们回忆曲边梯形的面积，基本原理就是作差我们将直线$x=0,x=x_0,y=0$和曲线$y=x^2$围成的曲边三角形面积记作$S(x_0)$令$g(x)=x^2$ $\because S(x_0)=\int^{x_0}_{0}g(x)\mathrm{d}x, S(x_0)=S(x_0)-S(0)$ $\therefore \int^{x_0}_{0}g(x)\mathrm{d}x=S(x_0)-S(0)$ 根据对曲边梯形面积的探究，我们也可以得到$S(x_0)=\frac{1}{3}x_0^3$对$S$求导，得：$S’(x_0)=\frac{1}{3}\cdot 3x_0^2=x_0^2$$\therefore S’(x_0)=g(x_0)$根据微积分基本定理得$\int^{x_0}_{0}g(x_0)\mathrm{d}x=\int^{x_0}_{0}S’(x_0)\mathrm{d}x=S(x_0)-S(0)$与上面结果一致故验证了微积分基本定理 Congratulations恭喜！你已经步入了高等数学的大门！接下来又是一些定义，相比刚才的推导易于接受些 算子微分算子无限微积分基于由$$Df(x)=\lim_{h\to 0}\frac{f(x+\Delta x)-f(x)}{\Delta x} $$所定义的微分算子$D$的性质有点眼熟？没错，$Df(x)$正是$f(x)$导函数！ 差分算子有限微积分基于由$$\Delta f(x)=f(x+1)-f(x)$$所定义的差分算子$\Delta$的性质可以看出，差分算子是微分的有限模拟，限制了$h$的正整数取值。于是当$h\to 0$时，$h=1$是我们所能到达的最近的“极限”，而$\Delta f(x)$则是$\frac{f(x+\Delta x)-f(x)}{\Delta x} $当$\Delta x=1$时的取值 幂我们知道$Df(x^m)$相当于对$f(x)=x^m$求导，结果是$Df(x^m)=mx^{m-1}$我们很希望$\Delta$算子也能像这样简单，但事实上并不如此，比如：$\Delta(x^3)=(x+1)^3-x^3=3x^2+3x+1$真是个乱七八糟的式子！但是有一类“$m$次幂”，它在$\Delta$的作用下可以很好地变换，这就是有限微积分的意义所在这种新型的$m$次幂由规则 $$x^{\underline m}=x(x-1)\dots (x-m+1),m\in N$$ 来定义。一共有$m$个因子相乘与此同时，还有一个对应的定义： $$x^{\overline m}=x(x+1)\dots (x+m-1),m\in N$$ 当$m=0$时，我们有$x^{\underline 0}=x^{\overline 0}=1$$x^{\underline m}$读作“$x$直降$m$次”；类似地，$x^{\overline m}读作“$x$直升$m$次”同时，这两个函数也被称为下降阶乘幂和上升阶乘幂扯回下降阶乘幂与$\Delta$算子。我们有\begin{align}\Delta(x^{\underline m})&amp;=(x+1)^{\underline m}-x^{\underline m}\\&amp;=(x+1)x\dots (x-m+2)-x\dots (x-m+2)(x-m+1)\\&amp;=mx(x-1)\dots (x-m+2)\\\end{align}由此，我们得到：$$\Delta(x^{\underline m})=mx^{\underline {m-1}}$$ 等差数列等差数列求积公式终于回到了放置已久的问题：等差数列求积公式现在，我们已经拥有足够的知识储备以解决这个问题了给定一首项为$a_1,$，公差为$d$的等差数列$\lbrace a\rbrace$，有：\begin{align}a_1a_2\dots a_n&amp;=d\frac{a_1}{d}d(\frac{a_1}{d}+1)d(\frac{a_1}{d}+2)\dots d(\frac{a_1}{d}+n-1)\\&amp;=d^n(\frac{a_1}{d})^{\overline n}\end{align}注意此公式在$\frac{a_1}{d}$为负或$0$时不可用至此，遗留的两个问题已全部解决 Gamma函数……还没完刚才的公式还可以写成$$\prod_{i=1}^{n}a_i=d^n\frac{\Gamma(\frac{a_1}{d}+n)}{\Gamma(\frac{a_1}{d})}$$我知道你很想打人……$\Gamma$是Gamma函数，对于$n\in N_+$，有$$\Gamma(n)=(n-1)!$$但Gamma函数的定义域远不止此对于非正整数的具有正实部的复数，有$$\Gamma(z)=\int^{\infty}_{0}x^{z-1}e^{-x}\mathrm{d}x$$没错，我也看不懂……不过，Gamma函数还可以用一种方法将定义域扩展到全部复数……——够了！ 尾声本博文解决了之前两篇悬而未决的问题，可能阅读起来有点困难不过Gamma函数的第二个定义完全可以不理它！事实上，我在写这篇博文时Hexo也崩溃了好几次，甚至导致了端口堵塞（我也不容易QAQ）衷心希望你能有所收获！]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学 曲边梯形面积探究]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%95%B0%E5%AD%A6-%E6%9B%B2%E8%BE%B9%E6%A2%AF%E5%BD%A2%E9%9D%A2%E7%A7%AF%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[正文引入Q1求函数$y=0, x=0, x=1, y=1$图像围成的图形的面积很显然面积是1 Q2求函数$y=0, x=0, x=1, y=x$图像围成的图形的面积很显然面积是$0.5$ Q3求函数$y=0, x=0, x=1, y=x^2$图像围成的图形的面积函数$y=x^2$在初二并没有学到，因此我们有必要对它进行进一步的了解 抛物线事实上，$y=x^2$的图像是一个相当漂亮的抛物线，下面是它的图像：下面是Wikipedia在代数上对抛物线的定义： The parabola is the locus of points in that plane that are equidistant from both the directrix and the focus.A parabola is a graph of a quadratic function. 抛物线是平面内到准线与焦点等距离的点的轨迹抛物线是一个二次函数的图像 接着，Wikipedia作了更详尽的说明： The line perpendicular to the directrix and passing through the focus is called the “axis of symmetry”.The point on the parabola that intersects the axis of symmetry is called the “vertex”, and is the point where the parabola is most sharply curved.The distance between the vertex and the focus, measured along the axis of symmetry, is the “focal length”.The “latus rectum” is the chord of the parabola which is parallel to the directrix and passes through the focus. 垂直于准线且过焦点的线称为“对称轴”，简称轴抛物线与对称轴的交点被称作“顶点”，并且这个点是抛物线弯曲幅度最大的点沿着对称轴测量，顶点和焦点的距离称为“焦距”平行于准线且过焦点的弦称为“正焦弦” 上图（原图自Wikipedia）: 回到Q3设要求的面积为$S$我们再看要求的面积：一个类似于直角三角形的图形的面积，不过斜边是曲线（事实上这个图形仍由四条直线构成，我们仍把它看作梯形，本博文为避免混淆，称其为曲边三角形，在后面的博文中会称其为曲边梯形）乍一看没什么思路：这并不是规则图形不过我们要想到，遇到不规则图形，解决问题的唯一途径就是割补！ 过剩估计我们将所求图形在$x$轴上的边分为$10$份并画出$10$个右上顶点在抛物线上的矩形表述的可能不清，如图所示记所有矩形的面积和为$S_1$我们发现$S_1&gt;S$，故称其为$S$的过剩估计值很容易求出$S_1$，当然，$S_1$并不等于的$S$我们将其分为$512$、$1024$、$2048$份的时候，会发现$S_1$的值无限趋近于$\frac{1}{3}$ 打个岔，既然$S_1$无限趋近于$\frac{1}{3}$却又不可能达到$\frac{1}{3}$，我们可以这样表示：$S_1\to \frac{1}{3}$即：$\frac{1}{3}$是$S_1$的极限令函数$p(i)$的值等于将$x$轴上的边分成$n$份时$S_1$的值，则又可写成：$\lim_{n\to \infty}p(n)=\frac{1}{3}$得出了这个结论，我们有必要证明一下 证明设我们将$x$轴上的边分成$n$份可得： \begin{align}S_1&amp;=\frac{1}{n}\cdot \frac{1^2}{n^2}+\frac{1}{n}\cdot \frac{2^2}{n^2}+\dots +\frac{1}{n}\cdot \frac{n^2}{n^2}\\&amp;=\frac{1}{n^3}\cdot (1^2+2^2+\dots +n^2)\\\end{align}又有：$1\cdot 2+2\cdot 3+\dots +n\cdot (n+1)$$=\frac{1}{3}(1\cdot 2\cdot 3-0\cdot 1\cdot 2)+\dots +\frac{1}{3}(n\cdot (n+1)\cdot (n+2)-(n-1)\cdot n\cdot(n+1))$$=\frac{1}{3}n(n+1)(n+2)$①$\sum\nolimits_{i=1}^{n}i=\frac{n(1+n)}{2}$②①$-$②，得：$1\cdot (1+1)+2\cdot (2+1)+\dots+n(n+1)-(1+2+\dots +n)=\frac{1}{3}n(n+1)(n+2)-\frac{n(1+n)}{2}$$\therefore 1^2+2^2+\dots +n^2=\frac{1}{6}n(n+1)(2n+1)$带入原式，得：\begin{align}S_1&amp;=\frac{1}{n^3}\cdot \frac{1}{6}n(n+1)(2n+1)\\&amp;=\frac{1}{6n^2}(n+1)(2n+1)\end{align}将其展开，得：\begin{align}S_1&amp;=\frac{1}{3}+\frac{1}{3n}+\frac{1}{6n^2}\end{align}$\because n\to \infty$$\therefore \frac{1}{3n}\to 0,\frac{1}{6n^2}\to 0$$\therefore S_1\to \frac{1}{3}$ 不足估计除了过剩估计，还有不足估计同样将所求图形在$x$轴上的边分为$10$份，我们这次画出$10$个左上顶点在抛物线上的矩形依然上图：没错，你发现了，实际上只有九个，因为最左边的一个左上角顶点坐标是$(0,0)$，但为了下文计算方便，我们认为最左边的矩形长为$\frac{1}{n}$，宽为$\frac{0^2}{n^2}$同样记所有矩形面积和为$S_2$，又发现$S_2&lt;S$，因此我们称之为$S$的不足估计值我们也可以很容易的求出$S_2$：\begin{align}S_2&amp;=\frac{1}{n}\cdot \frac{0^2}{n^2}+\frac{1}{n}\cdot \frac{1^2}{n^2}+\dots +\frac{(n-1)^2}{n^2}\\&amp;=\frac{1}{n^3}\cdot (0^2+1^2+\dots +(n-1)^2)\\&amp;=\frac{1}{6n^2}(n-1)(2n-1)\end{align}同理，展开得：\begin{align}S_2&amp;=\frac{1}{3}-\frac{1}{2n}+\frac{1}{6n^2}\end{align}$\because n\to \infty$$\therefore \frac{1}{2n}\to 0,\frac{1}{6n^2}\to 0$$\therefore S_2\to \frac{1}{3}$ 夹逼定理我们已经知道，$S_2&lt;S&lt;S_1$，且$S_1\to \frac{1}{3}, S_2\to \frac{1}{3}$那么$S$呢？猜猜也知道是$\frac{1}{3}$！实际上，数学上有一个非常奇妙的定理给我们了这个证明——夹逼定理算了我们还是称其为三明治定理吧……这个定理简单地说，就是若函数$A&gt;B,B&gt;C,A\to x,C\to x$，那么必有$B\to x$所以$S=\frac{1}{3}$证完（是不是觉得自己很伟大） Q4推广至求函数$y=0, x=0, x=t, y=x^2$图像围成的图形的面积简单的迁移，可得：$S=\frac{1}{3}t^3$ Q5别忘了我们探究的是曲边梯形求函数$y=0, x=0, x=1, x=0.5, y=x^2$图像围成的图形的面积上个图就很明显了：易得：$S_0=S_1-S_{0.5}$ Q6推广至一般形式求函数$y=0, x=0, x=a, x=b, y=x^2(a&lt;b)$图像围成的图形的面积直接上答案吧$S_0=\frac{1}{3}b^3-\frac{1}{3}a^3$ 尾声我们在这里只讨论了一个基本的结论下次，我们会对这个基本结论进行再探究]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 图床]]></title>
    <url>%2F2018%2F07%2F11%2FGitHub-%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[正文 create a repository clone 到本地 将想要上传的图片push 进入图床repository，找到你刚才push的图片 左键单击查看图片 在图片上右击-在新标签页中打开图片 复制图片url 该url即可直接调用 注意：以“https://github.com/” 开头的并不是你图片的url正常情况下url应以“https://raw.githubusercontent.com/” 开头在调用时严格区分大小写，包括文件扩展名的大小写！]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学 等差数列初步]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%95%B0%E5%AD%A6-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[引用说明本文引用的定义皆出自中文维基百科 正文定义 等差数列（又名算术数列）是数列的一种。在等差数列中，任何相邻两项的差相等。该差值称为公差。 我们设一等差数列为$\lbrace a\rbrace$ 公差公式由于等差数列相邻两项差值为$d$，可知第$a_n$与$a_m(m&lt;n)$之间相差$(n-m)$个$d$由此，我们得到：$$d=\frac{a_n-a_m}{n-m}$$ 通项公式由于等差数列相邻两项差值为$d$，可知第$a_n$与$a_m(m&lt;n)$之间相差$(n-m)$个$d$可得：$$a_n=a_m+(n-m)d$$ 等差级数 等差数列的和称为等差级数。 等差级数公式$$S_n=\frac{n(a_1+a_n)}{2}$$ 证明代数方法记等差数列$\lbrace a\rbrace$前$n$项的级数为$S_n$，可得：$S_n=(a_1+0d)+(a_1+1d)+(a_1+2d)+\dots+(a_1+(n-1)d)$$S_n=(a_n-(n-1)d)+(a_n-(n-2)d)+\dots+(a_n-d)+a_n$二式相加，得：$2S_n=na_1+na_n$$\therefore S_n=\frac{n(a_1+a_n)}{2}$ 几何方法我们可以这样想象：$a_1$表示一个长为$a_1$、宽为$1$的长方形$a_2$表示一个长为$a_2$、宽为$1$的长方形$\dots$$a_n$表示一个长为$a_n$、宽为$1$的长方形于是$S_n$便相当于这$n$个长方形的面积和把这$n$个长方形拼成一个直角梯形，根据梯形面积公式，得：$S_n=\frac{n(a_1+a_n)}{2}$ 性质所有等差数列的等差级数均可表示为$S_n=pn^2+qn$的形式。 证明对于等差数列$\lbrace a\rbrace$，我们有：\begin{align}S_n&amp;=\frac{n(a_1+a_n)}{2}\\&amp;=\frac{n(2a_1+(n-1)d)}{2}\\&amp;=\frac{2na_1+n^2d-nd}{2}\\&amp;=na_1+\frac{d}{2}n^2-\frac{d}{2}n\\&amp;=\frac{d}{2}n^2+(a_1-\frac{d}{2})n\end{align}$\therefore p=\frac{d}{2},\,q=a_1-\frac{d}{2}=a_1-p$ 命题等差中项对于任意的正整数$n&gt;1$，都有$$a_{n-1}+a_{n+1}=2a_n$$ 证明根据等差数列定义，得：$a_{n-1}=a_n-d, a_{n+1}=a_n+d$$\therefore a_{n-1}+a_{n+1}$$=a_n-d+a_n+d$$=2a_n$ 根据这个命题，我们可以推广：若有三个正整数$a, b, c$，满足$a+c=2b$，则$a, b, c$可组成一公差为$b-a$的等差数列 等差数列的积由于太菜不会，这里先略过……]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 添加搜索功能]]></title>
    <url>%2F2018%2F04%2F07%2FHexo-%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[题外话这个搜索功能坑了我好久…… 正文Step 1$ npm install hexo-generator-searchdb --save Step 2打开站点根目录_config.yml Step 3在文末加上 search: path: search.xml field: all format: html limit: 10000 Step 4打开NexT主题_config.yml Step 5找到local_search，将enable改为true]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 任务栏透明优化]]></title>
    <url>%2F2018%2F04%2F07%2FWindows-%E4%BB%BB%E5%8A%A1%E6%A0%8F%E9%80%8F%E6%98%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题外话这是我第一次用Menci大大开发的Moeditor写markdown文件，相比较Notepad++纯感觉无预览，使用感觉还是相当不错的。话说像我这种用GitHub当图床的也没谁了吧…… 正文初衷作为一名重度强迫症患者，说实话我很难容忍Windows任务栏与桌面的格格不入。 Step 1有问题先Google百度。先试了一下StartIsBack，发现不能设置全屏开始菜单栏，于是果断放弃。 Step 2百度不靠谱，只能上知乎。在知乎上找到了TranslucentTB。readme.md又指导我们访问AppVeyor artifacts以获取最新版（尽管是开发版）。下载&amp;使用，效果可以说是接近完美。附上效果图： 设置 显示隐藏图标-找到TranslucentTB-右击 勾选“Open at boot”，这样默认开机自启 鼠标移至Regular State-选择想要的效果 找到TranslucentTB.exe根目录，打开config.cfg 找到第二行 accent= ，等号后面的blur改为刚才你选择的效果（normal, clear, opaque, blur） 附对照表： 选项 效果 normal 系统默认 clear 全透明 opaque 不透明 blur 模糊]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 1160」 Post Office]]></title>
    <url>%2F2018%2F01%2F06%2FPOJ-1160%2F</url>
    <content type="text"><![CDATA[题外话话说原本mathjax老是出故障的\$\$突然变正常了，开心~ 题目链接POJ 1160 大意在$V$个村庄里选$P$个作为邮局，使得每个村庄到距它最近的邮局的距离和最短。 题解裸典型的区间DP。设$f(i,j)$表示前$i$个村庄内建立$j$个邮局的最小距离和，最终答案即为$f(V,P)$。可以想到，前$i$个村庄内建立$j$个邮局即为前$k$个村庄建立$j-1$个邮局、第$k+1$到第$i$个村庄建一个邮局。设$w(i,j)$表示在村庄$i$、$j$之间建立一个邮局后，该邮局与村庄$i$、$j$的最短距离和。易得：$w(i,j)=w(i,j-1)+a(j)-a((i+j)/2)$。可能有人会问，如果$i+j$为偶，则位置能确定（$(i+j)/2\in N^*$）；但若$i+j$为偶，是选$\lceil (i+j)/2 \rceil$还是$\lfloor (i+j)/2 \rfloor$呢？我们可以假设共有6个村庄，要在范围$[1..6]$内选择1个做邮局。根据上面疑问，我们分别选取$\lceil (i+j)/2 \rceil$即4与$\lfloor (i+j)/2 \rfloor$即3做比较。设每个村庄位置分别为$a_i$。 选取4。则总距离为：$$(a_4-a_1)+(a_4-a_2)+(a_4-a_3)+0+(a_5-a_4)+(a_6-a_4)=a_6+a_5+a_4-a_3-a_2-a_1$$ 选取3。则总距离为：$$(a_3-a_1)+(a_3-a_2)+0+(a_4-a_3)+(a_5-a_3)+(a_6-a_3)=a_6+a_5+a_4-a_3-a_2-a_1$$ 因此，可得当$i+j$为偶时，选$\lceil (i+j)/2 \rceil$与$\lfloor (i+j)/2 \rfloor$ 等价。计算$w$数组时可以用前缀和优化，在此不赘述。综上，不难得方程：$f(i,j)=min\lbrace f(i,j),f(k,j-1)+w(k+1,j)\rbrace$时间复杂度$O(pv^2)$ 代码 - 裸#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) &#123; for (int j = i + 1; j &lt;= v; j++) &#123; w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; &#125; &#125; memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) &#123; f[i][i] = 0; f[i][1] = w[1][i]; &#125; for (int j = 2; j &lt;= p; j++) &#123; for (int i = j + 1; i &lt;= v; i++) &#123; for (int k = j - 1; k &lt; i; k++) &#123; f[i][j] = min(f[i][j], f[k][j - 1] + w[k + 1][i]);//注意别写到括号外面去 &#125; &#125; &#125; cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;&#125; 优化在这里，我们要用到一个叫做四边形不等式的东西。 四边形不等式此问题中包含着一个常见的状态转移方程：$$f(i,j)=min\lbrace f(i,k-1)+f(k,j)+w(i,j)\rbrace$$假如对于任意$i\leq i’&lt;j\leq j’$，都有$w(i’,j)\leq w(i,j’)$，那么我们称函数$w$满足关于区间包含的单调性另外，假如有：$$w(i,j)+w(i’,j’)\leq w(i’,j)+w(i,j’)$$那么我们称函数$w$满足四边形不等式。不等式较抽象，建议画图理解。理解后，我们引出两个定理：1、若上述函数$w$同时满足区间包含单调性与四边形不等式，那么函数$f$也满足四边形不等式，即：$$f(i,j)+f(i’,j’)\leq f(i’,j)+f(i,j’),\;i\leq i’&lt;j\leq j’$$我们再定义函数$s(i,j)$表示$f(i,j)$取得最优值时对应的$k$。此时有定理：2、若上述函数$f$满足四边形不等式，则函数$s$单调，即：$$s(i,j)\leq s(i,j+1)\leq s(i+1,j+1)$$得出结论2后，我们发现：$s(i,j-1)\leq s(i,j)\leq s(i+1,j)$因此函数$f$等价于：$$f(i,j)=min\lbrace f(i,k-1)+f(k,j)+w(i,j)\rbrace,\;s(i,j-1)\leq k\leq s(i+1,j)$$ 回到问题理解四边形不等式后，我们发现：本题的$f$也满足四边形不等式（证明实在没力气了）。因此，本题可以优化成$O(vp)$。 代码 - 优化#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int s[1001][1001];int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) &#123; s[i][i] = i; for (int j = i + 1; j &lt;= v; j++) &#123; w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; &#125; &#125; memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) f[i][1] = w[1][i]; for (int i = 1; i &lt;= p; i++) s[v + 1][i] = v;//计算可能越界 for (int i = 1; i &lt;= p; i++) &#123; for (int j = v; j &gt; i; j--) &#123; for (int k = s[j][i - 1]; k &lt;= s[j + 1][i]; k++) &#123; if (f[j][i] &gt; f[k][i - 1] + w[k + 1][j]) &#123; f[j][i] = f[k][i - 1] + w[k + 1][j]; s[j][i] = k; &#125; &#125; &#125; &#125; cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>DP</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio 保存文件编码格式]]></title>
    <url>%2F2017%2F12%2F04%2FVisual-Studio-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题外话Visual Studio确实是最强的IDE，但功能太复杂了啊……每年产品的界面都不一样。2017企业版的默认保存为LINUX格式的，Windows下只能用Notepad++打开，很是苦恼。网上都说安装什么破插件。最后终于找到一篇正常的了…… 正文添加“高级保存选项” 单击“工具”|“自定义”命令，弹出“自定义”对话框。 单击“命令”标签，进入“命令”选项卡。 在“菜单栏”下拉列表中，选择“文件”选项。 单击“添加命令”按钮，弹出“添加命令”对话框。 在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”按钮，关闭“添加命令”对话框。 选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。 单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 更改保存格式更改成自己想要的编码即可。 参考解决Visual Studio 2017隐藏“高级保存选项”命令]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 2823」 Sliding Window]]></title>
    <url>%2F2017%2F11%2F26%2FPOJ-2823%2F</url>
    <content type="text"><![CDATA[题外话这题提交方式很玄学……C++交就TLE，改成G++就AC了…… 题目链接POJ 2823 题解首先我们想到暴力模拟，妥妥的TLE，加上POJ老掉牙的机器，不知道T成什么样了……既然模拟不可行，那么我们只能考虑一种新的方法。目前我们貌似没有掌握一种算法能快速算区间最大值的，因此我们只能从数据结构入手。堆？你怎么确定元素是否超出窗口边界？用struct？那还怎么用STL的priority_queue？线段树？和堆一样的问题（怎么删除超出边界的元素）。我们发现，我们需要的是一种 能支持\(O(1)\)输出队列最大值 具有队列的一切功能（进队、出队） 要实现这两个功能，我们只能请出新的角色——单调队列 单调队列上文已经说明单调队列的作用了，接下来我们要讨论如何实现单调队列。首先队列清空（这里有个坑，留待你发掘）。遇到即将入队的新元素，将它与队尾元素比较，如果大于队尾元素就不断弹出队尾元素，直到队尾元素大于即将入队的元素位置。新元素进队。保证队列元素都在规定范围内：判断队首元素是否超过边界，若超过，就不断弹出队首元素，直到队首元素在规定范围内。规定范围内的最大值就是该队列的队首元素。由于要实现两端都能出队的队列，只能挥泪告别STL，迎接手写queue了…… 代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, k;int a[1000005];int q[1000005];//队列int p[1000005];//下标struct Number&#123; int pos, val;&#125;num[1000005];void SolBig()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; &#125; cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; &#125; cout &lt;&lt; endl;&#125;void SolSml()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; &#125; cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) &#123; while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; &#125; cout &lt;&lt; endl;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; SolSml(); SolBig(); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2017」普及组复赛解题报告]]></title>
    <url>%2F2017%2F11%2F25%2FNOIP-2017%E6%99%AE%E5%8F%8A%E7%BB%84%E5%A4%8D%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题外话吐槽一下CCF的老爷机：CPU AMD Athlon(tm) II x2 240 processor，2.8GHz大概是什么价位的呢？ 参考报价：￥185 停产 2014-04-14（摘自中关村在线）都2017年了还不换新机子？？ 题目链接百度网盘 P1 成绩题解这题是给智商80-的人写的……不过官方好像说有精度问题（题目中明明写着“A、B、C 都是 10 的整数倍”啊）然后重测了。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;double a, b, c;int main(int argc, char ** argv)&#123; freopen("score.in", "r", stdin); freopen("score.out", "w", stdout); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; floor(a*0.2 + b*0.3 + c*0.5) &lt;&lt; endl; return 0;&#125; P2 图书管理员题解比较水啊，但注意图书编号不能只用string存，因为字符串大小和数字大小有区别。 代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int n, q;string st[1005];int nb[1005];int main(int argc, char ** argv)&#123; freopen("librarian.in", "r", stdin); freopen("librarian.out", "w", stdout); memset(nb, 0, sizeof(nb)); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; st[i]; for (int j = 0; j&lt;st[i].length(); j++) nb[i] = (nb[i] &lt;&lt; 3) + (nb[i] &lt;&lt; 1) + (st[i][j] ^ 48); &#125; for (int i = 0; i&lt;q; i++) &#123; bool flag = false; int tmp; int _min = 0x7f7f7f7f; string nd; cin &gt;&gt; tmp &gt;&gt; nd; for (int j = 0; j&lt;n; j++) &#123; if (st[j].length()&lt;nd.length()) continue; if (st[j].substr(st[j].length() - nd.length(), nd.length()) == nd) &#123; _min = min(_min, nb[j]); flag = true; &#125; &#125; if (!flag) cout &lt;&lt; "-1" &lt;&lt; endl; else cout &lt;&lt; _min &lt;&lt; endl; &#125; return 0;&#125; P3 棋盘题解两种解法。第一种是建图+最短路，第二种是DFS+记忆化。出于懒得写图让你们更简单地A掉这题的缘故，我决定写DFS。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define INF 0x7f7f7f7fint n, m;int a[105][105];int v[105][105];int f[105][105];void dfs(int x, int y, bool chd, int cst, int col)&#123; if (x&gt;m || y&gt;m || x &lt;= 0 || y &lt;= 0) return; if (chd&amp;&amp;a[x][y] == INF) return; else if (!chd&amp;&amp;a[x][y] == INF) &#123; cst += 2; chd = true; &#125; else if (a[x][y] != INF) &#123; if (a[x][y] != col) cst++; col = a[x][y]; chd = false; &#125; if (cst &lt; f[x][y]) f[x][y] = cst; else return; dfs(x-1, y, chd, cst, col); dfs(x, y-1, chd, cst, col); dfs(x, y+1, chd, cst, col); dfs(x+1, y, chd, cst, col);&#125;int main(int argc, char ** argv)&#123; freopen("chess.in", "r", stdin); freopen("chess.out", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; m &gt;&gt; n; memset(a, INF, sizeof(a)); memset(f, INF, sizeof(f)); for (int i = 1; i &lt;= n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cin &gt;&gt; a[x][y]; &#125; dfs(1, 1, 0, 0, a[1][1]); if (f[m][m] == INF) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; f[m][m] &lt;&lt; endl; return 0;&#125; P4 跳房子题解一眼看出是二分，check()函数用DP。设\(f(i)\)表示跳到第\(i\)个格子最大分数。显而易见，\(f(i)=max \lbrace f(j) \rbrace +s_i\)，且从第\(j\)个格子能跳到第\(i\)个格子。裸的DP能拿50分，下面考虑优化。由于计算的是一个单调区间的最大值，并且该区间不断后移，我们可以考虑用单调队列实现。 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define MAXN 500005int n, d, k;int h, t;long long f[MAXN];long long x[MAXN];long long s[MAXN];long long q[MAXN];void push(int add)&#123; while (f[q[t]] &lt;= f[add] &amp;&amp; h &lt;= t) t--; q[++t] = add;&#125;bool chk(int g)&#123; memset(f, -0x7f7f7f7f, sizeof(f)); f[0] = 0; h = 1; t = 0; int p = 0; q[h] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (x[i] - x[p] &gt;= max(d - g, 1) &amp;&amp; p &lt; i) push(p++); while (x[i] - x[q[h]] &gt; d + g&amp;&amp;h &lt;= t) h++; if (h &gt; t || f[q[h]] == -0x7f7f7f7f) continue; else f[i] = f[q[h]] + s[i]; if (f[i] &gt;= k) return true; &#125; return false;&#125;int main(int argc, char ** argv)&#123; ios::sync_with_stdio(false); freopen("jump.in", "r", stdin); freopen("jump.out", "w", stdout); cin &gt;&gt; n &gt;&gt; d &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; s[i]; if (!chk(x[n])) cout &lt;&lt; -1; else &#123; int l = 1, r = x[n]; while (l &lt; r) &#123; int mid = (l + r) / 2; if (chk(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」普及组复赛解题报告]]></title>
    <url>%2F2017%2F10%2F18%2FNOIP-2016%E6%99%AE%E5%8F%8A%E7%BB%84%E5%A4%8D%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接百度网盘 P1 买铅笔题解这题分外水啊……几个if就可以AC。考试时3分钟敲完……但今年懒得用if写了十几分钟…… 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, ans;int main(int argc, char ** argv)&#123; freopen("pencil.in","r",stdin); freopen("pencil.out","w",stdout); ans = 0x7f7f7f7f; cin &gt;&gt; n; for (int i = 1; i &lt;= 3; i++) &#123; int num, cost; cin &gt;&gt; num &gt;&gt; cost; ans = min(ans, (n / num + ((bool)(n - (n / num)*num)))*cost); //(bool)将int类余数强制转换成bool，若n能整除num（即不用再多买），则余数为0（false）。 //否则表达式的值就是true（非0即真），要多买一盒。 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P2 回文日期题解考试的时候敲了16KB（是的，你没看错，16KB），搞得监考老师查程序的时候差点叫出来……万幸的是AC了……解此题有两种方法。1、穷举日期（00000000~99999999），加上一堆检查，时间复杂度≈\(O(2×10^8)\)，比较险。2、穷举年份。因为每个年份存在多个日期，但只可能存在一个回文的，所以只要穷举年份，构造出回文日期，再判断是否合法即可。 代码//穷举年份#include&lt;iostream&gt;using namespace std;int stime, etime, ans;const int Mon[] = &#123; 0,31,28,31,30,31,30,31,31,30,31,30,31 &#125;;bool spe(int yea)&#123; return !(yea % 4) &amp;&amp; yea % 100 || !(yea % 400);//!(X % Y)：判断X是否整除Y，别写反。也要注意!的优先级比%高&#125;int main(int argc, char ** argv)&#123; freopen("date.in", "r", stdin); freopen("date.out", "w", stdout); cin &gt;&gt; stime &gt;&gt; etime; for (int i = stime / 10000; i &lt;= etime / 10000; i++) &#123; int pres = i * 10000 + (i % 10) * 1000 + (i % 100 / 10) * 100 + (i % 1000 / 100) * 10 + i / 1000; int mon = pres % 10000 / 100; int day = pres % 100; if (spe(pres / 10000) &amp;&amp; mon == 2) if (day &lt;= 29) if (pres &gt;= stime&amp;&amp;pres &lt;= etime) &#123; ans++; continue; &#125; if (day &lt;= Mon[mon] &amp;&amp; mon &lt;= 12) if (pres &gt;= stime&amp;&amp;pres &lt;= etime) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; P3 海港题解考试的时候作死，做出来70分胡改改成了25分……70分做法：按船存储数据，对于每艘船，找它和一天之前所有船的人员国籍。100分做法：按人存储数据。由于每艘船上的人的到港时间都是一样的，所以只需记录下每艘船到的时间和每个人的国籍。维护一个\(sum\)记录国籍总数，遇到一天前的船（人）就减去国籍数。详细内容见代码。 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;int num_data;int Sear;int sum;int nati[100005];int peop[100005];struct Ship&#123; int first, last, time;&#125;ship[100005]; int Binary_search(int left, int right)//二分查找最近的超过一天的船&#123; int ans = 0; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (Sear - ship[mid].time &gt;= 86400) &#123; ans = max(ans, mid); left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return ans;&#125;int main(int argc, char ** argv)&#123; freopen("port.in", "r", stdin); freopen("port.out", "w", stdout); cin &gt;&gt; n; int lastship = 0;//上一个（记录过的）超过一天的船 for (int i = 1; i &lt;= n; i++) &#123; int Peop; cin &gt;&gt; ship[i].time &gt;&gt; Peop; Sear = ship[i].time; ship[i].first = ship[i - 1].last + 1; ship[i].last = ship[i].first + Peop - 1; for (int j = 1; j &lt;= Peop; j++) &#123; cin &gt;&gt; peop[++num_data]; if (!nati[peop[num_data]]) sum++; nati[peop[num_data]]++; &#125; int BS = Binary_search(1, i); if (BS)//存在一个（最近的）一天前的船，因此，一天前的船即为lastship+1~BS的船 &#123; for (int j = ship[lastship + 1].first; j &lt;= ship[BS].last; j++)//lastship已经记录过，因此循环从lastship+1开始 &#123; nati[peop[j]]--; if (!nati[peop[j]]) &#123; sum--; &#125; &#125; lastship = BS; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 解释看到这里相信肯定有读者有疑惑：为什么你能保证\(sum\)的值一定是当前国籍总数？注意到，我们的\(nati_i\)记录的是拥有国籍\(i\)的人的一天内的总数。当发现有船到港时间在一天前，减去该船所有人的国籍记录即可。若减下来\(nati\)数组某国人数为0，就代表了一天内没有该国人到港。由于到港时间是单调上升的，上艘船的前一天到港的船只也必定是本艘船前一天到港的，因此本艘船的数据可以沿用上一艘的记录。 P4 魔法阵题解这题拿到手先暴力……暴力完开始想正解。由于\(n\)和\(m\)都比较大，并且题目中有几个方程，肯定想到用数学方法解。当然差分约束从方程入手。为方便，记\(x_a\)为\(A\)、\(x_b\)为\(B\)，\(C\)、\(D\)同理。\(\because B−A=2(D−C),\ B-A&lt;(C-B)/3\)\(\therefore 2(D-C)&lt;(C-B)/3\)\(\therefore C-B&gt;6(D-C)\)设\(D-C=i\)则\(B-A=2i\)\(C-B&gt;6i\)\(\therefore D-A&gt;9i\)推完后，我们发现先确定\(i\)，再枚举\(D\)，就能把\(C\)求出来，同理，枚举\(A\)，就能把\(B\)求出来。维护4个数组记录每样物品分别作为\(A,B,C,D\)的次数，根据简单的乘法原理和加法原理可以算出来方案数。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt; using namespace std;int x[40005];int s[40005];int a[40005];int b[40005];int c[40005];int d[40005];#define q ' 'int n, m;int main(int argc, char ** argv)&#123; freopen("magic.in", "r", stdin); freopen("magic.out", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x[i]; s[x[i]]++; &#125; for (int i = 1; i * 9 + 1 &lt;= n; i++) &#123; int sum = 0; for (int D = i * 9 + 2; D &lt;= n; D++) &#123; sum += s[D - 7 * i - 1] * s[D - 9 * i - 1]; c[D - i] += s[D] * sum; d[D] += s[D - i] * sum; &#125; sum = 0; for (int A = n - i * 9 - 1; A; A--) &#123; sum += s[A + i * 9 + 1] * s[A + i * 8 + 1]; a[A] += s[A + 2 * i] * sum; b[A + 2 * i] += s[A] * sum; &#125; &#125; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; a[x[i]] &lt;&lt; q &lt;&lt; b[x[i]] &lt;&lt; q &lt;&lt; c[x[i]] &lt;&lt; q &lt;&lt; d[x[i]] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++探索」 main函数参数]]></title>
    <url>%2F2017%2F08%2F01%2FC%2B%2B-main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[说明今天突然不想用VS了，打开Dev-C++又胡乱设置一通。突然在Dev-C++的菜单-工具-编译器属性-语法里看到这样一段：int main(int argc, char **argv) 顿时懵了：main函数还带参数？？于是别人博客+自行摸索，总结出如下结论（注意：方便起见，讨论的将先是int main(int argc, char * argv[])，不要问我为什么）。 讨论char * argv[]先编写以下代码：#include&lt;iostream&gt;using namespace std;int main(int argc, char * argv[])&#123; cout &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) cout &lt;&lt; argv[i] &lt;&lt; endl; return 0;&#125; 注意，这里直接运行会得到以下结果： 1 D:\Program\Debug\Program.exe 看的是不是云里雾里？既然输出了程序的路径，那么我们放到cmd里运行试试。D:\Program\Debug\Program.exe 输出一样。那么，1是什么？让我们尝试运行以下指令：D:\Program\Debug\Program.exe Sena 输出： 2 D:\Program\Debug\Program.exe Sena 似乎有点明白了？再运行以下指令：D:\Program\Debug\Program.exe Sena Senb Senc 输出： 4 D:\Program\Debug\Program.exe Sena Senb Senc 现在很明显了：argc是命令行参数的个数，argv[]存的是命令行的参数。而argv[0]指向exe程序路径。 char ** argv可能你会说，上面更改了原来的参数，并不能说明问题。因此下面我们研究char * argv[]与char ** argv 的区别。先看char * argv[]。由于[]的优先级高于*，所以a先与[]组合，因此argv是一个数组，数组中的元素类型是char *。对于char ** argv，argv是二级指针（指针的指针），指向一级指针char *的地址。而char *本身是个指向第一个字符的指针！所以不严谨的看，char * argv[]等价于char ** argv。之所以说不严谨，是因为char *存放在常量区，而char []存放在栈中。前者赋初值后不能更改，而后者可以。编写以下代码：#include&lt;iostream&gt;using namespace std;int main(int argc, char ** argv)&#123; cout &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) cout &lt;&lt; argv[i] &lt;&lt; endl; system("pause"); return 0;&#125; 其输出与char * argv[]无异。若将第7行改为cout &lt;&lt; *argv[i] &lt;&lt; endl;的话，则输出： 1 D cmd中运行以下指令：D:\Program\Debug\Program.exe Sena Senb Senc 输出： 4 D S S S 输出的是每个参数的首字母，因为char *本身是个指向第一个字符的指针。 总结看完本文，相信读者已经对main函数的参数有了一定的了解，同时对指针有了更深的认识。当然，由于本文并未涉及字符串的编辑，所以char * argv[]与char ** argv的区别并没有真正体现出来。这将在以后的学习过程中提及。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++关键字」 register]]></title>
    <url>%2F2017%2F08%2F01%2FC%2B%2B-register%2F</url>
    <content type="text"><![CDATA[说明众所周知，计算机在运行程序时，会读取程序存储在硬盘的数据，数据被加载在内存里面，即可执行命令。而存放在CPU寄存器里的数据存取速度比内存快得多。然而，CPU寄存器数量有限，所以不能存储太多数据。所以我们只取优化较大的变量存储到CPU寄存器里。这时候，我们就要用到register关键字。 定义register修饰符暗示编译程序相应的变量将被频繁地使用。 注意点 register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。 因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。 实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。 只有函数参数和局部变量可被声明为register。 register变量的生命周期只维持在它所声明的块中。 测试下面对比使用register关键字前后的运行速度。 代码#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;int main()&#123; LARGE_INTEGER st, ed, t; QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); for (int i = 1; i &lt;= 700; i++) for (int j = 1; j &lt;= 700; j++) for (int k = 1; k &lt;= 700; k++) ; QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time (unregistered) : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; //====================// QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); for (register int i = 1; i &lt;= 700; i++) for (register int j = 1; j &lt;= 700; j++) for (register int k = 1; k &lt;= 700; k++) ; QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time (registered) : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出：Use time (unregistered) : 0.88237 Sec.Use time (registered) : 0.855508 Sec.可以看到是有些优化的。将循环改到\(800^3\)，输出：Use time (unregistered) : 1.322 Sec.Use time (registered) : 1.19792 Sec.再改到\(1000^3\)，输出：Use time (unregistered) : 2.63044 Sec.Use time (registered) : 2.23786 Sec.改为\(350,000,000\)的一重循环，发现反例：Use time (unregistered) : 0.989227 Sec.Use time (registered) : 1.19519 Sec. 总结虽然register关键字有小幅优化（有时则相反），但对于\(O(N^3)\)的时间复杂度也力不从心。所以，优化算法才是王道！ 参考C++中register关键字]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「C++技巧」 计时]]></title>
    <url>%2F2017%2F07%2F31%2FC%2B%2B-%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[说明计时可以在C++里面方便地实现，可以在诸如NOIP、NOI之类的比赛中了解算法最坏运算时间。当然，如果对于自己算法的时间复杂度很有信心的话（\(O(N)\)之类的）请移步……不过如果复杂度到了\(O(N^2)\)或\(O(N \log N)\)的级别的话还是建议测一下，前提是你会敲……毕竟第2、3种方法比较复杂，考试时用的是Dev-C++又不是Visual Studio。 方法1用time()函数获取当前系统时间。time()函数返回的是time_t类型的数据，返回值是从1970年1月1日（UNIX TIME的纪元时间）到当前时刻的秒数。 代码#include&lt;iostream&gt;#include&lt;time.h&gt;using namespace std;time_t st, ed;void work()&#123; for (int i = 1; i &lt;= 300000000; i++) ;&#125;int main()&#123; st = time(NULL); work(); ed = time(NULL); cout &lt;&lt; "Use Time : " &lt;&lt; ed - st &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Use Time : 1 Sec. 可以看到C++循环里啥都不干1秒能跑3亿次循环。 方法2（实属无聊）用SYSTEMTIME里的函数获取当前系统时间（毫秒级）。 代码#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;void work()&#123; for (int i = 1; i &lt;= 300000000; i++) ;&#125;int main()&#123; SYSTEMTIME st, ed; GetLocalTime(&amp;st); work(); GetLocalTime(&amp;ed); cout &lt;&lt; "Start Time : " &lt;&lt; st.wYear &lt;&lt; '/' &lt;&lt; st.wMonth &lt;&lt; '/' &lt;&lt; st.wDay &lt;&lt; ' ' &lt;&lt; st.wHour &lt;&lt; ':' &lt;&lt; st.wMinute &lt;&lt; ':' &lt;&lt; st.wSecond &lt;&lt; ':' &lt;&lt; st.wMilliseconds &lt;&lt; " Week" &lt;&lt; st.wDayOfWeek &lt;&lt; endl; cout &lt;&lt; "End Time : " &lt;&lt; ed.wYear &lt;&lt; '/' &lt;&lt; ed.wMonth &lt;&lt; '/' &lt;&lt; ed.wDay &lt;&lt; ' ' &lt;&lt; ed.wHour &lt;&lt; ':' &lt;&lt; ed.wMinute &lt;&lt; ':' &lt;&lt; ed.wSecond &lt;&lt; ':' &lt;&lt; ed.wMilliseconds &lt;&lt; " Week" &lt;&lt; ed.wDayOfWeek &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Start Time : 2017/8/1 20:55:50:369 Week2 End Time : 2017/8/1 20:55:51:209 Week2 推翻上面数据。跑3亿次循环仅需840毫秒，上面的情况只是由于测试是在起始秒的第160毫秒后计算的。用此程序测得1s最多循环次数为344,795,000（1.001s）。注意：要看CPU和内存的性能，相同机器不同时间可能结果有异。 方法3（更无聊了）用QueryPerformanceCounter()函数返回高精确度性能计数器的值（微秒级）。 代码#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;void work()&#123; for (int i = 1; i &lt;= 350000000; i++) ;&#125;int main()&#123; LARGE_INTEGER st, ed, t; QueryPerformanceFrequency(&amp;t); QueryPerformanceCounter(&amp;st); work(); QueryPerformanceCounter(&amp;ed); cout &lt;&lt; "Use time : " &lt;&lt; (ed.QuadPart - st.QuadPart)*1.0 / t.QuadPart &lt;&lt; " Sec." &lt;&lt; endl; system("pause"); return 0;&#125; 输出： Use time : 0.93279 Sec. 事实证明3亿5千万完全没压力（运气好的话）。 结尾其实方法远不止这3种……。NOIP的话建议第二种即可，第一种实在不敢恭维。再次注意不要迷信测出来的时间！具体运行时间要看CPU、内存的性能及人品！NOIP好运！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1553」 数字反转（升级版）]]></title>
    <url>%2F2017%2F07%2F31%2F%E6%B4%9B%E8%B0%B7-1553%2F</url>
    <content type="text"><![CDATA[题外话这题也坑了我好久……谁说分到“简单”字符串的？？？话说好像字符串的题一碰就死……然而【狡（Wei）黠（Suo）的微笑】，这题可以不用字符串。所以你没看到上面的Tags有一个STL啊？？语言歧视（笑）。欸，你没发现题解几乎和洛谷 1308一毛一样？？？ 题目链接洛谷 1553 题解本题考点是字符串的操作，如果你聪明的话也可以用stack实现。也是两种解法：一是找出特殊字符位置做相应处理，二是像我一样用stack实现（其实我也是看到别人题解才恍然大悟的）。由于第二种方法涉及到STL，所以就写第二种了（Pascal党请移步）。细节较多，请自己体会。 解释为什么可以用stack实现？原因在于stack（栈）这种线性数据结构的特性：FILO（First In Last Out）刚好符合题中反转的要求！ 代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;sstream&gt;//stringstreamusing namespace std;stack &lt;char&gt; stac;string st;char ch, op;bool flag;int main()&#123; getline(cin, st); stringstream read(st);//用stringstream只为锻（Zhuang）炼（Bi） flag = true; while (read &gt;&gt; ch) &#123; if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; if (op != '.') stac.push(ch);//进栈 else &#123; if (!(ch == '0' &amp;&amp; flag)) stac.push(ch); if (ch != '0') flag = false; &#125; &#125; else &#123; op = ch; while (!stac.empty() &amp;&amp; stac.top() == '0')//是否为空栈 stac.pop();//出栈 if (stac.empty()) cout &lt;&lt; 0; while (!stac.empty()) &#123; cout &lt;&lt; stac.top();//取栈顶元素 stac.pop(); &#125; cout &lt;&lt; op; &#125; &#125; while (!stac.empty() &amp;&amp; stac.top() == '0') stac.pop(); if (op != '%') if (stac.empty()) cout &lt;&lt; 0; while (!stac.empty()) &#123; cout &lt;&lt; stac.top(); stac.pop(); &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1308」 统计单词数]]></title>
    <url>%2F2017%2F07%2F30%2F%E6%B4%9B%E8%B0%B7-1308%2F</url>
    <content type="text"><![CDATA[题外话这题坑了我好久……谁说分到“简单”字符串的？？？ 题目链接洛谷 1308 题解本题考点是字符串的操作。两种解法：一是读完文章再操作，二是边读边操作。由于第一种方法用的标准函数较多，就写第一种了（虽然第二种较优），有兴趣的可以尝试第二种（实际上是我懒得写第二种了）。 细节如果使用algorithm里的transform函数的话要注意函数的意义：第1、2个参数是字符串的起始、结束位置。第3个参数是开始应用转换的位置。第4个参数是执行的操作（toupper/tolower）。还有一点，如果直接写成“transform(string.begin(), string.end(), string.begin(), tolower);”这样的话提交至OJ有可能出错：“error: no matching function for call to ‘transform(std::basic_string::iterator, std::basic_string::iterator, std::basic_string::iterator, )’”这里就需要将C++的函数强制改为C的（本是同根生，相煎何太急……）：transform(string.begin(), string.end(), string.begin(), ::tolower); 代码#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;string wrd, sen, st;int ans, wh, tmp;bool flag;//用于确定是否是第二次扫描int main()&#123; wh = 0x7f7f7f7f; getline(cin, wrd);//字符串读至行末回车 getline(cin, sen); transform(wrd.begin(), wrd.end(), wrd.begin(), ::tolower);//transform函数将所有字母转小写，包含于algorithm头文件 transform(sen.begin(), sen.end(), sen.begin(), ::tolower); int i = 0;//字符串从0开始 while (i &lt; sen.size()) &#123; if (sen[i] == ' ')//防止开头出现空格 &#123; i++; continue; &#125; st = sen.substr(i, wrd.size()); if (st == wrd &amp;&amp; (sen[i + wrd.size()] == ' ')) wh = min(wh, i), ans++, i += wrd.size();//第一次出现的序号一定最小，偷懒 else &#123; tmp = sen.find(' ', i);//从第i个位置开始找字符' ' if (tmp != -1) &#123; i = tmp + 1; continue; &#125; else &#123; if (!flag) flag = 1; else break; &#125; &#125; i++; &#125; if (!ans) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; wh &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1091」 合唱队形]]></title>
    <url>%2F2017%2F07%2F29%2F%E6%B4%9B%E8%B0%B7-1091%2F</url>
    <content type="text"><![CDATA[题外话最近都刷的什么垃圾题目啊……连我自己都不忍直视 题目链接洛谷 1091 题解在大意中已经写的很明显了，要求最少的不在原序列的元素个数。虽然读起来有些别扭，但仔细一想，可以转化成求最长符合条件的子序列的长度，再拿\(n\)减去该长度即可。再看题，符合条件的子序列是什么？满足“有且只有一个元素与其左边所有元素单调上升，与其右边所有元素单调下降”。明显是最长上升子序列和最长下降子序列的组合！我们可以把前\(i\)个元素变成一个序列并求最长上升子序列的长度，第\(i+1\)~第\(n\)个元素变成一个序列并求最长下降子序列的长度。设\(f(i)\)为取第\(i\)个元素的最长上升/下降子序列长度。得DP方程：\(f(i)=max(f(i),f(j)+1),\;a_i＜(＞)a_j,\,j&lt;i\) 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n, ans;int a[1001], f[1001];void ms()&#123; memset(f, 0, sizeof(f));&#125;bool judge(int op, int x, int y)&#123; if (!op) return x &gt; y; else return x &lt; y;&#125;int longest(int op, int x)&#123; //若op=0，则求最长上升子序列长度，否则求最长下降子序列长度。 //C++中语句连起来可以写成 S1, S2, S3;的形式。 int st, ed; if (!op) st = 1, ed = x; else st = x, ed = n; ms(); for (int i = st; i &lt;= ed; i++) &#123; f[i] = 1; for (int j = st; j &lt; i; j++) &#123; if (judge(op, a[i], a[j])) f[i] = max(f[i], f[j] + 1); &#125; &#125; int tmp = -0x7f7f7f7f; for (int i = st; i &lt;= ed; i++) tmp = max(tmp, f[i]); return tmp;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) ans = max(ans, longest(0, i) + longest(1, i+1)); cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 3371」 【模板】单源最短路径]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%B4%9B%E8%B0%B7-3371%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 3371 题解图的最短路有多种解法，如Dijkstra（贪心）、Floyed（DP），还有我们即将讨论的SPFA（BFS）。说SPFA是BFS也有些牵强。SPFA与BFS最大的区别就在于BFS某个结点只会访问一次，即出队列就不会二次进队，而SPFA则允许二次进队的情况出现。貌似唯一可能让顶点二次进队的情况只有一种：负环。这也是SPFA比其它两种最短路算法更优的原因（可判负环）。此外，SPFA也有DFS的。接下来讨论SPFA的操作步骤 SPFA 初始化（数组、源点）。 每次取出队首元素\(u\)，搜索以\(u\)为起点的每一条边\(e=(u,v)\) 若符合松弛条件，松弛； 否则继续循环。 当头指针=尾指针时结束循环。 代码#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct Edge&#123; int to, wei, next;&#125;edge[500001];int head[500001], dis[10001], q[10000001];int n, m, s, num_edge, a, b, c;bool vis[10001];void add(int a, int b, int c)&#123; edge[++num_edge].to = b; edge[num_edge].wei = c; edge[num_edge].next = head[a]; head[a] = num_edge;&#125;void spfa()&#123; memset(dis, 0x7f7f7f7f, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[s] = 0; vis[s] = true; int l = 1, r = 1; q[1] = s; while (l &lt;= r) &#123; int u = q[l]; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (dis[v] &gt; dis[u] + edge[i].wei) &#123; dis[v] = dis[u] + edge[i].wei; if (!vis[v]) &#123; q[++r] = v; vis[v] = true; &#125; &#125; &#125; vis[u] = false; l++; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; spfa(); for (int i = 1; i &lt;= n; i++) &#123; if (s == i) cout &lt;&lt; 0 &lt;&lt; ' '; else if (dis[i] == 0x7f7f7f7f) cout &lt;&lt; 2147483647 &lt;&lt; ' '; else cout &lt;&lt; dis[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 3366」 【模板】最小生成树]]></title>
    <url>%2F2017%2F07%2F24%2F%E6%B4%9B%E8%B0%B7-3366%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 3366 题解对于图\(G=(V,E)\)，最小生成树有两种较普遍的解法，即Kruskal算法和Prim算法。这里的程序采用Kruskal。接下来讨论Kruskal的操作步骤。 步骤 对于边集合\(E\)，按照边权从小到大排序。 对于\(m\)条边扫一遍。每次判断若加该边是否构成环： 若不构成，则最小生成树边数+1，权值和加上该边权值； 否则继续循环。 若最小生成树边数=图的顶点数-1，则输出权值和，否则输出orz。 这样Kruskal算法流程就结束了。下面对执行时的两个细节进行讨论。 细节 判断是否构成环。其实本步只需判断是否所加入的边\(e∈E\)的两个顶点\(u,v∈e\)是否在一集合里。想到集合，自然会想到并查集的实现。有关并查集，在此不赘述。 最小生成树的边数数一定是图（树）的顶点数-1。最小生成树的定义是：若图\(G=(V,E)\)是一个连通的无向图，则把它所有顶点\(V\)与部分边\(E’\)构成连通无环子图\(G’\)（图\(G\)的生成树），所有可能的生成树\(G’\)中边集\(E’\)中所有边的权值和最小的图\(G’\)称为图\(G\)的最小生成树。我们可以首先将图\(G’\)（最小生成树是一个图）连成一个环，最少需\(|V|\)条边。但如果仅需保证图是联通的，就有一条边是不必要的。所以最小生成树中有\(|V|-1\)条边。 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int ans, n, m, num_ans, tmp;int rt[500001];struct Edge&#123; int from, to, wei;&#125;edge[8000001];bool cmp(Edge a, Edge b)&#123; return a.wei &lt; b.wei;&#125;void init()&#123; for (int i = 1; i &lt;= n; i++) rt[i] = i;&#125;int getrt(int x)&#123; if (rt[x] == x) return x; else return rt[x] = getrt(rt[x]);&#125;void _union(int x, int y)&#123; rt[y] = x;&#125;void kruskal()&#123; sort(edge + 1, edge + m + 1, cmp); for (int i = 1; i &lt;= m; i++) &#123; int fr = getrt(edge[i].from), tr = getrt(edge[i].to); if (fr == tr) continue; else &#123; _union(fr, tr); ans += edge[i].wei; num_ans++; &#125; if (num_ans == n - 1) return; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].wei; &#125; init(); kruskal(); if (num_ans == n-1) cout &lt;&lt; ans; else cout &lt;&lt; "orz"; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 1020」 导弹拦截]]></title>
    <url>%2F2017%2F07%2F20%2F%E6%B4%9B%E8%B0%B7-1020%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 1020 题解这题分两问，在大意中已很明确地分析出来了。接下来，让我们分问题讨论。 第一问对于第一问，很显然是DP。设\(f(i)\)表示从\(1\)~\(i\)以\(i\)结尾（取\(i\)）的最长不上升子序列的最长长度\((i≤n)\)。由于是\(1\)~\(i\)这些导弹，所以有必要再加一层循环，判断第\(j\)发导弹是否能打。得DP方程： \(f(i)=max(f(i),f(j+1)),\;a_i≤a_j,\,j&lt;i\) 第二问第二问可以用贪心解决。一遍循环，将当前\(a_i,\,1≤i≤n\)与在数组\(ar\)中最小的不小于\(a_i\)的编号\(k\)与值记录下来，存入\(ar_k\)中。若无此值，则再加一个元素。最后统计\(ar\)数组元素个数即可。 代码#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int cnt = 0, _max, sum;int a[105], f[105], ar[105];int main()&#123; ios::sync_with_stdio(false);//cin、cout优化 while (cin &gt;&gt; a[++cnt]) ; cnt--; //求第一问 for (int i = 1; i &lt;= cnt; i++) &#123; f[i] = 1; for (int j = 1; j &lt; i; j++) &#123; if (a[i] &lt;= a[j]) f[i] = max(f[i], f[j] + 1); &#125; &#125; for (int i = 1; i &lt;= cnt; i++) _max = max(_max, f[i]); cout &lt;&lt; _max &lt;&lt; endl; //求第二问 for (int i = 1; i &lt;= cnt; i++) &#123; int wh = 0; _max = 0x7f7f7f7f; for (int j = 1; j &lt;= sum; j++) &#123; if (ar[j] &gt;= a[i] &amp;&amp; ar[j] &lt; _max) &#123; _max = ar[j]; wh = j; &#125; &#125; if (!wh) ar[++sum] = a[i]; else ar[wh] = a[i]; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[Blog致敬向所有程序员致敬！本站音乐播放器：APlayer，由DIYgod基于MIT License发布当时我听着目前的背景音乐，看到MIT License的全文，真的差点哭出来摘录MIT License原文： Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 是的，无限制这就是互联网精神向所有开源工作者致敬！ 简介基于Hexo搭建，使用NexT.Pisces主题，使用GitHub Pages托管网页。 个人信息即将初三，赴江苏省丹阳高级中学学习 操作系统Microsoft Windows 10 Enterprise IDEMicrosoft Visual Studio Enterprise 2017 编译器MinGW-W64VC++ 编辑器Notepad++Visual Studio Code]]></content>
  </entry>
</search>
