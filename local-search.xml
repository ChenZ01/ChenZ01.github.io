<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CodeTON Round 3</title>
    <link href="/2022/11/30/CodeTON-Round-3/"/>
    <url>/2022/11/30/CodeTON-Round-3/</url>
    
    <content type="html"><![CDATA[<p>最近太摆了，补题</p><span id="more"></span><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><a href="https://codeforces.com/contest/1750">CodeTON Round 3</a></p><h1 id="A-Indirect-Sort"><a href="#A-Indirect-Sort" class="headerlink" title="A - Indirect Sort"></a>A - Indirect Sort</h1><p>我们发现，$a_1$ 是不会增大的。故若 $a_1$ 不是最小值，不可能将 $\lbrace a\rbrace$ 变成不降的</p><p>而若 $a_1$ 是最小值，操作 2 就变成了交换 $a_j, a_k$，就是普通的 <code>swap</code> 操作，因而一定可以调整为不降的</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1750/submission/181368474">1750 A</a></p><h1 id="B-Maximum-Substring"><a href="#B-Maximum-Substring" class="headerlink" title="B - Maximum Substring"></a>B - Maximum Substring</h1><p>模拟即可</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1750/submission/181369084">1750 B</a></p><h1 id="C-Complementary-XOR"><a href="#C-Complementary-XOR" class="headerlink" title="C - Complementary XOR"></a>C - Complementary XOR</h1><p>注意到，每一次的操作会让全部的 $|a_i - b_i|$ 取反，这意味着如果初始状态 $|a_i - b_i|$ 不全都相等的话，不可能做到</p><p>方便起见，如果 $|a_i - b_i| &#x3D; 1$，进行一次操作，使得 $a_i &#x3D; b_i$</p><p>接下来进行 $n - 1$ 次操作让 $a_i$ 全部变得相等。此时会有四种情况：</p><ul><li>$a_i &#x3D; 1, b_i &#x3D; 0$</li><li>$a_i &#x3D; 1, b_i &#x3D; 1$</li><li>$a_i &#x3D; 0, b_i &#x3D; 0$</li><li>$a_i &#x3D; 0, b_i &#x3D; 1$</li></ul><p>操作方法显然，讨论一下即可</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1750/submission/181390387">1750 C</a></p><h1 id="D-Count-GCD"><a href="#D-Count-GCD" class="headerlink" title="D - Count GCD"></a>D - Count GCD</h1><p>显然 $b_1 &#x3D; a_1$</p><p>令 $f(i)$ 表示 $i$ - 前缀的答案，有 $f(1) &#x3D; 1$ 及转移</p><p>$$f(i) &#x3D; f(i - 1) \times g(i)\bmod p$$<br>其中 $g(i)$ 表示满足 $\gcd(x, a_{i - 1}) &#x3D; a_i$ 的 $x$ 的个数</p><p>由于一定有 $a_i | a_{i - 1}$，取 $q &#x3D; a_{i - 1} &#x2F; a_i$</p><ul><li>若 $q &#x3D; 1$，$g(i) &#x3D; \lfloor\dfrac{m}{a_i}\rfloor$</li><li>若 $q\neq 1$，则应满足 $x &#x3D; ka_i$，其中 $\gcd(k, q) &#x3D; 1, k\leq\lfloor\dfrac{m}{a_i}\rfloor$</li></ul><p>问题转化为求 $\left[1, \lfloor\dfrac{m}{a_i}\rfloor\right]$ 中与 $q$ 互质的数的个数</p><p>考虑容斥原理。得到 $q$ 的质因数后，使用二进制来枚举因数，使用 <code>popcount()</code> 来计算系数正负。以前没用过，看到二进制枚举豁然开朗</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><p>WA + RE 了 8 发，写在 Warnings 里面了</p><p><a href="https://codeforces.com/contest/1750/submission/182932701">1750 D</a></p><h1 id="Warnings"><a href="#Warnings" class="headerlink" title="Warnings"></a>Warnings</h1><ul><li>开 <code>long long</code></li><li>注意自己在 <code>init()</code> 里到底写了啥，这次是疯狂重复 Euler 筛</li><li>注意一些 Global Variable 的变化情况，这次是 <code>cntPrime</code> 疯狂变大导致 RE</li><li>当发现把数组开大就能多过几个原先 RE 的点时，注意自己数组访问的问题</li></ul><h1 id="Postscript"><a href="#Postscript" class="headerlink" title="Postscript"></a>Postscript</h1><p>R.I.P.</p><p>当我还是一名 OIer 的时候，玩的最多的就是膜蛤、续命、决赛圈的梗</p><p>熬过了地图头、送走了英女王，长者终于停下了已迈入决赛圈中的脚步</p><p>1926.08.17 - 2022.11.30</p><p>是谁禁止了军队经商<br>是谁平治了洪水汤汤<br>是谁稳定了通货膨胀<br>是谁坚持了改革开放<br>是谁任命了铁血宰相<br>是谁摧毁了邪教道场<br>是谁收回了澳门香港<br>是谁平息了金融巨浪<br>是谁加入了世界商贸<br>是谁提出了科教兴邦</p><p>苟利国家生死以，岂因祸福避趋之</p><p>功名半纸，风雪千山</p>]]></content>
    
    
    <categories>
      
      <category>ICPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Constructive Algorithms</tag>
      
      <tag>Greedy</tag>
      
      <tag>Number Theory</tag>
      
      <tag>Combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 830</title>
    <link href="/2022/10/29/Codeforces-Round-830/"/>
    <url>/2022/10/29/Codeforces-Round-830/</url>
    
    <content type="html"><![CDATA[<p>补题</p><span id="more"></span><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><a href="https://codeforces.com/contest/1732">Codeforces Round #830</a></p><h1 id="A-Bestie"><a href="#A-Bestie" class="headerlink" title="A - Bestie"></a>A - Bestie</h1><p>注意到 $\gcd(n, n + 1) &#x3D; 1, \forall n\in\mathbb{N}$，因此我们一定可以通过对第 $n - 1$ 项和第 $n$ 项进行操作从而使 $\gcd(a_{n - 1}, a_n) &#x3D; 1$</p><p>答案至多是 $1 + 2 &#x3D; 3$，需考虑仅对 $a_{n - 1}$ 或 $a_n$ 进行操作和初始 $\gcd_{i &#x3D; 1}^na_i &#x3D; 1$ 的情况</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1732/submission/177756987">1732 A</a></p><h1 id="B-Ugu"><a href="#B-Ugu" class="headerlink" title="B - Ugu"></a>B - Ugu</h1><p>从 B 开始，我的 Solution 和官方的 <a href="https://codeforces.com/blog/entry/108327">Tutorial</a> 就有很大差别了（</p><p>考虑 DP</p><p>注意到被反转偶数次等于未被反转，因而记录反转次数状态只需要记录 $0, 1$ 两种</p><p>令 $f(i, j, k)$ 表示前缀 $s_{1\dots i}$ 被改造为合法的，且以 $j &#x3D; 0, 1$ 为结尾、算上该次（可能没进行的）对后缀 $s_{i\dots n}$ 反转的反转次数为 $k &#x3D; 0, 1$ 的最小代价</p><p>转移显然，就是容易搞错情况，因为有些状态是不可能的<del>（为什么？）</del></p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1732/submission/178169630">1732 B</a></p><h1 id="C1-Sheikh-Easy-version"><a href="#C1-Sheikh-Easy-version" class="headerlink" title="C1 - Sheikh (Easy version)"></a>C1 - Sheikh (Easy version)</h1><p>记 $s$ 为异或和</p><p>注意到，任何正整数对和的贡献恒大于等于对异或和的贡献。形式化地，$x\geq |s - (s\oplus x)|$。因而我们只会去删掉那些贡献相等的数，否则一定会使 $f$ 变小。而 $f$ 值一定是 $\text{sum}(l, r) - \text{xor}(l, r)$</p><p>注意到丢掉的 $a_i$ 会对异或和有影响，因而 two-pointers 扫描</p><p>具体而言，先确定左边删去个数最多的情况，然后不断减少左边删去的个数从而使右边删去的个数相应增加。综合所有情况取最值</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1732/submission/178635415">1732 C1</a></p><h1 id="C2-Sheikh-Hard-version"><a href="#C2-Sheikh-Hard-version" class="headerlink" title="C2 - Sheikh (Hard version)"></a>C2 - Sheikh (Hard version)</h1><p>记 $s$ 为异或和</p><p>回到异或运算的性质上来。我们发现，满足条件的 $x$，即满足 $x &#x3D; s - s\oplus x$ 的 $x$，其二进制表示中的位和 $s$ 相应的位一定相同</p><p>那么缩小 $[l, r]$ 的过程，可以视作将 $s$ 中为 $1$ 的位不断删去，且 $s$ 能删去某些 $1$ 的位当且仅当 $x$ 的二进制表示如此</p><p>最坏情况是待删除的 $x_{(2)}$ 为 $1, 10, 100, 1000, \cdots$ 且 $s_{(2)} &#x3D; 111\cdots$，而 $\log_2 10^9\le 31$，故复杂度实际上还是 $O(n)$ <del>只是常数 31 比较感人</del></p><p>不过 TLE 了，原因在于 $x &#x3D; 0$ 的情况。一堆 $0$ 会使复杂度变成 $O(n^2)$，去掉 $0$ 即可。这个过程与离散化微妙地相似</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1732/submission/179390024">1732 C2</a></p><h1 id="D1-Balance-Easy-version"><a href="#D1-Balance-Easy-version" class="headerlink" title="D1 - Balance (Easy version)"></a>D1 - Balance (Easy version)</h1><p>大暴力，过的人比 C1 还多就离谱</p><p>记 $f(k)$ 为所求，将 $f$ 存下来，以后再求 $k$ 就能从 $f(k)$ 开始找了</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1732/submission/179424554">1732 D1</a></p>]]></content>
    
    
    <categories>
      
      <category>ICPC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Global Round 23</title>
    <link href="/2022/10/22/Codeforces-Global-Round-23/"/>
    <url>/2022/10/22/Codeforces-Global-Round-23/</url>
    
    <content type="html"><![CDATA[<p>Codeforces 下分计划 绝赞进行中</p><span id="more"></span><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><a href="https://codeforces.com/contest/1746">Codeforces Global Round 23</a></p><h1 id="A-Maxmina"><a href="#A-Maxmina" class="headerlink" title="A - Maxmina"></a>A - Maxmina</h1><p>构造</p><p>全 $0$ 则结论平凡 <del>你在哪学的这种数学教材风啊</del></p><p>若有一个 $1$，则一定可以通过不断执行操作 1，将 $n$ 个数减少到 $k$ 个。最后执行操作 2 即可</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1746/submission/176683270">1746 A</a></p><h1 id="B-Rebellion"><a href="#B-Rebellion" class="headerlink" title="B - Rebellion"></a>B - Rebellion</h1><p>贪心</p><p>最后一定会成为 $0..01…1$，我们只需要将最后的 $0$ 与最前的 $1$ 不断对调即可</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1746/submission/176763960">1746 B</a></p><h1 id="C-Permutation-Operations"><a href="#C-Permutation-Operations" class="headerlink" title="C - Permutation Operations"></a>C - Permutation Operations</h1><p>差分，构造</p><p>区间修改、对于单调性的判断一定要往差分上面多想想 <del>别老惦记着你那 BIT   逆序对了</del></p><p>令 $d_i &#x3D; a_{i + 1} - a_i$</p><p>改造成递增序列意味着 $d_i$ 均非负，后缀 $[i, n]$ 全部增加 $x$ 意味着 $d_{i - 1}$ 加上 $x$ 且 $\lbrace d\rbrace$ 中其余元素不变</p><p>因此注意到，我们第 $i$ 次的操作就是给 $\lbrace d\rbrace$ 中 $n - 1$ 个元素中的某一个加上 $i$，由于 $\lbrace a\rbrace$ 是 $n$ 排列，最极端情况下 $\lbrace d\rbrace$ 是 $n - 1$ 排列，因此我们一定能构造出这样的一组解：</p><p>对于 $a_i$，有 $d_{i - 1} &#x3D; a_i - a_{i - 1} &gt; a_{i - 1}$，故在 $[i, n]$ 后缀加上 $a_{i - 1}$ 即可使得 $d_{i - 1} &gt; 0$</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1746/submission/177013198">1746 C</a></p><h1 id="D-Paths-on-the-Tree"><a href="#D-Paths-on-the-Tree" class="headerlink" title="D - Paths on the Tree"></a>D - Paths on the Tree</h1><p>树形 DP</p><p>由题意，一个具有 $s$ 个儿子、能够提供 $p$ 条 path 的结点，每个儿子分配到的 path 应该有 $\lfloor\dfrac{p}{s}\rfloor$ 或 $\lfloor\dfrac{p}{s}\rfloor + 1$ 条</p><p>考虑令 $f(u, p)$ 表示以 $u$ 为父结点的树、分配 $p$ 条 path 能获得的最大值，DP 即可</p><p>奇怪的是，我脑抽觉得一个 $(u, p)$ 只可能访问一次，没有返回记忆化的值。这种想当然的错误已经在 ICPC 里面犯过一次了（那次是觉得答案不可能超，没取模）</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1746/submission/177467112">1746 D</a></p>]]></content>
    
    
    <categories>
      
      <category>ICPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Constructive Algorithms</tag>
      
      <tag>Greedy</tag>
      
      <tag>Two Pointers</tag>
      
      <tag>DP</tag>
      
      <tag>Tree</tag>
      
      <tag>Implementation</tag>
      
      <tag>Difference</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GSS1</title>
    <link href="/2022/08/23/GSS1/"/>
    <url>/2022/08/23/GSS1/</url>
    
    <content type="html"><![CDATA[<p>GSS 系列本来在换电脑前就打算完成的，但由于当时我本人也是一知半解，没有底气与实力写 blog，遂弃置至今</p><span id="more"></span><p>考上 ZJU后，重新开始的 blog 以此为开头，也算是有些许意义</p><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><a href="https://www.spoj.com/problems/GSS1/">SPOJ GSS1</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定长度为 $n$ 的序列，回答 $m$ 个询问 $[x, y]$，要求出 $[x, y]$ 的最大子串和</p><p>这里用了<strong>子串</strong>来与<strong>子序列</strong>进行区分</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>区间查询，考虑线段树 <del>据说可以用猫树做，但我不会，咕了</del><br>因而我们应该考虑如何将 father 线段上的问题分割给两个 son 线段来处理</p><p>考察符合要求的子串 $[l, r]$ 在 father 区间 $[L, R]$ 的位置，只有以下三种情况</p><ul><li>$[l, r]$ 在 $[L, R]$ 左半边</li><li>$[l, r]$ 在 $[L, R]$ 右半边</li><li>$[l, r]$ 跨过 $[L, R]$ 中间</li></ul><p>三种情况取 max 即可，接下来便考虑如何计算这三种情况的答案</p><h3 id="左右半边"><a href="#左右半边" class="headerlink" title="左右半边"></a>左右半边</h3><p>直接返回 lson &#x2F; rson 的 max 即可，相当于规模减半的子问题</p><h3 id="跨中间"><a href="#跨中间" class="headerlink" title="跨中间"></a>跨中间</h3><p>答案为左区间后缀和最大值（可能取最大值时子串长度为0） + 右区间前缀和最大值（同理可能不选右区间元素）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线段树的 node 需要维护前缀和、后缀和、子串和最大值，不难发现还需要维护区间所有值的和，易在 <code>pushUp()</code> 中维护</p><p>这样我们有了一份很朴实的 <code>query()</code> 想法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span></span><br><span class="hljs-function"></span>&#123;<br>    S[rt] = S[rt &lt;&lt; <span class="hljs-number">1</span>] + S[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>    L[rt] = <span class="hljs-built_in">max</span>(L[rt &lt;&lt; <span class="hljs-number">1</span>], S[rt &lt;&lt; <span class="hljs-number">1</span>] + L[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>    R[rt] = <span class="hljs-built_in">max</span>(R[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>], S[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] + R[rt &lt;&lt; <span class="hljs-number">1</span>]);<br>    M[rt] = <span class="hljs-built_in">max</span>(M[rt &lt;&lt; <span class="hljs-number">1</span>], <span class="hljs-built_in">max</span>(M[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>], R[rt &lt;&lt; <span class="hljs-number">1</span>] + L[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (m &gt;= qr)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt &lt;&lt; <span class="hljs-number">1</span>, l, m);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &lt; ql)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr)<br>        <span class="hljs-keyword">return</span> M[rt];<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query</span>(rt &lt;&lt; <span class="hljs-number">1</span>, l, m), <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query</span>(rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r), R[rt &lt;&lt; <span class="hljs-number">1</span>] + L[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就在 master test 中 T 了……</p><h3 id="Optimize"><a href="#Optimize" class="headerlink" title="Optimize"></a>Optimize</h3><p>显然我们这个 <code>query()</code> 写的太暴力了，考虑优化掉一些</p><p>考虑到线段树统计答案的顺序，一定是 lson -&gt; rson -&gt; father，这使得 lson 的后缀和最大值可以被 father 计算时利用，改造一下 <code>query()</code> 即可</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-type">int</span> neg = <span class="hljs-number">0</span>;<br>    x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getchar</span>())<br>        neg |= (c == <span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isdigit</span>(c); c = <span class="hljs-built_in">getchar</span>())<br>        x = x * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (neg)<br>        x = -x;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T x, T y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt; y)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-type">int</span> n, m, ql, qr, ans, rans;<br><span class="hljs-type">int</span> a[<span class="hljs-number">50010</span>];<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> M[<span class="hljs-number">200010</span>], L[<span class="hljs-number">200010</span>], R[<span class="hljs-number">200010</span>], S[<span class="hljs-number">200010</span>];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span></span><br><span class="hljs-function">    </span>&#123;<br>        S[rt] = S[rt &lt;&lt; <span class="hljs-number">1</span>] + S[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>        L[rt] = <span class="hljs-built_in">max</span>(L[rt &lt;&lt; <span class="hljs-number">1</span>], S[rt &lt;&lt; <span class="hljs-number">1</span>] + L[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>        R[rt] = <span class="hljs-built_in">max</span>(R[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>], S[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] + R[rt &lt;&lt; <span class="hljs-number">1</span>]);<br>        M[rt] = <span class="hljs-built_in">max</span>(M[rt &lt;&lt; <span class="hljs-number">1</span>], <span class="hljs-built_in">max</span>(M[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>], R[rt &lt;&lt; <span class="hljs-number">1</span>] + L[rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r)<br>        &#123;<br>            M[rt] = L[rt] = R[rt] = S[rt] = a[l];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">build</span>(rt &lt;&lt; <span class="hljs-number">1</span>, l, m);<br>            <span class="hljs-built_in">build</span>(rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-built_in">pushUp</span>(rt);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">max</span>(M[rt], rans + L[rt]));<br>            rans = <span class="hljs-built_in">max</span>(R[rt], rans + S[rt]);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (ql &lt;= m)<br>                <span class="hljs-built_in">query</span>(rt &lt;&lt; <span class="hljs-number">1</span>, l, m);<br>            <span class="hljs-keyword">if</span> (m &lt; qr)<br>                <span class="hljs-built_in">query</span>(rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r);<br>        &#125;<br>    &#125;<br>&#125;;<br><br>SegmentTree sgt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-built_in">read</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-built_in">read</span>(a[i]);<br>    &#125;<br>    sgt.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">read</span>(m); m; --m)<br>    &#123;<br>        <span class="hljs-built_in">read</span>(ql); <span class="hljs-built_in">read</span>(qr);<br>        ans = rans = <span class="hljs-number">-0x7f7f7f7f</span>;<br>        sgt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>        std::cout &lt;&lt; ans &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ICPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Segment Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
