{"pages":[{"title":"About","text":"世界、俯いちゃう前にキュッとしちゃった心の音をどうぞ。まだまだ忘れないわ。 The Cruel World TOUHOU、Arknights、Portal玩家 High School Grade 1 永远感谢Yirannn 我们所可以自慰的，想来想去，也还是所谓对于将来的希望。希望是附丽于存在的，有存在，便有希望，有希望，便是光明。 所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Friends","text":"按照字典序排序 Name Chhokmah Enderturtle FFjet FlyInTheSky LJC00118 Logey M_sea memset0 redbag SiriusRen Studying Father Yirannn","link":"/friends/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"「AtCoder Beginner Contest 117」","text":"Digression远坂凛生日快乐！到现在仍然对中日时差表示困惑，网站上写的是北京时间还是东京时间我也弄不清…… TasksA - Entrance ExaminationAnalysis输出$T/X$即可 Code1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstdio&gt;char ch;template &lt;typename T&gt;void read(T&amp; x){ x = 0; ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}double n, m;int main(){ read(n), read(m); printf(&quot;%.10f\\n&quot;, n / m); return 0;} B - PolygonAnalysis根据给出的Theorem，最长边$l_i\\leq \\sum l - l_i$，故$l_j&lt;\\sum l - l_j(j\\ne i)$ Code某些函数略 12345678910111213141516int n, s, ans = 1;int a[1000010];int main(){ read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]), s += a[i]; for (int i = 1; i &lt;= n; ++i) ans &amp;= (a[i] &lt; s - a[i]); if (ans) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); return 0;} C - StreamlineAnalysis从C题开始比较有意思首先我们一定会把这$n$个pieces放在某一个$X_i$上显然当$n\\geq m$时，答案为$0$接下来我们考虑放置一个piece对于答案的影响：放置一个piece必定会使我们少走一段$X_i - X_{i - 1}$的距离（即某两个相邻coordinates中间那段距离就不用再走了）故考虑贪心，将所有$X_i - X_{i - 1}$排序 Code这里特意把read()放出来，因为坐标可能为负 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;char ch;template &lt;typename T&gt;void read(T&amp; x){ x = 0; ch = getchar(); int minus = 0; for (; !isdigit(ch); minus |= (ch == '-'), ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar()); if (minus) x = -x;}int n, m, ans, s;int a[1000010], d[1000010];int main(){ read(n), read(m); for (int i = 1; i &lt;= m; ++i) read(a[i]); if (n &gt;= m) { printf(&quot;0\\n&quot;); return 0; } std::sort(a + 1, a + m + 1); for (int i = 1; i &lt; m; ++i) d[i] = a[i + 1] - a[i], s += d[i]; std::sort(d + 1, d + m); for (int i = m - 1, cnt = 1; i &amp;&amp; cnt &lt; n; --i, ++cnt) ans += d[i]; printf(&quot;%d\\n&quot;, s - ans); return 0;} D - XXORAnalysis先将$\\lbrace A_n\\rbrace$全部转二进制，位数不足补前导零，设最大位数为$l$，$x$同题意，$A_{ij}$表示第$i$个数二进制表示的第$j$位（$0$或$1$），从$0$位开始std::bitset大法吼啊然后考虑异或运算的性质：对于二进制的某一位，异或$0$不变，异或$1$取反那么：若改变$A$中全部元素的第$j$位比不改变更优，则$x$的第$j$位为$1$，否则为$0$显然改变更优的充要条件为$\\sum{A_{ij}} &lt; n - \\sum{A_{ij}}$又：若确定$x$的第$j$位为$1$，则$x$会增加$2 ^ j$，同时答案增加$2^j\\cdot(n-2\\cdot\\sum A_{ij})$也就是说：我们有至多$\\log_2k$个选择，每个选择会贡献$2^j\\cdot(n-2\\cdot\\sum A_{ij})$，并使$x$增加$2^j$这不是01背包吗！！？然而$K$过大，否决由于$\\log_2k$不大，考虑暴搜TLE……一看只T了3个点，剪枝！设当前搜到第$dep$个选择，总贡献为$val$，总增量为$cost$考虑到$\\sum_{i = 1} ^ j 2 ^ i= 2 ^ {j + 1} - 1$，我们发现若当前搜到的$val$加上$2^{dep + 1}$仍不如当前最优解的话可直接剪去若搜索顺序为$0$到$l$则剪枝无法进行，故顺序应为$l$到$0$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061long long n, k, rec, s, ans, szeK;long long a[100010], tot[100010], cst[100010], f[1010010];std::bitset &lt;110&gt; b[100010];void dfs(int dep, long long val, long long cost){ if (dep &lt; 0) { ans = std::max(ans, val); return; } if (val + f[dep + 1] &lt; ans) return; if (cst[dep] &amp;&amp; cost + cst[dep] &lt;= k) dfs(dep - 1, val + tot[dep], cost + cst[dep]); dfs(dep - 1, val, cost);}int getSize(long long x){ int ret = 0; while (x) ++ret, x &gt;&gt;= 1; return ret;}int main(){ f[0] = 1; for (int i = 1; i &lt;= 60; ++i) f[i] = f[i - 1] * 2; read(n), read(k); for (int i = 1; i &lt;= n; ++i) read(a[i]), s += a[i]; std::sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) b[i] = a[i]; for (int i = b[n].size() - 1; ~i; --i) if (b[n][i]) { rec = i; break; } if (getSize(k) - 1 &gt; rec) rec = getSize(k) - 1; for (long long i = rec; ~i; --i) { for (int j = 1; j &lt;= n; ++j) tot[i] += b[j][i]; } for (int i = 0; i &lt;= rec; ++i) { if (tot[i] &lt; n - tot[i]) tot[i] = f[i] * (n - 2 * tot[i]), cst[i] = f[i]; else tot[i] = 0; } dfs(rec, 0, 0); std::cout &lt;&lt; s + ans &lt;&lt; std::endl; return 0;}","link":"/2019/02/03/ABC-117/"},{"title":"「AtCoder Beginner Contest 121」 D - XOR World","text":"这回连C都省掉了 Analysis观察异或运算$\\oplus$的性质 $\\forall n = 2k, k\\in \\mathbb{N}, n \\oplus (n + 1) = 1$ $\\forall n \\in \\mathbb{N}, n \\oplus n = 0$ 因此有$F(A, B) = F(0, A - 1) \\oplus F(0, B)$将$F(0, n)$写成如下形式$$\\begin{aligned}F(0, n) &amp;= 0 \\oplus 1\\oplus 2\\oplus 3\\dots (n - 1)\\oplus n \\notag \\\\&amp;= (0 \\oplus 1) \\oplus (2 \\oplus 3)\\dots \\notag \\\\\\end{aligned}$$判断$n$的奇偶计算即可 Code12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;long long a, b;long long f(long long x){ if (x &amp; 1) return (x + 1) / 2 % 2; else return (x / 2 % 2) ^ x;}int main(){ std::cin &gt;&gt; a &gt;&gt; b; std::cout &lt;&lt; (f(a - 1) ^ f(b)) &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2019/03/11/ABC-121-D/"},{"title":"「AtCoder Beginner Contest 125」","text":"TasksC - GCD on BlackboardAnalysis令$l(i) = \\mathrm{gcd}_{j\\le i}a_j$，$r(i) = \\mathrm{gcd}_{j \\ge i}a_j$，则显然答案为$\\max_{i}\\lbrace \\gcd(l(i - 1), r(i + 1))\\rbrace$ Code123456789101112131415161718192021222324252627constexpr static int ___maxN = 100010;int gcd(int x, int y){ return y ? gcd(y, x % y) : x;}int n, ans;int a[___maxN], l[___maxN], r[___maxN];int main(){ std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) l[i] = ::gcd(l[i - 1], a[i]); for (int i = n; i; --i) r[i] = ::gcd(r[i + 1], a[i]); for (int i = 1; i &lt;= n; ++i) ans = std::max(ans, ::gcd(l[i - 1], r[i + 1])); std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} D - Flipping SignsAnalysis我们发现负号可以任意移动。比如$a, -b, c$可以变为$-a, b, c$和$a, b, -c$那么我们将负号全部挪到一起，再2个2个消去，可知如果负号的个数为偶数则可以将整个数列全部变成正的否则将负号移动到绝对值最小的那个数上即可 Code123456789101112131415161718192021222324int n, cntMinus;int a[1000010];long long ans;int main(){ std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i], cntMinus += a[i] &lt;= 0; if (cntMinus % 2) { int _min = 0x7f7f7f7f; for (int i = 1; i &lt;= n; ++i) ans += a[i] &gt; 0 ? a[i] : -a[i], _min = std::min(_min, a[i] &gt; 0 ? a[i] : -a[i]); ans -= 2 * 1ll * _min; } else for (int i = 1; i &lt;= n; ++i) ans += a[i] &gt; 0 ? a[i] : -a[i]; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/05/19/ABC-125/"},{"title":"「AtCoder Beginner Contest 120」","text":"Tasks我估计以后ABC的A和B都会被我省掉 C - UnificationAnalysis考虑到如果一个序列存在$0$和$1$，怎么搞都能消掉它们那么答案就是$0$和$1$的个数取最小值即可 Code123while (isdigit(ch = getchar())) a[++n] = ch ^ 48, cntZero += a[n] == 0, cntOne += a[n];std::cout &lt;&lt; std::min(cntOne, cntZero) * 2 &lt;&lt; &quot;\\n&quot;; D - Decayed BridgesAnalysis考虑离线倒着做令第$i$个bridge collapses后的答案为$f(i)$，显然有$f(m) = \\frac{n(n - 1)}{2}$倒着考虑，假设一开始bridge全没了，我们一个个加上，则$f(i)$即为加了$i$到$m$这么多边后的答案接下来加bridge $e_i = (a_i, b_i)$，存在两种情况 本来这两个就连通，$f(i) = f(i + 1)$ 这两个不连通，$f(i) = f(i + 1) - N_1 \\cdot N_2$，其中$N_1, N_2$分别表示两个island所处连通块的大小 Union-Find Set实现，注意long long Code1234567891011121314151617181920212223242526272829303132int getRoot(int x){ return x == root[x] ? x : root[x] = getRoot(root[x]);}int main(){ std::ios::sync_with_stdio(0); std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) std::cin &gt;&gt; a[i] &gt;&gt; b[i]; for (int i = 1; i &lt;= n; ++i) root[i] = i, size[i] = 1; ans[m + 1] = n * (n - 1) / 2; for (int i = m; i &gt; 1; --i) { int x = getRoot(a[i]), y = getRoot(b[i]); if (x == y) ans[i] = ans[i + 1]; else { ans[i] = ans[i + 1] - size[x] * size[y]; size[x] += size[y]; size[y] = 0; root[y] = x; } } for (int i = 2; i &lt;= m + 1; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2019/03/08/ABC-120/"},{"title":"「AtCoder Beginner Contest 126」","text":"ABC的题量突然增多了……向ARC看齐了？ TasksC - Dice and CoinAnalysis从来没有做过概率题的ChenZ01表示很慌……仔细一想这不跟GCJ 2008 APAC C几乎一样么……注意一下概率均要乘上$1 / n$首先考虑点数为$d \\ge K$的情况，这就不用掷第二遍了，$P(d) = 1$然后我们考虑$d &lt; K$的情况，不难发现$d\\ge\\lceil k / 2\\rceil$时概率为$1 / 2$，其余情况$P(d) = 1 / 2 * P(2d)$ Code123456789101112131415161718192021int n, k;long double f[3000010]; int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; k; for (int i = k / 2 + k % 2; i &lt; k; ++i) f[i] = 0.5; for (int i = k; i &lt;= n; ++i) f[i] = 1; for (int i = k / 2 + k % 2 - 1; i; --i) { f[i] = 0.5 * f[i * 2]; } long double ans = 0; for (int i = 1; i &lt;= n; ++i) ans += f[i]; printf(&quot;%.12Lf\\n&quot;, ans / (long double)n); return 0;} D - Even RelationAnalysis令$1$为root，直接将其染黑/白，根据边奇偶对子节点染色即可容易验证这样构造出来的一定没问题 Code1234567891011121314151617181920212223242526272829303132333435363738394041struct Edge{ int v, w; Edge(int v = 0, int w = 0) : v(v), w(w) {}}; int n;int c[100010];std::vector &lt;Edge&gt; t[100010]; void dfs(int x, int fr, int col){ c[x] = col; for (auto i : t[x]) { int v = i.v; if (v == fr) continue; if (i.w % 2) // Odd dfs(v, x, !col); else dfs(v, x, col); }} int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt; n; ++i) { int u = 0, v = 0, w = 0; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; t[u].push_back(Edge(v, w)); t[v].push_back(Edge(u, w)); } dfs(1, 0, 0); // Black for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; c[i] &lt;&lt; std::endl; return 0;} E - 1 or 2Analysis考虑若$A_x$与$A_y$被直接或间接的fact涉及，则我们知道$A_x$则一定能知道$A_y$并查集处理即可比赛时思路比较乱就写了个连边求连通块个数的，实质就是并查集 Code这是比赛脑抽连边的版本 1234567891011121314151617181920212223242526272829303132333435363738int n, m, cnt;int vis[100010];std::vector &lt;int&gt; rela[100010]; void dfs(int x){ vis[x] = 1; for (auto i : rela[x]) { if (!vis[i]) dfs(i); }} int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { int x = 0, y = 0, z = 0; std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; rela[x].push_back(y), rela[y].push_back(x); } int ans = 0; for (int i = 1; i &lt;= n; ++i) { if (!vis[i]) { if (rela[i].size()) ++ans, dfs(i); else ++ans; } } std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} F - XOR MatchingAnalysis感谢FlyInTheSky聚聚的Construction，其实本题不止一种构造方法判断完后构造即可存在性只需判断除$k$以外全部数的异或和是否为$0$ Code1234567891011121314151617181920212223242526272829// Construct [k, 0, 1, ..., k - 1, k + 1, ..., 2 ^ m, k, 2 ^ m, ..., k + 1, k - 1, ..., 2, 1, 0]int m, k; int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; m &gt;&gt; k; if (k == 0) { for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot;; return 0; } int s = 0; for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) if (i != k) s ^= i; if (s != k) return (std::cout &lt;&lt; -1 &lt;&lt; std::endl), 0; std::cout &lt;&lt; k &lt;&lt; &quot; &quot;; for (int i = 0; i &lt; (1 &lt;&lt; m); ++i) if (i != k) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; std::cout &lt;&lt; k &lt;&lt; &quot; &quot;; for (int i = (1 &lt;&lt; m) - 1; ~i; --i) if (i != k) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; return 0;}","link":"/2019/05/20/ABC-126/"},{"title":"「AtCoder Beginner Contest 133」","text":"神FFjet带窝上分 TasksB - Good DistanceAnalysis按题意模拟 Code12345678910111213141516171819202122232425int n, d, ans;long long a[20][20];int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; d; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= d; ++j) std::cin &gt;&gt; a[i][j]; for (int i = 1; i &lt; n; ++i) { for (int j = i + 1; j &lt;= n; ++j) { long long s = 0; for (int k = 1; k &lt;= d; ++k) s += (a[i][k] - a[j][k]) * (a[i][k] - a[j][k]); if ((int)std::sqrt(s) * (int)std::sqrt(s) == s) ++ans; } } std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} C - Remainder Minimization 2019Analysis首先有$2019 = 3 \\times 673$考虑到如果$[l, r]$中有$673$的倍数与$3$的倍数答案就为$0$，若区间长度$r - l + 1 \\ge 673$我们可以直接输出$0$. 否则区间长度很小，直接暴力求解 Code思路混乱的考场上区间长度搞不清 12345678910111213141516171819202122int l, r;long long ans = 0x7f7f7f7f;int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; l &gt;&gt; r; if (r - l &gt;= 673) std::cout &lt;&lt; 0 &lt;&lt; std::endl; else { for (int i = l; i &lt; r; ++i) { for (int j = i + 1; j &lt;= r; ++j) { ans = std::min(1ll * i * 1ll * j % 2019, ans); } } std::cout &lt;&lt; ans &lt;&lt; std::endl; } return 0;} D - Rain Flows into DamsAnalysis列方程$$\\begin{cases} (a_1 + a_2) / 2 = A_1 &amp;(1)\\\\ (a_2 + a_3) / 2 = A_2 &amp;(2)\\\\ \\cdots \\\\ (a_n + a_1) / 2 = A_n &amp;(n)\\end{cases}$$将偶数编号方程乘上$-1$，将前$n - 1$个方程相加得到$$(a_1 - a_n) / 2 = \\sum_{i = 1} ^ {n - 1}A_i$$与第$n$个方程相加得到$a_1$, 依次带入方程消元 Code1234567891011121314151617181920212223242526int n;long long a[1000010], A[1000010];int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { std::cin &gt;&gt; a[i]; } long long s = 0; for (long long i = 1, minus = 1; i &lt; n; ++i) { s += minus * a[i]; minus = -minus; } A[1] = a[n] + s; for (int i = 2; i &lt;= n; ++i) { A[i] = 2 * a[i - 1] - A[i - 1]; } for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;; return 0;} E - Virus Tree 2Analysis记节点$i$放置的方案数为$\\binom{c_i}{1}$我们先考虑对根节点$1$染色, 显然有$c_1 = k$接着考虑$1$的子节点. 不难发现其第一个子节点有$c= k - 1$, 其第二个子节点有$c = k - 2$, 以此类推得到$1$的所有子节点的$c$值接下来考虑$1$的子节点的子节点. 显然对于$1$的某个子节点的第一个子节点有$c = k - 2$, 第二个有$c = k - 3$. 且我们注意到$1$的任意两个子节点的任意两个子节点不会互相影响故有结论: 对于深度大于$2$的 (根节点深度为$1$) 节点, 有最左边的节点$c$值为$k - 2$, 其兄弟节点 (父节点相同) 的$c$值递减. 不为兄弟节点的深度相同的节点由于互不影响, 再从$c = k - 2$重新对新的一部分进行求值答案即为$$\\prod_i \\binom{c_i}{1}$$ Code123456789101112131415161718192021222324252627282930313233int n, k, u, v;int c[100010];std::vector &lt;int&gt; g[100010];void dfs(int x, int fr){ int cnt = 0; for (auto i : g[x]) if (i != fr) { c[i] = k - 2 - (cnt++); dfs(i, x); }}int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt; n; ++i) std::cin &gt;&gt; u &gt;&gt; v, g[u].push_back(v), g[v].push_back(u); c[1] = k; for (int i = 0, lim = g[1].size(); i &lt; lim; ++i) c[g[1][i]] = k - (i + 1), dfs(g[1][i], 1); long long ans = 1; for (int i = 1; i &lt;= n; ++i) { (ans *= 1ll * c[i]) %= 1000000007; } std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} F - Colorful Tree咕咕咕, 等FFjet巨巨教窝QwQ","link":"/2019/07/08/ABC-133/"},{"title":"「AHOI2013」 差异","text":"Solution显然$\\sum_{1\\le i&lt;j\\le n}\\mathrm{len}(T_i) + \\mathrm{len}(T_j) = (n - 1)n(n + 1) / 2$，故我们只需求每对后缀的$\\mathrm{lcp}$即可观察到$\\mathrm{lcp}$的前缀和具有单调性，故单调栈维护即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;struct SuffixArray{ std::string st = &quot;&quot;; int len = 0, size = 0; int bucket[1000010], pos[1000010], sa[1000010], rank[1000010], height[1000010]; // Each array starts from 1 void radixSort() { for (int i = 1; i &lt;= size; ++i) bucket[i] = 0; for (int i = 1; i &lt;= len; ++i) ++bucket[rank[i]]; for (int i = 1; i &lt;= size; ++i) bucket[i] += bucket[i - 1]; for (int i = len; i; --i) sa[bucket[rank[pos[i]]]--] = pos[i]; } void getSA() { for (int i = 1; i &lt;= len; ++i) rank[i] = st[i], pos[i] = i; radixSort(); for (int w = 1, p = 0; p &lt; len &amp;&amp; w &lt;= len; size = p, w &lt;&lt;= 1) { p = 0; for (int i = len - w + 1; i &lt;= len; ++i) pos[++p] = i; for (int i = 1; i &lt;= len; ++i) if (sa[i] &gt; w) pos[++p] = sa[i] - w; radixSort(); std::swap(rank, pos); rank[sa[1]] = p = 1; for (int i = 2; i &lt;= len; ++i) rank[sa[i]] = pos[sa[i]] == pos[sa[i - 1]] &amp;&amp; pos[sa[i] + w] == pos[sa[i - 1] + w] ? p : ++p; } } void getHeight() { int j = 0, k = 0; for (int i = 1; i &lt;= len; ++i) { if (k) --k; j = sa[rank[i] - 1]; while (st[i + k] == st[j + k]) ++k; height[rank[i]] = k; } } void main(std::string __st, int __size = 127) { st = __st, len = st.length() - 1, size = __size; getSA(), getHeight(); }};struct Data{ int val, pos; Data(int val = 0, int pos = 0) : val(val), pos(pos) {}};std::string st;SuffixArray SA;long long f[1000010];int main(){ std::cin &gt;&gt; st; int n = st.length(), del = 0; st = ' ' + st; SA.main(st); long long ans = (long long)(n + 1) * n * (n - 1) / 2; std::stack &lt;Data&gt; stack; for (int i = 1; i &lt;= n; ++i) { while (stack.size() &amp;&amp; stack.top().val &gt;= SA.height[i]) stack.pop(); if (stack.size()) f[i] = f[stack.top().pos] + (i - stack.top().pos) * SA.height[i]; else f[i] = i * SA.height[i]; stack.push(Data(SA.height[i], i)); } for (int i = 1; i &lt;= n; ++i) ans -= 2 * f[i]; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/05/07/AHOI2013-%E5%B7%AE%E5%BC%82/"},{"title":"「APIO2009」 抢掠计划","text":"弃Tarjan拥抱Kosaraju Solution强连通分量缩点，标记一下缩点后的哪些点有酒吧，跑最长路由于Kosaraju算法处理后的图顶点编号就是拓扑序 (好评！)，直接DP即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071constexpr static int ___maxN = 500010;int n, m, u, v, top, cntSCC, s, p;int vis[___maxN], stack[___maxN], belong[___maxN], moneyCross[___maxN], tagCross[___maxN], tag[___maxN], money[___maxN], f[___maxN];std::vector &lt;int&gt; g[___maxN], rG[___maxN];std::map &lt;int, int&gt; connected[___maxN];void dfs(int x){ vis[x] = 1; for (auto i : g[x]) if (!vis[i]) dfs(i); stack[++top] = x;}void rDFS(int x){ vis[x] = 1, belong[x] = cntSCC; for (auto i : rG[x]) if (!vis[i]) rDFS(i);}void SCC(){ for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i); memset(vis, 0, sizeof vis); for (int i = n; i; --i) if (!vis[stack[i]]) ++cntSCC, rDFS(stack[i]);}int main(){ read(n, m); for (int i = 1; i &lt;= m; ++i) read(u, v), g[u].push_back(v), rG[v].push_back(u); for (int i = 1; i &lt;= n; ++i) read(moneyCross[i]); read(s, p); for (int i = 1; i &lt;= p; ++i) read(u), tagCross[u] = 1; SCC(); for (int i = 1; i &lt;= n; ++i) { if (!belong[i]) continue; money[belong[i]] += moneyCross[i], tag[belong[i]] |= tagCross[i]; for (auto j : g[i]) if (belong[i] != belong[j] &amp;&amp; belong[j]) connected[belong[i]][belong[j]] = 1; } f[belong[s]] = money[belong[s]]; for (int i = belong[s]; i &lt;= cntSCC; ++i) { for (auto j : connected[i]) { u = j.first; f[u] = std::max(f[u], f[i] + money[u]); } } int ans = 0; for (int i = belong[s]; i &lt;= cntSCC; ++i) if (tag[i]) ans = std::max(ans, f[i]); std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/05/29/APIO2009-%E6%8A%A2%E6%8E%A0%E8%AE%A1%E5%88%92/"},{"title":"「AHOI2017初中组」 alter","text":"Link洛谷 3718 Solution由于对于一个答案我们很容易验证是否可行，考虑二分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int n, k, t;string st;int check(int x){ int len = 1, cnt = 0; for (int i = 1; i &lt; st.length(); ++i) { if (st[i] == st[i - 1]) ++len; else len = 1; if (len &gt; x) { ++cnt, len = 0; if (x &lt; 2) st[i] = st[i] == 'N' ? 'F' : 'N', ++len; } } if (cnt &lt;= k) return 1; else return 0;}int main(){ ios::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; st; int l = 1, r = n; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout &lt;&lt; l &lt;&lt; endl; return 0;}","link":"/2018/10/27/AHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84-alter/"},{"title":"BIT修改与查询","text":"我们将修改与查询问题归为四大类 单点修改，单点查询这就不用做了，无脑开数组或map 单点修改，区间查询这里的树状数组用法较基础，模板题目：洛谷 3374 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, x, y;long long s[1000010];inline void update(int pos, int add){ while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;}inline long long query(int pos){ long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t , update(i, t); while (q--) { cin &gt;&gt; t &gt;&gt; x &gt;&gt; y; if (t == 1) update(x, y); else cout &lt;&lt; query(y) - query(x - 1) &lt;&lt; endl; } return 0;} 区间修改，单点查询我们学习一个叫做差分的神奇东西简单来说，对于原数组$a,a_0=0$，定义差分数组$d$，其构造法则为：$$d_i=a_i-a_{i-1}$$可以发现：$$a_i=\\sum_{j=1}^id_j$$假设我们给区间$[l,r]$加上$k$，那么我们会发现$d_l$变大了$k$，$d_{r+1}$变小了$k$，其余的不变因此我们只需维护$d$数组的前缀和即可，树状数组可以很方便的维护依然送上模板题目：洛谷 3368 Code实现时要注意我们维护的是差分数组，因此在对树状数组的初始化时要注意update的元素 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, l, r, x, lst;long long s[1000010];void update(int pos, int add){ while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;}long long query(int pos){ long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; while (q--) { cin &gt;&gt; t; if (t == 1) cin &gt;&gt; l &gt;&gt; r &gt;&gt; x, update(l, x), update(r + 1, -x); else cin &gt;&gt; x, cout &lt;&lt; query(x) &lt;&lt; endl; } return 0;} 区间修改，区间查询我们依然要用到差分，定义与上面的相同当我们查询区间$[l,r]$时，前缀和思想是非常清晰的：$$\\sum_{i=l}^ra_i=\\sum_{i=1}^ra_i-\\sum_{i=1}^{l-1}a_i$$对于一个单独的$\\sum_{i=1}^xa_i$，我们有：$$\\sum_{i=1}^xa_i=\\sum_{i=1}^x\\sum_{j=1}^id_j=\\sum_{i=1}^x(x-i+1)d_i$$再将其进行一个神奇的转换：$$\\sum_{i=1}^x(x-i+1)d_i=\\sum_{i=1}^x(x+1)d_i-\\sum_{i=1}^xid_i=(x+1)\\sum_{i=1}^xd_i-\\sum_{i=1}^xid_i$$所以我们可以维护两个树状数组，分别维护$d_i$和$id_i$即可每个询问区间的答案即是：$$\\sum_{i=1}^ra_i-\\sum_{i=1}^{l-1}a_i=(r+1)\\sum_{i=1}^rd_i-\\sum_{i=1}^rid_i-l\\sum_{i=1}^{l-1}d_i+\\sum_{i=1}^{l-1}id_i$$ Code维护时注意，第二个树状数组维护的是$id_i$，这意味着第一个树状数组update操作变化的值是$k$，那么第二个树状数组update操作变化的值是$ki$模板：POJ 3468千万注意数据规模可能超int，因此我选择整数运算和long long无异但范围比long long大的long double（其实没必要） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#pragma warning(disable:4996)int n, q, t, a, b, c, lst;char ch;long double s1[100010];long double s2[100010];void update(int pos, long long add){ int tpos = pos; while (pos &lt;= n) s1[pos] += add, s2[pos] += tpos * add, pos += pos &amp; -pos;}long long query(int pos){ long long sum = 0, tpos = pos; while (pos) sum += (tpos + 1)*s1[pos] - s2[pos], pos -= pos &amp; -pos; return sum;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; for (int i = 1; i &lt;= q; i++) { cin &gt;&gt; ch; if (ch == 'C') cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, update(a, c), update(b + 1, -c); else cin &gt;&gt; a &gt;&gt; b, cout &lt;&lt; query(b) - query(a - 1) &lt;&lt; endl; } return 0;}","link":"/2018/09/23/BIT%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9F%A5%E8%AF%A2/"},{"title":"「BZOJ 1455」 罗马游戏","text":"左偏树裸题 Solution考虑使用并查集维护堆顶kill 一个人之后其本人的祖先也需要修改 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstdio&gt;using std::cin;using std::cout;using std::endl;template &lt;typename T&gt;void read(T&amp; x){ x = 0; char c = getchar(); for (; !isdigit(c); c = getchar()); for (; isdigit(c); x = x * 10 + (c ^ 48), c = getchar());}struct Node{ int val, d, fa; int ch[2]; Node(int v = 0, int f = 0) { val = v; fa = f; ch[0] = ch[1] = d = 0; }};class LeftistTree{private: int&amp; rS(int x) { return tr[x].ch[tr[tr[x].ch[1]].d &lt; tr[tr[x].ch[0]].d]; }public: Node tr[1000010]; void pushUp(int x) { if (!x) return; if (tr[x].d != tr[rS(x)].d + 1) { tr[x].d = tr[rS(x)].d + 1; pushUp(tr[x].fa); } } int merge(int x, int y) { if (!x || !y) return x | y; if (tr[x].val &gt; tr[y].val) std::swap(x, y); tr[rS(x) = merge(rS(x), y)].fa = x; pushUp(x); return x; }};class DisjointSet{public: int f[1000010]; void init(int n) { for (int i = 1; i &lt;= n; ++i) f[i] = i; } int getF(int x) { return x == f[x] ? x : f[x] = getF(f[x]); }};int n, m;int killed[1000010];LeftistTree t;DisjointSet s;int main(){ read(n); s.init(n); for (int i = 1; i &lt;= n; ++i) { int x = 0; read(x); t.tr[i] = Node(x, i); } for (read(m); m; --m) { char c = ' '; cin &gt;&gt; c; if (c == 'M') // Merge { int x = 0, y = 0; read(x); read(y); int fX = s.getF(x), fY = s.getF(y); if (fX == fY || killed[x] || killed[y]) continue; s.f[fX] = s.f[fY] = t.merge(fX, fY); } else // Kill { int x = 0; read(x); if (killed[x]) { printf(&quot;0\\n&quot;); continue; } int f = s.getF(x); s.f[f] = s.f[t.tr[f].ch[0]] = s.f[t.tr[f].ch[1]] = t.merge(t.tr[f].ch[0], t.tr[f].ch[1]); killed[f] = 1; printf(&quot;%d\\n&quot;, t.tr[f].val); } } return 0;}","link":"/2019/12/08/BZOJ-1455-%E7%BD%97%E9%A9%AC%E6%B8%B8%E6%88%8F/"},{"title":"「BZOJ 2140」 稳定婚姻","text":"大型NTR现场 Solution人物之间瞎连一通，判断二人是否在同一SCC里即可 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364constexpr static int ___maxN = 100010;int n, m, cntNode, cntSCC, top;int stack[___maxN], belong[___maxN], vis[___maxN];std::string gi, bo;std::vector &lt;int&gt; g[___maxN], rG[___maxN];std::map &lt;std::string, int&gt; map;void dfs(int x){ vis[x] = 1; for (int i : g[x]) if (!vis[i]) dfs(i); stack[++top] = x;}void rDFS(int x){ vis[x] = 1, belong[x] = cntSCC; for (int i : rG[x]) if (!vis[i]) rDFS(i);}void SCC(){ memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= cntNode; ++i) if (!vis[i]) dfs(i); memset(vis, 0, sizeof vis); cntSCC = 0; for (int i = cntNode; i; --i) if (!vis[stack[i]]) ++cntSCC, rDFS(stack[i]);}int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { std::cin &gt;&gt; gi &gt;&gt; bo; map[gi] = ++cntNode, map[bo] = ++cntNode; g[cntNode - 1].push_back(cntNode); rG[cntNode].push_back(cntNode - 1); } std::cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { std::cin &gt;&gt; gi &gt;&gt; bo; g[map[bo]].push_back(map[gi]); rG[map[gi]].push_back(map[bo]); } SCC(); for (int i = 1; i &lt;= cntNode; i += 2) if (belong[i] != belong[i + 1]) std::cout &lt;&lt; &quot;Safe&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;Unsafe&quot; &lt;&lt; std::endl; return 0;}","link":"/2019/05/29/BZOJ-2140-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB/"},{"title":"「Codeforces 1009」 F - Dominant Indices","text":"132个点真TM好评 Solution题意即为找到每个子树含有最多节点的那一层的深度，若有则输出第一个这玩意还是裸的吧 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;constexpr static int ___maxN = 1000010;char ch;template &lt;typename T&gt;void read(T&amp; x){ for (x = 0, ch = getchar(); !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}int n, maxD, cHS, u, v;int ans[___maxN], sze[___maxN], depth[___maxN], hS[___maxN], cnt[___maxN];std::vector &lt;int&gt; t[___maxN];void getHS(int x, int fr){ sze[x] = 1, depth[x] = depth[fr] + 1; for (auto i : t[x]) if (i != fr) { getHS(i, x), sze[x] += sze[i]; if (sze[hS[x]] &lt; sze[i]) hS[x] = i; }}void add(int x, int fr, int y){ cnt[depth[x]] += y; if (cnt[depth[x]] &gt; cnt[maxD] || cnt[depth[x]] == cnt[maxD] &amp;&amp; depth[x] &lt; maxD) maxD = depth[x]; for (auto i : t[x]) if (i != fr &amp;&amp; i != cHS) add(i, x, y);}void dfs(int x, int fr, int keep){ for (auto i : t[x]) if (i != fr &amp;&amp; i != hS[x]) dfs(i, x, 0); if (hS[x]) dfs(hS[x], x, 1), cHS = hS[x]; add(x, fr, 1); ans[x] = maxD - depth[x], cHS = 0; if (!keep) add(x, fr, -1), maxD = 0;}int main(){ read(n); for (int i = 1; i &lt; n; ++i) read(u), read(v), t[v].push_back(u), t[u].push_back(v); getHS(1, 0), dfs(1, 0, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0;}","link":"/2019/04/04/Codeforces-1009-F/"},{"title":"Cassini&#39;s Identity","text":"令 ${F_i}$ 为 Fibonacci 数列$$F_0 = F_1 = 1, F_{n + 1} = F_n + F_{n - 1}$$那么对于 $n\\ge 1$，有$$F_{n + 1}F_{n - 1} - F_n^2 = (-1)^{n + 1}$$ Proof 1使用归纳法 首先对于 $n = 1$ 成立：$2\\times 1 - 1^2 = 1 = 1^{1 + 1}$ 假设对于 $n = k$ 成立，即 $F_{k + 1}F_{k - 1} - F_k^2 = (-1)^{k + 1}$，我们需要证明 $F_{k + 2}F_k - F_{k + 1}^2 = (-1)^{k + 2}$。为此我们要证明$$F_{k + 2}F_k - F_{k + 1}^2 = F_k^2 - F_{k + 1}F_{k - 1}$$直接化式子$$\\begin{aligned}F_{k}^{2} - F_{k+1}F_{k-1} &amp;= F_{k}^{2} + F_{k}F_{k-1}- F_{k}F_{k-1} - F_{k+1}F_{k-1}\\\\&amp;= F_{k+1}F_{k} - F_{k}F_{k-1} - F_{k+1}F_{k-1}\\\\&amp;= F_{k+1}F_{k} - 2F_{k}F_{k-1} - F_{k-1}^{2}\\\\&amp;= (F_{k+1} + F_{k})F_{k} - (F_{k}+F_{k-1})^2\\\\&amp;= F_{k+2}F_{k}-F_{k+1}^{2}\\end{aligned}$$ Proof 1’仍使用归纳法，归纳假设同上 将 $F_{n - 1} = F_{n + 1} - F_n$ 代入，即$$F_{k + 1}^2 - F_{k + 1}F_k - F_k^2 = (-1)^{k + 1}$$这与下式相同$$F_{k + 1}^2 - F_k(F_{k + 1} + F_k) = (-1)^{k + 1}$$进一步$$F_{k + 1}^2 - F_kF_{k + 2} = (-1)^{k + 1}$$这正是 $n = k + 1$ 的情况，故证毕 Proof 2根据 Fibonacci 数列通项公式$$F_n = \\dfrac{1}{\\sqrt{5}}(\\phi^n - \\tau^n)$$其中 $\\phi = \\dfrac{1 + \\sqrt{5}}{2}, \\tau = \\dfrac{1 - \\sqrt{5}}{2}$故有$$\\begin{aligned}F_{n+1}F_{n-1}-F_{n}^{2} &amp;= \\frac{1}{5}[(\\phi^{n+1} - \\tau^{n+1})(\\phi^{n-1} - \\tau^{n-1}) - (\\phi^{n} - \\tau^{n})^2]\\\\&amp;= \\frac{1}{5}[\\phi^{n+1}\\tau^{n-1}-\\phi^{n-1}\\tau^{n+1}+2\\phi^{n}\\tau^{n}]\\\\&amp;= \\frac{1}{5}(\\phi\\tau)^{n-1}(\\phi^{2} - 2\\phi\\tau +\\tau^{2})\\\\&amp;= \\frac{1}{5}(-1)^{n-1}(\\phi-\\tau)^{2}\\\\&amp;= (-1)^{n+1}\\end{aligned}$$ Proof 3有过 OI 基础的应该知道递推 Fibonacci 的矩阵是$$A =\\begin{bmatrix} 0 &amp; 1\\\\ 1 &amp; 1\\end{bmatrix}$$ 有$$A^{n + 1} =\\begin{bmatrix} F_{n - 1} &amp; F_n\\\\ F_n &amp; F_{n + 1}\\end{bmatrix}$$故 $\\det A^{n + 1} = F_{n - 1}F_{n + 1} - F_n^2$由方阵的性质 $\\det AB = \\det A\\det B$ 有$$\\det A^{n + 1} = (\\det A)^{n + 1} = (-1)^{n + 1}$$证毕","link":"/2020/01/29/Cassini-s-Identity/"},{"title":"「Codeforces Global Round 1」","text":"Digression由于本人太菜，G和H就咕咕咕了 TasksA - ParityAnalysis首先想到直接求哇！过大怎么办，取模哇！模数？19260817事实证明19260817还是很给力地过了7个pretest的，1e9+7只过了3个好啦不扯了讲正解这题还用讲？只用统计奇数的奇数次幂和$a_k$的奇偶性就行了哇 Code123456789101112131415161718192021222324int main(){ read(b), read(k); for (int i = 1; i &lt;= k; ++i) read(a[i]); if (b % 2 == 0) { if (a[k] % 2) std::cout &lt;&lt; &quot;odd&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;even&quot; &lt;&lt; std::endl; return 0; } for (int i = 1; i &lt;= k; ++i) if (a[i] % 2 == 0) continue; else ++ans; if (ans % 2) std::cout &lt;&lt; &quot;odd&quot; &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;even&quot; &lt;&lt; std::endl; return 0;} B - TapeAnalysis出门向下走拿到这题我都觉得吃惊，结束以后才发现评论区里有人放ABC的链接了（雾 Code1234567891011121314int main(){ read(n), read(m), read(k); for (int i = 1; i &lt;= n; ++i) read(a[i]); ans = a[n] - a[1] + 1; for (int i = 1; i &lt; n; ++i) b[i] = a[i + 1] - a[i] - 1; std::sort(b + 1, b + n); for (int i = n - 1; i &gt; n - k; --i) ans -= b[i]; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} C - Meaningless OperationsAnalysis嗯，真meaningless…首先明确一点，答案最多不超过把$a$转成二进制后所有位全变成$1$的数 $a$不能写成$2^k-1$的形式转成二进制后，构造新的数$b$，其比$a$少一位，各位等于$a$的对应位取非比如$a(2)=100010110$，构造$b(2)=11101001$不难发现此时$a$按位与$a &amp; b=0$，按位异或$a \\oplus b=a ^ c - 1$，其中$c$为$a$转二进制后的位数而$\\gcd(0, a ^ c - 1) = a ^ c - 1$这就达到上限了哇，肯定最大哇 $a$能写成$2^k-1$的形式我们观察到$a \\le 2 ^ {25} - 1$，因此你懂的官方tutorial如是说： or it’s possible to calculate answers for all $a = 2^{x−1}$ beforehand 但我们关心or之前的，因此来搞搞正解我们发现此时$a&amp;b$就是$b$哇，$a\\oplus b$就是$a - b$哇然$\\forall a, b\\in \\mathbb{N^+}, \\gcd(a, a + b) = \\gcd(a, b)$因此$\\gcd(a &amp; b, a \\oplus b) = \\gcd(a, b)$那就找最大的约数哇！ Code这里给的是「beforehand」的高级解法哇（雾 12345678910111213141516171819202122232425const int table[] = {0, 0, 1, 1, 5, 1, 21, 1, 85, 73, 341, 89, 1365, 1, 5461, 4681, 21845, 1, 87381, 1, 349525, 299593, 1398101, 178481, 5592405, 1082401, 22369621, 19173961};int deal(int x){ int judge = 1, sav = x, bt = 0, w = 0; while (sav) judge &amp;= sav, sav &gt;&gt;= 1, (bt &lt;&lt;= 1) |= 1, w += 1; if (judge) // power of 2 - 1 { return table[w]; } else { return bt; }}int main(){ read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); for (int i = 1; i &lt;= n; ++i) std::cout &lt;&lt; deal(a[i]) &lt;&lt; std::endl; return 0;} D - Jongmah从这里我就跪了… Analysis很聪明的做法哇我们规定$t[a, b, c]$表示$t$个$[a, b, c]$这样的triple (没有指明$t$则为$1$)，并且还可以套用结合律（雾那么我们想，$3[x, x + 1, x + 2]$与$[x, x, x], [x + 1, x + 1, x + 1], [x + 2, x + 2, x + 2]$等价那么假使最优解里面有$k[x, x + 1, x + 2]$，我们一定能换成$(k,\\mathrm{mod},3)[x, x + 1, x + 2]$和$(k - k,\\mathrm{mod},3)([x, x, x], [x + 1, x + 1, x + 1], [x + 2, x + 2, x + 2])$因此这样换过之后，最优解里面肯定没有$k[x, x + 1, x + 2], k &gt; 2$那么我们可以设计DP状态了哇设$f(i, j, k)$表示选择到**$i$这个数且$j[i - 2, i - 1, i], k[i - 1, i, i + 1]$往后推就行了哇**$m$要$+1$哇！！！ Code1234567891011121314151617181920212223int main(){ read(n), read(m); for (int i = 1; i &lt;= n; ++i) read(x), ++a[x]; ++m; for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt; 3; ++j) for (int k = 0; k &lt; 3; ++k) { int p = a[i] - j - k, q = a[i + 1] - k, r = a[i + 2]; for (int l = 0; l &lt; 3; ++l) { if (p &gt;= l &amp;&amp; q &gt;= l &amp;&amp; r &gt;= l) f[i + 1][k][l] = std::max(f[i + 1][k][l], f[i][j][k] + l + (p - l) / 3); } } for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt; 3; ++j) for (int k = 0; k &lt; 3; ++k) ans = std::max(ans, f[i][j][k]); std::cout &lt;&lt; ans &lt;&lt; std::endl;} E - Magic StonesAnalysis很聪明的做法哇构造差分数组$\\lbrace d_{n - 1}\\rbrace : d_i = c_{i + 1} - c_i$我们看看操作一次后$d$数组会怎么样，假设synchronize了$c_j$，也就是$c_j’ = c_{j + 1} + c_{j - 1} - c_j$$d_j’ = c_{j + 1} - c_j’ = c_{j + 1} - c_{j + 1} - c_{j - 1} + c_j = c_j - c_{j - 1} = d_{j - 1}$$d_{j - 1}’ = c_j’ - c_{j - 1} = c_{j + 1} + c_{j - 1} - c_j - c_{j - 1} = c_{j + 1} - c_j = d_j$唔…就是交换了$d_j, d_{j - 1}$哇那么直接比较$\\lbrace c_n\\rbrace$的差分数组和$\\lbrace t_n\\rbrace$是否元素相同就行了哇 Code1234567891011121314151617181920212223int main(){ read(n); for (int i = 1; i &lt;= n; ++i) read(s[i]); for (int i = 1; i &lt;= n; ++i) read(t[i]); for (int i = 1; i &lt; n; ++i) ds[i] = s[i + 1] - s[i], dt[i] = t[i + 1] - t[i]; if (s[1] != t[1] || s[n] != t[n]) std::cout &lt;&lt; &quot;No&quot; &lt;&lt; std::endl; else { std::sort(ds + 1, ds + n), std::sort(dt + 1, dt + n); for (int i = 2; i &lt; n; ++i) if (ds[i] != dt[i]) { std::cout &lt;&lt; &quot;No&quot; &lt;&lt; std::endl; return 0; } std::cout &lt;&lt; &quot;Yes&quot; &lt;&lt; std::endl; }} F - Nearest LeafAnalysis : Brute给每个叶节点重标号，给每个节点建一棵线段树哇MLE on test 8代码就不放了 Analysis : Standard考虑离线哇把Segment-Tree的Code Style彻底颠覆了C++ 11和C++ 17的新语法真心好评哇 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;const long long INF = 1152921504606846976;int n, q;int p[500010], w[500010];class Node{public: long long val = 0, tag = 0; void apply(int l, int r, long long v) { val += v, tag += v; }};struct SegmentTree{ std::vector &lt;Node&gt; tree; int n; Node unite(const Node&amp; l, const Node&amp; r) { Node res; res.val = std::min(l.val, r.val); return res; } SegmentTree(int n) : n(n) { tree.resize(n &lt;&lt; 2); } void pull(int root) { tree[root] = unite(tree[root &lt;&lt; 1], tree[root &lt;&lt; 1 | 1]); } void push(int l, int r, int root) { int mid = l + r &gt;&gt; 1; if (tree[root].tag) tree[root &lt;&lt; 1].apply(l, mid, tree[root].tag), tree[root &lt;&lt; 1 | 1].apply(mid + 1, r, tree[root].tag), tree[root].tag = 0; } void build(int l, int r, int root, const std::vector &lt;long long&gt;&amp; v) { if (l == r) tree[root].apply(l, r, v[l]); else { int mid = l + r &gt;&gt; 1; build(l, mid, root &lt;&lt; 1, v); build(mid + 1, r, root &lt;&lt; 1 | 1, v); pull(root); } } Node query(int l, int r, int root, int ql, int qr) { if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[root]; else { int mid = l + r &gt;&gt; 1; push(l, r, root); if (qr &lt;= mid) return query(l, mid, root &lt;&lt; 1, ql, qr); else if (ql &gt; mid) return query(mid + 1, r, root &lt;&lt; 1 | 1, ql, qr); else return unite(query(l, mid, root &lt;&lt; 1, ql, qr), query(mid + 1, r, root &lt;&lt; 1 | 1, ql, qr)); } } void modify(int l, int r, int root, int ql, int qr, const long long&amp; v) { if (ql &lt;= l &amp;&amp; r &lt;= qr) tree[root].apply(l, r, v); else { int mid = l + r &gt;&gt; 1; push(l, r, root); if (ql &lt;= mid) modify(l, mid, root &lt;&lt; 1, ql, qr, v); if (qr &gt; mid) modify(mid + 1, r, root &lt;&lt; 1 | 1, ql, qr, v); pull(root); } }};int main(){ std::ios::sync_with_stdio(0); std::cin &gt;&gt; n &gt;&gt; q; std::vector &lt;int&gt; p(n), w(n); std::vector &lt;long long&gt; dist(n); std::vector &lt;bool&gt; leaf(n, 1); std::vector &lt;std::vector &lt;std::pair&lt;int, int&gt; &gt; &gt; adj(n); for (int i = 1; i &lt; n; ++i) std::cin &gt;&gt; p[i] &gt;&gt; w[i], --p[i], leaf[p[i]] = 0, dist[i] = dist[p[i]] + w[i], adj[p[i]].emplace_back(i, w[i]); for (int i = 0; i &lt; n; ++i) if (!leaf[i]) dist[i] = INF; SegmentTree T(n); T.build(0, n - 1, 1, dist); std::vector &lt;std::vector &lt;std::tuple&lt;int, int, int&gt; &gt; &gt; asks(n); std::vector &lt;long long&gt; ans(q); ans.resize(q); for (int i = 0; i &lt; q; ++i) { int v, l, r; std::cin &gt;&gt; v &gt;&gt; l &gt;&gt; r; --v, --l, --r; asks[v].emplace_back(l, r, i); } std::vector &lt;int&gt; low(n), hig(n); std::function &lt;void(int)&gt; dfs = [&amp;](int x) { low[x] = hig[x] = x; for (auto p : adj[x]) { int y = p.first; dfs(y), low[x] = std::min(low[x], low[y]), hig[x] = std::max(hig[x], hig[y]); } }; dfs(0); long long cur = 0; std::function&lt;void(int)&gt; solve = [&amp;](int x) { for (auto p : asks[x]) ans[std::get&lt;2&gt;(p)] = T.query(0, n - 1, 1, std::get&lt;0&gt;(p), std::get&lt;1&gt;(p)).val + cur; for (auto p : adj[x]) { int y = p.first; cur += p.second; T.modify(0, n - 1, 1, low[y], hig[y], -2 * p.second); solve(y); T.modify(0, n - 1, 1, low[y], hig[y], 2 * p.second); cur -= p.second; } }; solve(0); for (int i = 0; i &lt; q; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2019/02/10/Codeforces-Global-Round-1/"},{"title":"「Codeforces 1165」","text":"Tasks这场CF粉碎了我摆脱pupil的希望（ A - RemainderAnalysis理智分析，我们只需将第$y$bit之后的所有bit置为$0$，第$x$bit到第$y$bit之间的所有bit置为$0$即可哇别忘记第$y$bit要置为$1$哇注意特判$y = 0$的情况哇 Code123456789101112131415161718192021222324252627282930int n, x, y, ans;std::string st;int main(){ std::cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for (ch = getchar(); !isdigit(ch); ch = getchar()); for (; isdigit(ch); st = ch + st, ch = getchar()); st = ' ' + st; if (y == 0) { if (st[1] == '0') ++ans; for (int i = 2; i &lt;= x; ++i) if (st[i] != '0') ++ans; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0; } for (int i = 1; i &lt;= y; ++i) if (st[i] != '0') ++ans; if (st[y + 1] == '0') ++ans; for (int i = y + 2; i &lt;= x; ++i) if (st[i] != '0') ++ans; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} B - Polycarp TrainingAnalysis排序后模拟即可，码量比A还小哇…… Code1234567891011121314151617181920212223int n, ans = 1;int a[2000010];int main(){ read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); std::sort(a + 1, a + n + 1); for (int i = 1; ; ++i) { while (a[i] &lt; ans &amp;&amp; i &lt;= n) ++i; if (i &gt; n) { --ans; break; } ++ans; } std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} C - Good StringAnalysis注意到删去两个相同字符的任意一个带来的影响是一样的，模拟即可哇注意特判字符串长度为$1$的情况啊！！我就是这么被hack的 Code12345678910111213141516171819202122232425262728293031int n, ans;std::string st;int main(){ read(n); std::cin &gt;&gt; st; if (st.length() == 1) { std::cout &lt;&lt; 1 &lt;&lt; std::endl &lt;&lt; std::endl; return 0; } for (int i = 0; ;) { if (st[i] == st[i + 1]) ++ans, st.erase(i, 1); else i += 2; n = st.length(); if (i == n - 1) { ++ans; st.erase(i, 1); break; } else if (i == n) break; } std::cout &lt;&lt; ans &lt;&lt; std::endl &lt;&lt; st &lt;&lt; std::endl;; return 0;} D - Almost All DivisorsAnalysis先将$\\lbrace d\\rbrace$排序考虑到若$\\lbrace d\\rbrace$为数$x$的全部非平凡约数，则定有$x = d_1\\cdot d_n$接下来只需$\\mathcal{O}(\\sqrt{n})$验证约数是否全部存在于$\\lbrace d\\rbrace$中即可哇数据千万条，清空第一条。多测不清空，爆零两行泪。 Code12345678910111213141516171819202122232425262728int cases, n;int appear[1000010];long long d[1000010];int main(){ for (read(cases); cases; --cases) { memset(appear, 0, sizeof appear); int flag = 0, cnt = 0; read(n); for (int i = 1; i &lt;= n; ++i) read(d[i]), appear[d[i]] = 1; std::sort(d + 1, d + n + 1); long long x = d[1] * d[n], limit = sqrt(x); for (int i = 2; i &lt;= limit; ++i) if (x % i == 0) if ((!appear[i] || !appear[x / i]) &amp;&amp; (flag = 1)) break; else cnt += (i != x / i) + 1; if (flag || cnt != n) std::cout &lt;&lt; -1 &lt;&lt; std::endl; else std::cout &lt;&lt; x &lt;&lt; std::endl; } return 0;} E - Two Arrays and Sum of FunctionsAnalysis考虑$a_i\\cdot b_i$累加的次数，显然为$i\\cdot(n - i + 1)$那么我们要计算的就是$\\sum_{i = 1} ^ {n} a_ib_ii(n - i + 1)$，故不妨令$a_i$乘上$i(n - i + 1)$使用Rearrangement Inequality即可 Code123456789101112131415161718constexpr static int ___maxN = 200010, ___mod = 998244353;int n;long long a[___maxN], b[___maxN];long long ans;int main(){ read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]), a[i] *= (long long)i * (n - i + 1); for (int i = 1; i &lt;= n; ++i) read(b[i]); std::sort(a + 1, a + n + 1), std::sort(b + 1, b + n + 1); for (int i = 1; i &lt;= n; ++i) (ans += (long long)a[i] % ___mod * b[n - i + 1] % ___mod) %= ___mod; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;} F - MicrotransactionsAnalysis这里直接将F1和F2并作F令答案为$ans$，显然能得到$ans \\le2\\cdot \\sum k_i$题目中的$\\sum k_i \\le 2\\cdot 10^5$非常微妙，故想到二分天数由于能获得的microtransaction随天数单调不降，故可以二分judge()函数贪心选取合法的时间最靠后的促销即可哇 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253constexpr static int ___maxN = 200010;struct Data{ int d, t; Data(int d = 0, int t = 0) : d(d), t(t) {}};int cmp(const Data&amp; x, const Data&amp; y){ return x.d &gt; y.d;}int n, m, tot;int k[___maxN], b[___maxN];Data a[___maxN];int judge(long long x){ memcpy(b, k, sizeof b); int calc = 0, curMoney = x; for (int i = 1; i &lt;= m &amp;&amp; curMoney; ++i) if (a[i].d &lt;= x) { calc += std::min(b[a[i].t], std::min(curMoney, a[i].d)); int lMoney = curMoney; curMoney = std::max(0, std::min(curMoney, a[i].d) - b[a[i].t]); b[a[i].t] = std::max(b[a[i].t] - std::min(lMoney, a[i].d), 0); } for (int i = 1; i &lt;= n; ++i) calc += 2 * b[i]; return calc &lt;= x;}int main(){ read(n, m); for (int i = 1; i &lt;= n; ++i) read(k[i]), tot += k[i]; for (int i = 1; i &lt;= m; ++i) read(a[i].d, a[i].t); std::sort(a + 1, a + m + 1, cmp); int l = 1, r = tot * 2; while (l &lt;= r) { long long mid = l + r &gt;&gt; 1; if (judge(mid)) r = mid - 1; else l = mid + 1; } std::cout &lt;&lt; l &lt;&lt; std::endl; return 0;}","link":"/2019/05/17/Codeforces-1165/"},{"title":"「Codeforces 570」 D - Tree Requests","text":"Solution判断重排后是否回文有个显而易见的方式：若该串中的任意两种或以上字符存在奇数个则不回文由于只有26个字母，考虑用二进制来压缩信息，用异或$\\oplus$更新信息显然，若每个二进制位被更新偶数次则为$0$，被更新奇数次则为$1$那么只需判断状态是否是$2$的次幂或$0$即可，注意$1$也是可行的，可用!(x &amp; (x - 1))判断 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;int n, m, u, v, curChild;int sze[500010], bigChild[500010], depth[500010], letter[500010], cnt[500010], ans[500010];char ch;std::vector &lt;int&gt; g[500010];std::vector &lt;std::pair &lt;int, int&gt; &gt; query[500010];template &lt;typename T&gt;void read(T&amp; x){ for (x = 0, ch = getchar(); !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}void getBigChild(int x, int fr = 0){ sze[x] = 1, depth[x] = depth[fr] + 1; for (auto i : g[x]) getBigChild(i, x), sze[x] += sze[i], bigChild[x] = sze[i] &gt; sze[bigChild[x]] ? i : bigChild[x];}void add(int x){ cnt[depth[x]] ^= (1 &lt;&lt; letter[x]); for (auto i : g[x]) if (i != curChild) add(i);}void dfs(int x, int keep = 0){ for (auto i : g[x]) if (i != bigChild[x]) dfs(i, 0); if (bigChild[x]) dfs(bigChild[x], 1), curChild = bigChild[x]; add(x), curChild = 0; for (auto i : query[x]) ans[i.second] = !(cnt[i.first] &amp; (cnt[i.first] - 1)); if (!keep) add(x);}int main(){ read(n), read(m); for (int i = 2; i &lt;= n; ++i) read(u), g[u].push_back(i); for (ch = getchar(); !isalpha(ch); ch = getchar()); for (int i = 1; i &lt;= n; ++i) letter[i] = ch - 'a', ch = getchar(); for (int i = 1; i &lt;= m; ++i) read(u), read(v), query[u].push_back(std::make_pair(v, i)); depth[1] = 1; getBigChild(1); dfs(1); for (int i = 1; i &lt;= m; ++i) printf(ans[i] ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); return 0;}","link":"/2019/04/04/Codeforces-570-D/"},{"title":"「GCJ R1A 2008」 C - numbers","text":"题目链接GCJ R1A 2008 C总觉得Code Jam都需要科学方式访问是不是有些太过了 题解拿到手首先肯定不能暴力，于是我们考虑数学方法 分析对于这个式子：$(3+\\sqrt{5})^n$，一眼想到二项式定理，将其展开得：$$(3+\\sqrt{5})^n=C_n^03^n\\sqrt{5}^0+C_n^13^{n-1}\\sqrt{5}^1+\\dots+C_n^{n-1}3^1\\sqrt{5}^{n-1}+C_n^n3^0\\sqrt{5}^n$$不难发现若幂次为偶数，则$\\sqrt{5}$也会变成整数，那么我们可以将上面的式子写成如下形式：$$(3+\\sqrt{5})^n=f(n)+g(n)\\sqrt{5}$$$f(n)$即为展开式中所有运算结果为整数的部分的和仍然没法解决，我们再考虑另一个式子：$$(3-\\sqrt{5})^n=C_n^03^n\\sqrt{5}^0-C_n^13^{n-1}\\sqrt{5}^1+\\dots+(-1)^{n-1}C_n^{n-1}3^1\\sqrt{5}^{n-1}+(-1)^nC_n^n3^0\\sqrt{5}^n$$同理，可写成：$$(3-\\sqrt{5})^n=f(n)-g(n)\\sqrt{5}$$二式相加，得：$$(3+\\sqrt{5})^n+(3-\\sqrt{5})^n=2f(n)$$所以$$(3+\\sqrt{5})^n=2f(n)-(3-\\sqrt{5})^n$$考虑到$$0&lt;(3-\\sqrt{5})^n&lt;1$$而我们要求的是整数部分，那么完全可以写成$$\\lfloor(3+\\sqrt{5})^n\\rfloor=2f(n)-1$$ 求解$f$问题是这个$f$怎么求考虑以下递推式： $$\\begin{aligned}(3+\\sqrt{5})^{n+1}&amp;=(3+\\sqrt{5})(3+\\sqrt{5})^n\\notag\\\\&amp;=(3+\\sqrt{5})(f(n)+g(n)\\sqrt{5})\\notag\\\\&amp;=3f(n)+3\\sqrt{5}g(n)+\\sqrt{5}f(n)+5g(n)\\notag\\end{aligned}$$所以$$\\begin{aligned}f(n+1)=3f(n)+5g(n)\\notag\\\\g(n+1)=f(n)+3g(n)\\notag\\end{aligned}$$由此我们可以用矩阵快速幂解决 矩阵原始矩阵：$$\\begin{aligned}\\begin{bmatrix}f(0)\\\\g(0)\\notag\\end{bmatrix}=\\begin{bmatrix}1\\\\0\\end{bmatrix}\\end{aligned}$$递推的矩阵：$$\\begin{bmatrix}3&amp;5\\\\1&amp;3\\end{bmatrix}$$至此问题解决 代码printf()格式化真心强大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#pragma warning(disable:4996)using namespace std;int T, n;struct Mat{ int r, c; int matrix[10][10];};Mat basmat;void init(){ basmat.c = basmat.r = 2; basmat.matrix[0][0] = 3, basmat.matrix[0][1] = 5; basmat.matrix[1][0] = 1, basmat.matrix[1][1] = 3;}Mat mul(Mat mat1, Mat mat2){ Mat tmat; memset(tmat.matrix, 0, sizeof tmat.matrix); tmat.r = mat1.r; tmat.c = mat2.c; for (int i = 0; i &lt; mat1.r; i++) for (int j = 0; j &lt; mat2.c; j++) for (int k = 0; k &lt; mat1.c; k++) tmat.matrix[i][j] = (tmat.matrix[i][j] + mat1.matrix[i][k] * mat2.matrix[k][j]) % 1000; return tmat;}void fastpow(int index){ Mat retmat; retmat.r = retmat.c = 2; retmat.matrix[0][0] = retmat.matrix[1][1] = 1; retmat.matrix[0][1] = retmat.matrix[1][0] = 0; while (index) { if (index &amp; 1) retmat = mul(retmat, basmat); basmat = mul(basmat, basmat); index &gt;&gt;= 1; } printf(&quot;%03d\\n&quot;, ((retmat.matrix[0][0] &lt;&lt; 1) - 1) % 1000);}int main(int argc, char ** argv){ freopen(&quot;C-large-practice.in&quot;, &quot;r&quot;, stdin); freopen(&quot;C-large-practice.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;T); for (int TT = 1; TT &lt;= T; TT++) { scanf(&quot;%d&quot;, &amp;n); init(); printf(&quot;Case #%d: &quot;, TT); fastpow(n); } return 0;}","link":"/2018/09/02/GCJ-R1A-2008-C/"},{"title":"「HAOI2016」 找相同字符","text":"Solution考虑容斥将两个串用分隔符拼在一起，则求该串的相同子串个数减去两个串各自相同的子串个数 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;struct SuffixArray{ std::string st = &quot;&quot;; int len = 0, size = 0; int bucket[1000010], pos[1000010], sa[1000010], rank[1000010], height[1000010]; // Each array starts from 1 void radixSort() { for (int i = 1; i &lt;= size; ++i) bucket[i] = 0; for (int i = 1; i &lt;= len; ++i) ++bucket[rank[i]]; for (int i = 1; i &lt;= size; ++i) bucket[i] += bucket[i - 1]; for (int i = len; i; --i) sa[bucket[rank[pos[i]]]--] = pos[i]; } void getSA() { for (int i = 1; i &lt;= len; ++i) rank[i] = st[i], pos[i] = i; radixSort(); for (int w = 1, p = 0; p &lt; len &amp;&amp; w &lt;= len; size = p, w &lt;&lt;= 1) { p = 0; for (int i = len - w + 1; i &lt;= len; ++i) pos[++p] = i; for (int i = 1; i &lt;= len; ++i) if (sa[i] &gt; w) pos[++p] = sa[i] - w; radixSort(); std::swap(rank, pos); rank[sa[1]] = p = 1; for (int i = 2; i &lt;= len; ++i) rank[sa[i]] = pos[sa[i]] == pos[sa[i - 1]] &amp;&amp; pos[sa[i] + w] == pos[sa[i - 1] + w] ? p : ++p; } } void getHeight() { int j = 0, k = 0; for (int i = 1; i &lt;= len; ++i) { if (k) --k; j = sa[rank[i] - 1]; while (st[i + k] == st[j + k]) ++k; height[rank[i]] = k; } } void main(std::string __st, int __size = 127) { memset(sa, 0, sizeof sa); memset(height, 0, sizeof height); memset(bucket, 0, sizeof bucket); memset(pos, 0, sizeof pos); memset(rank, 0, sizeof rank); st = __st, len = st.length() - 1, size = __size; getSA(), getHeight(); }};std::string a, b;SuffixArray SA;long long ans;long long f[2000010];void solve(int op, std::string st){ SA.main(' ' + st); std::stack &lt;long long&gt; stack; memset(f, 0, sizeof f); int n = st.length(); for (int i = 1; i &lt;= n; ++i) { while (stack.size() &amp;&amp; SA.height[stack.top()] &gt;= SA.height[i]) stack.pop(); if (!stack.size()) f[i] = SA.height[i] * (i - 1); else f[i] = f[stack.top()] + SA.height[i] * (i - stack.top()); stack.push(i); ans += 1ll * op * f[i]; }}int main(){ std::cin &gt;&gt; a &gt;&gt; b; solve(1, a + '!' + b); solve(-1, a); solve(-1, b); std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;}","link":"/2019/05/07/HAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6/"},{"title":"「HEOI2015」 兔子与樱花","text":"Link洛谷 4107 Solution假设当前节点为$i$，则其某个子节点$j$被删除且不违背最大载重的话一定满足$$c_i+c_j-1\\leq m$$而且只需满足这个条件即可那么我们为了删除尽可能多的点，易想到贪心解决 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, m, tmp, son, ans;int c[2000010], k[2000010];vector &lt;int&gt; tree[2000010];bool cmp(const int &amp;x, const int &amp;y){ return c[x] &lt; c[y];}void dfs(int root){ int sze = tree[root].size(); if (!sze) return; for (int i = 0; i &lt; sze; ++i) dfs(tree[root][i]); sort(tree[root].begin(), tree[root].end(), cmp); for (register int i = 0; i &lt; sze; ++i) { if (c[root] + c[tree[root][i]] - 1 &lt;= m) c[root] += c[tree[root][i]] - 1, ++ans; else break; }}int main(){ ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; c[i]; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; tmp; c[i] += tmp; while (tmp--) cin &gt;&gt; son, tree[i].push_back(son); } dfs(0); cout &lt;&lt; ans &lt;&lt; endl; return 0;} Extra洛谷提交时记得开O2","link":"/2018/10/23/HEOI2015-%E5%85%94%E5%AD%90%E4%B8%8E%E6%A8%B1%E8%8A%B1/"},{"title":"「IOI2011」 Race","text":"Solution考虑DSU on Tree维护一个std::map，保存每个长度对应的最小深度，每个节点查询答案 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;map&gt;constexpr static int ___maxN = 200010;char ch;template &lt;typename T&gt;void read(T&amp; x){ for (ch = getchar(); !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}int n, k, u, v, w, dfn, ans = 0x7f7f7f7f;int hS[___maxN], sze[___maxN], id[___maxN], nid[___maxN], depth[___maxN];long long dis[___maxN];std::vector &lt;int&gt; to[___maxN], wei[___maxN];std::map &lt;long long, int&gt; map;void getHS(int x, int fr){ sze[x] = 1, id[x] = ++dfn, nid[dfn] = x, depth[x] = depth[fr] + 1; int __max = 0, __size = to[x].size(); for (int i = 0; i &lt; __size; ++i) { int tmp = to[x][i]; if (tmp != fr) { dis[tmp] = dis[x] + wei[x][i]; getHS(tmp, x); sze[x] += sze[tmp]; if (sze[tmp] &gt; __max) __max = sze[tmp], hS[x] = tmp; } }}void update(int x, int y){ int z = dis[x]; if (y == -1) map[z] = 0; else { if (!map[z]) map[z] = depth[x]; else map[z] = std::min(map[z], depth[x]); }}void dfs(int x, int fr, int keep){ for (auto i : to[x]) if (i != fr &amp;&amp; i != hS[x]) dfs(i, x, 0); if (hS[x]) dfs(hS[x], x, 1); for (auto i : to[x]) if (i != fr &amp;&amp; i != hS[x]) { for (int j = 0; j &lt; sze[i]; ++j) { int nxt = nid[id[i] + j], req = k + 2 * dis[x] - dis[nxt]; if (map.count(req) &amp;&amp; map[req]) ans = std::min(ans, map[req] + depth[nxt] - 2 * depth[x]); } for (int j = 0; j &lt; sze[i]; ++j) update(nid[id[i] + j], 1); } update(x, 1); if (map.count(dis[x] + k) &amp;&amp; map[dis[x] + k]) ans = std::min(ans, map[dis[x] + k] - depth[x]); if (!keep) for (int i = 0; i &lt; sze[x]; ++i) update(nid[id[x] + i], -1);}int main(){ read(n), read(k); for (int i = 1; i &lt; n; ++i) read(u), read(v), read(w), to[u].push_back(v), to[v].push_back(u), wei[u].push_back(w), wei[v].push_back(w); getHS(0, 0); dfs(0, 0, 0); std::cout &lt;&lt; (ans == 0x7f7f7f7f ? -1 : ans) &lt;&lt; std::endl; return 0;}","link":"/2019/04/14/IOI2011-Race/"},{"title":"「JSOI2019」 骗分过样例","text":"Overview本题的题意即为给定所有输入输出文件，让选手猜测每个点要实现的目的与方法经观察，Case 1-7与$19$的幂次有关，Case 8-16与区间内的数和函数有关同时经提示、联想与对数据的观察，不难得出：?表示某数未知，wa表示溢出，p表示质数（prime number），u表示Möbius函数（$\\mu$），g表示原根（primitive root，常记为$g$）初步的观察对于解题有着极大的帮助。观察过后，我们开始对每个Case进行分析 SolutionCase 1-3经观察可发现要求输出$19$的幂次对$998244353$取模的结果 Method 1使用高精度乘法 Method 2使用欧拉定理$$a^{\\varphi(n)}\\equiv 1(\\mathrm{mod},n)\\quad \\text{if},\\gcd(a, n) = 1$$在使用快读的时候将输入数据对$\\varphi(998244353) = 998244352$取模即可 Case 4经观察可发现要求输出$19$的幂次对某一质数$p$取模的结果观察下发的software4.ans可得到大致范围$p\\in(1.1\\times10^6, 1.2\\times10^6)$，故枚举得到$p = 1145141$ Case 5要求同Case 4一样，经观察可得出大致范围$p\\in(5.2\\times10^{18}, 5.3\\times10^{18})$，故需要更优的解法设输入数据中某两个数为$x_1, x_2$，其对应的值为$y_1, y_2$，则在模$p$意义下有$19^{x_1}\\equiv y_1, 19^{x_2}\\equiv y_2$。稍作变形可得到$$y_1\\cdot19^{x_2 - x_1}\\equiv y_2(\\mathrm{mod},p)$$故$p | y_1\\cdot19^{x_2 - x_1} - y_2$。根据software5.in和software5.ans中的两组指数相近的情况再经简单枚举可得出$p = 5211600617818708273$ Case 6-7经观察可发现要求输出$19$的幂次对$p = 998244353$取模的结果，但中间运算溢出导致出现错误结果考虑19的某次方对$p$取模且溢出的结果可看做在区间$(-p, p)$内随机选择了一个数。根据生日悖论，存在多个指数对应相同的结果的概率是相当大的。故我们断定：必然会存在$1 &lt; x_1 &lt; x_2$使得输出的结果相同。即从$x_1$开始每$x_2 - x_1$个数构成相同的循环节预处理后$\\mathcal{O}(1)$解决一个询问 Case 8-10经观察可发现要求判断指定区间内每个数为质数还是合数 Method 1由于区间长度不大于1000000，考虑直接对每个数Miller-Rabin测试 Method 2考虑筛法对于Case 8，直接线性筛对于Case 9，考虑到任意合数$a\\in[10^6, 10^{12}]$必有质因子$p\\in(1, 10^6)$，故先筛出$10^6$以内的质数，再用这些质数筛出所求区间内的合数对于Case 10，类似Case 9 + 打表解决 Case 11-13经观察可发现要求输出指定区间内每个数的Möbius函数考虑先筛出$10^6$以内所有质数及所有数的Möbius函数。对于小于等于$10^6$的询问$\\mu(x)$直接输出否则先将$x$的所有小于等于$10^6$的质因子全部除去并同时统计$\\mu(x)$，设最后我们得到了$x_0$。显然$x_0$要么等于1，要么由最多两个大于$10^6$的质数组成。设当前统计到的$\\mu(x)$为$\\mu_P(x)$对于$x_0$， 判断其是否为质数 若是，则输出$-\\mu_P(x)$ 否则继续第2步 判断其是否为完全平方数 若是，则输出$0$ 否则其一定有两个与之前筛出的不同的质因子，则输出$\\mu_P(x)\\times(-1)\\times(-1) = \\mu_P(x)$ 实现时注意Miller-Rabin的基选取问题，经尝试仅需选取24251 Case 14-15经观察可发现要求判断指定区间内每个数是否是指定质数$p$的原根对于$p = 998244353$，由欧拉定理可知，若$x^t\\equiv1(\\mathrm{mod},p), t &lt; \\varphi(p)$，则定有$t|\\varphi(p)$。故若对于$p$的任意质因子$p_i$，都有$x^{p_i}\\not\\equiv1(\\mathrm{mod},p)$，则$x$是$p$的一个原根。每个数验证即可对于$p = 13123111$，由于$\\varphi(p)$的质因子较多，故不能按以上方法实现考虑先求出某一原根$g$。令$x = g^k,\\mathrm{mod},p$，则若$x$为原根，就有$$g^{k\\varphi(p)}\\equiv1(\\mathrm{mod},p)$$且$\\varphi(p)$是最小的使$g^{kt}\\equiv1(\\mathrm{mod},p)$的正整数$t$。而$g^{\\varphi(p)}\\equiv1(\\mathrm{mod},p)$，故$k\\perp\\varphi(p)$预处理出每个$x$的$k$与每个数是否与$\\varphi(p)$互质即可 Case 16已知$p\\in[10^9, 2\\times10^9]$，要求判断指定区间内每个数是否是质数$p$的原根由于不同质数在同一区间内原根的分布情况是混乱的，故不是解的$p$一定会很快被排除。故只需筛出所有可能的质数代入求解即可 Code过长，还是不放了","link":"/2019/05/07/JSOI2019-%E9%AA%97%E5%88%86%E8%BF%87%E6%A0%B7%E4%BE%8B/"},{"title":"「POJ 2348」 Euclid&#39;s Game","text":"还是第一次写博弈论的题目呐虽然完全口胡做法 Solution考虑到一方输一定是被迫输的，也就是只有可能这么选我们用$(a, b)$表示当前两个数 ($a &gt; b$)，令$c$为最大的使$bc &lt; a$的整数 $b = 1$。这就没得其它方法选了，继续往下做吧 $b &gt; 1$。若我们这一轮将状态变为$(a - (c - 1)b, b)$，此时变成对方无法选择，下一步对方只可能将其变成$(b, a - bc)$。然而我们可以直接在这一轮将状态变为$(b, a - bc)$。也就是说我们既可以自己将状态变成$(b, a - bc)$，也可以通过对方之手变换，故这种状态是必胜的 那么就结束啦，细节自己判去（ Code1234567891011121314151617181920212223242526272829303132333435template &lt;typename Num&gt;void read(Num&amp; x){ char ch = 0; for (ch = getchar(); !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}template &lt;typename Num, typename ...List&gt;void read(Num&amp; x, List&amp; ...y){ read(x), read(y...);}int solve(int x, int y){ int f = 1; for (; ; ) { if (x &lt; y) std::swap(x, y); if (x % y == 0 || x - y &gt; y) return f; x -= y; f = !f; }}int main(){ int a = 0, b = 0; for (read(a, b); a &amp;&amp; b; read(a, b)) std::cout &lt;&lt; (solve(a, b) ? &quot;Stan&quot; : &quot;Ollie&quot;) &lt;&lt; &quot; wins&quot; &lt;&lt; std::endl; return 0;}","link":"/2019/05/24/POJ-2348/"},{"title":"「NOI2015」 品酒大会","text":"Solution显然答案具有后缀和性质考虑按$\\mathrm{height}$从大到小顺序处理，每次将两个后缀所在集合合并，计算$\\mathrm{hight}_t$相似的答案注意两个极小负数乘积也会极大 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109constexpr static int ___maxN = 300010;struct SuffixArray{ std::string st = &quot;&quot;; int len = 0, size = 0; int bucket[1000010], pos[1000010], sa[1000010], rank[1000010], height[1000010]; // Each array starts from 1 void radixSort() { for (int i = 1; i &lt;= size; ++i) bucket[i] = 0; for (int i = 1; i &lt;= len; ++i) ++bucket[rank[i]]; for (int i = 1; i &lt;= size; ++i) bucket[i] += bucket[i - 1]; for (int i = len; i; --i) sa[bucket[rank[pos[i]]]--] = pos[i]; } void getSA() { for (int i = 1; i &lt;= len; ++i) rank[i] = st[i], pos[i] = i; radixSort(); for (int w = 1, p = 0; p &lt; len &amp;&amp; w &lt;= len; size = p, w &lt;&lt;= 1) { p = 0; for (int i = len - w + 1; i &lt;= len; ++i) pos[++p] = i; for (int i = 1; i &lt;= len; ++i) if (sa[i] &gt; w) pos[++p] = sa[i] - w; radixSort(); std::swap(rank, pos); rank[sa[1]] = p = 1; for (int i = 2; i &lt;= len; ++i) rank[sa[i]] = pos[sa[i]] == pos[sa[i - 1]] &amp;&amp; pos[sa[i] + w] == pos[sa[i - 1] + w] ? p : ++p; } } void getHeight() { int j = 0, k = 0; for (int i = 1; i &lt;= len; ++i) { if (k) --k; j = sa[rank[i] - 1]; while (st[i + k] == st[j + k]) ++k; height[rank[i]] = k; } } void main(std::string __st, int __size = 127) { st = __st, len = st.length() - 1, size = __size; getSA(), getHeight(); }};int n;int a[___maxN], rt[___maxN], id[___maxN], size[___maxN];long long max[___maxN], min[___maxN], setMax[___maxN], ans[___maxN], sum[___maxN];std::string st;SuffixArray SA;int cmp(const int&amp; x, const int&amp; y){ return SA.height[x] &gt; SA.height[y];}int getRt(int x){ return rt[x] == x ? x : rt[x] = getRt(rt[x]);}void unite(int x, int y, int len){ x = getRt(x), y = getRt(y); rt[y] = x; sum[len] += 1ll * size[x] * size[y]; size[x] += size[y]; setMax[x] = std::max(setMax[x], std::max(setMax[y], std::max(1ll * max[x] * max[y], 1ll * min[x] * min[y]))); max[x] = std::max(max[x], max[y]); min[x] = std::min(min[x], min[y]); ans[len] = std::max(ans[len], setMax[x]);}int main(){ std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0); std::cin &gt;&gt; n &gt;&gt; st, st = ' ' + st; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i]; SA.main(st); for (int i = 1; i &lt;= n; ++i) max[i] = min[i] = a[i], ans[i] = setMax[i] = -1e18, id[i] = rt[i] = i, size[i] = 1; ans[n + 1] = ans[0] = -1e18; std::sort(id + 2, id + n + 1, cmp); for (int i = 2; i &lt;= n; ++i) unite(SA.sa[id[i]], SA.sa[id[i] - 1], SA.height[id[i]]); for (int i = n; ~i; --i) sum[i] += sum[i + 1], ans[i] = std::max(ans[i], ans[i + 1]); for (int i = 0; i &lt; n; ++i) std::cout &lt;&lt; sum[i] &lt;&lt; &quot; &quot; &lt;&lt; (!sum[i] ? 0 : ans[i]) &lt;&lt; std::endl; return 0;}","link":"/2019/05/29/NOI2015-%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A/"},{"title":"「POJ 2406 &amp; 1961」 Power Strings &amp; Period","text":"双倍经验 Solution2406再回顾一遍$\\pi$函数的定义显然，若一个串是由循环节构成的，为模式串真后缀 (停顿) 且为模式串前缀的串 (停顿) 的最长长度 (停顿) 即为模式串长减去循环节长那么做完了哇 1961把上文中 “模式串真后缀” 改为 “模式串某前缀的真后缀”，每个位置求一遍即可 Code虽然依然只跟$\\pi$函数有关但还是挂个KMP的名字吧 2406123456789void KMP(std::string s){ prefixFunction(s); int m = s.length() - 1; if (m % (m - pi[m]) == 0) std::cout &lt;&lt; m / (m - pi[m]) &lt;&lt; std::endl; else std::cout &lt;&lt; 1 &lt;&lt; std::endl;} 1961123456789101112void KMP(std::string s){ prefixFunction(s); int m = s.length() - 1; std::cout &lt;&lt; &quot;Test case #&quot; &lt;&lt; ++testCase &lt;&lt; std::endl; for (int i = 2; i &lt;= m; ++i) { if (pi[i] &amp;&amp; i % (i - pi[i]) == 0) std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; i / (i - pi[i]) &lt;&lt; std::endl; } std::cout &lt;&lt; std::endl;}","link":"/2019/05/29/POJ-2406-1961/"},{"title":"「POJ 2752」 Seek the Name, Seek the Fame","text":"这名字好中二啊 Solution考虑到前缀函数$\\pi$的定义：$\\pi_q$等于 (停顿) 是模式串前缀$P_q$的真后缀 (停顿) 且是模式串$P$的最长前缀的串 (停顿) 的长度显然$\\pi_{P.length}$符合题意，接下来根据$\\pi$迭代即可 Code虽然只跟$\\pi$函数有关但还是挂个KMP的名字吧 1234567891011121314151617181920212223242526272829303132333435int pi[400010];void prefixFunction(std::string s){ memset(pi, 0, sizeof pi); int m = s.length() - 1, k = 0; for (int q = 2; q &lt;= m; ++q) { while (k &amp;&amp; s[k + 1] != s[q]) k = pi[k]; if (s[k + 1] == s[q]) ++k; pi[q] = k; }}void KMP(std::string s){ prefixFunction(s); int x = s.length() - 1; std::priority_queue &lt;int, std::vector &lt;int&gt; , std::greater &lt;int&gt; &gt; q; while (pi[x]) q.push(pi[x]), x = pi[x]; while (q.size()) std::cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;, q.pop(); std::cout &lt;&lt; s.length() - 1&lt;&lt; std::endl;}int main(){ std::string s = &quot;&quot;; while (std::cin &gt;&gt; s) s = ' ' + s, KMP(s); return 0;}","link":"/2019/05/29/POJ-2752/"},{"title":"「SDOI2010」 古代猪文 - CRT + Lucas","text":"Link洛谷 2480 Solution题意即求$$G ^ {\\sum_{d | n}C_n^d},\\mathrm{mod},999911659$$ Step 1推广费马小定理可得$$G^{\\sum_{d | n}C_n^d,\\mathrm{mod},999911659} = G^{\\sum_{d | n}C_n^d,\\mathrm{mod},999911658},\\mathrm{mod},999911659$$ Step 2快速幂很好办，那么唯一的难点就是指数——模数不为质数，不能直接用Lucas Theorem再看一眼我们要求的指数$$\\sum_{d | n}C_n^d,\\mathrm{mod},999911658$$对于$d$我们采用$O(\\sqrt{n})$的方式暴力枚举，然后呢……似乎我们已经走入穷途末路了…… Step 3方便起见令$s = \\sum_{d | n}C_n^d, x = s ,\\mathrm{mod},999911659$分解$999911658 = 2 \\cdot 3 \\cdot 4679 \\cdot 35617$令$a_1 = s,\\mathrm{mod}, 2, a_2 = s,\\mathrm{mod}, 3, a_3 = s,\\mathrm{mod}, 4679, a_4 = s,\\mathrm{mod}, 35617$我们可以得到$$\\begin{cases}x \\equiv a_1 (\\mathrm{mod}, 2)\\\\x \\equiv a_2 (\\mathrm{mod}, 3)\\\\x \\equiv a_3 (\\mathrm{mod}, 4679)\\\\x \\equiv a_3 (\\mathrm{mod}, 35617)\\end{cases}$$求解出$x$即为指数 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;#define MOD 999911659template &lt;class T&gt;void Read(T &amp;x){ x = 0; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}long long n, g;long long frac[50010];void init(long long p){ frac[0] = 1; for (register long long i = 1; i &lt;= p; ++i) frac[i] = frac[i - 1] * i % p;}inline long long fastpow(long long base, long long index, long long p){ register long long ret = 1; while (index) { if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; } return ret;}inline long long inv(long long x, long long p){ return fastpow(x, p - 2, p);}inline long long C(long long x, long long y, long long p){ if (x &lt; y) return 0; else return frac[x] * inv(frac[y], p) * inv(frac[x - y], p) % p;}inline long long Lucas(long long x, long long y, long long p){ if (x &lt; y) return 0; else if (x &lt; p &amp;&amp; y &lt; p) return C(x, y, p); else return Lucas(x % p, y % p, p) * Lucas(x / p, y / p, p) % p;}inline long long CRT(vector &lt;long long&gt; &amp;a, vector &lt;long long&gt; &amp;b){ register long long ret = 0, m = MOD - 1; for (register int i = 0; i &lt; 4; ++i) ret = (ret + a[i] * (m / b[i]) % m * inv(m / b[i], b[i]) % m) % m; return (ret % m + m) % m;}inline long long sum(long long p){ vector &lt;long long&gt; a(4), b(4); b[0] = 2, b[1] = 3, b[2] = 4679, b[3] = 35617; for (register int j = 0; j &lt; 4; ++j) { init(b[j]); for (register int i = 1; i * i &lt;= n; ++i) { if (!(n % i)) { a[j] = (a[j] + Lucas(n, i, b[j])) % b[j]; if (i * i != n) a[j] = (a[j] + Lucas(n, n / i, b[j])) % b[j]; } } } return CRT(a, b) % p;}int main(){ Read(n), Read(g); if (!(g % MOD)) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; fastpow(g, sum(MOD), MOD)&lt;&lt; endl;}","link":"/2018/12/04/SDOI2010-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/"},{"title":"「SDOI2006」 保安站岗","text":"Link洛谷 2458 Solution对于某个节点，其被覆盖的情况有三种： 被其父节点覆盖 被自己覆盖 被其子节点覆盖 那么我们可按以下方式转移：设$f(0/1/2,i)$表示节点$i$被父节点/本身/子节点覆盖且其子树全被覆盖的最小代价，设$j$为其子节点，易得方程$$f(0,i)=\\sum\\min\\lbrace f(1,j),f(2,j)\\rbrace$$$$f(1,i)=\\sum\\min\\lbrace f(0,j),f(1,j),f(2,j)\\rbrace$$$$f(2,i)=f(1,k)+\\sum_{j\\neq k}\\min\\lbrace f(1,j),f(2,j)\\rbrace,f(1,k)=\\min\\lbrace f(1,j)\\rbrace$$ $f(2,i)$转移的细节依然令$j$为$i$的一个子节点思路即取一个最优的子节点强制性的使用它的$f(1,j)$来转移，其余的取最优方案有个细节千万注意：并非$f(1,j)$最小的$j$为最优，反例即为该点的$f(2,j)$远小于该点的$f(1,j)$值也就是我们强制选择的点就是$f(1,j)-f(2,j)$最小的点以$x$记录上述值，$y$记录是否选过$f(1,j)&lt;f(2,j)$的点（$j$本身覆盖优于$j$的子节点覆盖）若$y=0$，那么我们必须加上一个最小的$f(1,j)-f(2,j)$，否则代表我们已经选过最优的这种点了，不作改动 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, numi, ordi, soni;int w[1510], f[3][1510];vector &lt;int&gt; tree[1510];void dfs(int cur, int fr){ int x = 0x7f7f7f7f, y = 0; f[1][cur] = w[cur]; for (int i = 0; i &lt; tree[cur].size(); ++i) { int to = tree[cur][i]; if (to != fr) { dfs(to, cur), f[0][cur] += min(f[1][to], f[2][to]), f[1][cur] += min(f[0][to], min(f[1][to], f[2][to])); if (f[1][to] &lt; f[2][to]) ++y; else x = min(x, f[1][to] - f[2][to]); f[2][cur] += min(f[1][to], f[2][to]); } } if (!y) f[2][cur] += x;}int main(){ ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; ordi &gt;&gt; w[ordi] &gt;&gt; numi; for (; numi; --numi) cin &gt;&gt; soni, tree[ordi].push_back(soni), tree[soni].push_back(ordi); } dfs(1, 0); cout &lt;&lt; min(f[1][1], f[2][1]) &lt;&lt; endl; return 0;}","link":"/2018/10/26/SDOI2006-%E4%BF%9D%E5%AE%89%E7%AB%99%E5%B2%97/"},{"title":"「SDOI2013」 随机数生成器 - BSGS","text":"Link洛谷 3306 Solution大力推式子$$\\begin{aligned}X_{i + 1} &amp;\\equiv aX_i + b(\\mathrm{mod},p)\\notag\\\\X_{i + 1} + \\frac{b}{a} &amp;\\equiv aX_i + b + \\frac{b}{a}(\\mathrm{mod},p)\\notag\\\\aX_{i + 1} + b &amp;\\equiv a^2X_i + ab + b(\\mathrm{mod},p)\\notag\\\\X_{i + 2} &amp;\\equiv a^2X_i + ab + b(\\mathrm{mod},p)\\notag\\\\\\end{aligned}$$ 那么我们得到 $$\\begin{aligned}X_2 &amp;\\equiv aX_1 + b(\\mathrm{mod},p)\\notag\\\\X_3 &amp;\\equiv a ^ 2X_1 + ab + b(\\mathrm{mod},p)\\notag\\\\X_4 &amp;\\equiv a ^ 3X_1 + a ^ 2b + ab + b(\\mathrm{mod},p)\\notag\\\\\\dots\\notag\\\\X_i &amp;\\equiv a ^ {i - 1}X_1 + b\\sum_{j = 0} ^ {i - 2}a ^ j(\\mathrm{mod},p)\\notag\\\\\\end{aligned}$$ 也就是我们要判断如下方程是否有整数解，若有则求解 $$t \\equiv a ^ {i - 1}X_1 + b\\sum_{j = 0} ^ {i - 2}a ^ j(\\mathrm{mod},p)$$ 继续化化化 $$\\begin{aligned}t &amp;\\equiv a ^ {i - 1}X_1 + b\\sum_{j = 0} ^ {i - 2}a ^ j(\\mathrm{mod},p)\\notag\\\\t &amp;\\equiv a ^ {i - 1}X_1 + b\\frac{1 - a ^ {i - 1}}{1 - a}(\\mathrm{mod},p)\\notag\\\\t &amp;\\equiv a ^ {i - 1}X_1 + \\frac{b}{1 - a} - \\frac{b}{1 - a} \\cdot a^{i - 1}(\\mathrm{mod},p)\\notag\\\\t &amp;\\equiv a ^ {i - 1}(X_1 - \\frac{b}{1 - a}) + \\frac{b}{1 - a}(\\mathrm{mod},p)\\notag\\\\a ^ {i - 1} &amp;\\equiv \\frac{t - \\frac{b}{1 - a}}{X_1 - \\frac{b}{1 - a}}(\\mathrm{mod},p)\\notag\\\\\\end{aligned}$$ 大功告成，用BSGS求解出$i - 1$的值，由于$t$是第$i$项，答案加一即可 Detail 1对于$X_1 = t$时，直接输出$1$ Detail 2对于$a = 0$时，$X_i = b$ Detail 3对于$a = 1$时，有$X_i \\equiv X_1 + b(i - 1)(\\mathrm{mod},p)$那么求解$t - X_1 \\equiv b(i - 1)(\\mathrm{mod},p)$的系数$i - 1$即可注意当答案就是$p$的时候不要再模$p$了 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;template &lt;class I&gt;inline void Read(I &amp;x){ register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}long long NUMOFCASES, a, b, p, x, t, X, Y;long long fastpow(long long base, int index, int MOD){ register long long ret = 1; while (index) { if (index &amp; 1) ret = ret * base % MOD; base = base * base % MOD; index &gt;&gt;= 1; } return ret;}long long gcd(long long a, long long b){ return b ? gcd(b, a % b) : a;}long long inv(long long x, int MOD){ return fastpow(x, MOD - 2, MOD);}long long bsgs(long long a, long long b, int MOD){ a %= MOD, b %= MOD; std::map&lt;long long, long long&gt; map; register long long m = ceil(sqrt(MOD)), t = 1; for (register int i = 0; i &lt; m; ++i) { if (!map.count(t)) map[t] = i; t = t * a % MOD; } register long long k = inv(t, MOD), w = b; for (int i = 0; i &lt; m; ++i) { if (map.count(w)) return i * m + map[w]; w = w * k % MOD; } return -1;}int main(){ Read(NUMOFCASES); for (; NUMOFCASES; --NUMOFCASES) { Read(p), Read(a), Read(b), Read(x), Read(t); if (x == t) cout &lt;&lt; 1 &lt;&lt; endl; else if (a == 1) { t = (t - x + p) % p; if (t % gcd(b, p)) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; (t * inv(b, p) + 1 == p ? t * inv(b, p) + 1 : (t * inv(b, p) + 1) % p) &lt;&lt; endl; } else if (a == 0) { if (b == t) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; } else { long long ans = bsgs(a, ((t - b * inv(1 - a, p)) % p + p) % p * inv(((x - b * inv(1 - a, p)) % p + p) % p , p), p) % p; if (ans == -1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans + 1 &lt;&lt; endl; } }}","link":"/2018/12/04/SDOI2013-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"「SDOI2011」 计算器","text":"Link洛谷 2485 Solution1裸的快速幂取模 2令$d=\\gcd(a,n)$ 一个推论当且仅当$d|b$时，方程$ax\\equiv b(\\mathrm{mod},n)$对于未知量$x$有解 一个定理假设对某些整数$x’$和$y’$，有$d=ax’+ny’$。若$d|b$，则方程$ax\\equiv b(\\mathrm{mod},n)$的有一个解的值为$x_0$，这里$$x_0=x’(b/d),\\mathrm{mod},n$$ 证明根据$x’$的性质，即：$$ax\\equiv d(\\mathrm{mod},n)$$可得：$$\\begin{aligned}ax_0&amp;\\equiv ax’(b/d)(\\mathrm{mod},n)\\notag\\\\&amp;\\equiv d(b/d)(\\mathrm{mod},n)\\notag\\\\&amp;\\equiv b(\\mathrm{mod},n)\\notag\\end{aligned}$$因此$x_0$是方程$ax\\equiv b(\\mathrm{mod},n)$的一个解 解决那么对于询问2，用扩欧求方程$ax’+ny’=d$即可注意根据上面的一个推论，当$d$不整除$b$时该方程无解 3我们引入一个概念—— 离散对数若$g$是$\\mathrm{Z}_n^*$的一个原根且$a$是$\\mathrm{Z}_n^*$中的任意元素，则存在一个$z$，使得$g^z\\equiv a(\\mathrm{mod},n)$，则将$z$称为对模$n$到基$g$上的$a$的一个离散对数或指数说人话，也就是对于给定的$a,b,p$，存在一个$x$，使得$$a^x\\equiv b(\\mathrm{mod},p)$$则称$x$为$b$在模$p$意义下以$a$为底的离散对数 很显然本题就是让我们求$y$的离散对数，常用方法叫做BSGS——Baby Step-Giant Step BSGS拿出我们要解的关于$x$的方程：$$a^x\\equiv b(\\mathrm{mod},p)$$令$m=\\lceil \\sqrt{p}\\rceil$。根据费马小定理，有$a^{p-1}\\equiv 1(\\mathrm{mod},p)$故若方程有解，则必存在一个$0\\leq x&lt;p-1$根据除法的定义，令$x=im+j$，方程可化为： $$\\begin{aligned}a^x&amp;\\equiv b(\\mathrm{mod},p)\\notag\\\\a^{im+j}&amp;\\equiv b(\\mathrm{mod},p)\\notag\\\\a^j&amp;\\equiv b\\cdot a^{-im}(\\mathrm{mod},p)\\notag\\\\a^j&amp;\\equiv b\\cdot (a^{-m})^i(\\mathrm{mod},p)\\notag\\end{aligned}$$得到这玩意，我们就只需找到一组$i,j$使得最后一个式子成立即可那么我们先枚举$j$，递推出左边$a^j,\\mathrm{mod},p$的所有取值，并将其按照$(a^j,\\mathrm{mod},p)\\mapsto j$的映射关系插入到哈希表中之后求出$a^m,\\mathrm{mod},p$的乘法逆元，枚举$i$，递推出所有的$b\\cdot(a^{-m})^i$，每得到一个值后在哈希表内查找该值。若存在，取出对应的$j$，$x=im+j$即为一个解 Extra注意取模的时候可能有负数，并且应该先模$p$，具体见代码注释的那一行，卡了我35分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;long long T, K, y, z, p, gcd, X, Y;map &lt;long long, long long&gt; mp;inline long long fastpow(long long base, long long index){ long long ret = 1; while (index) { if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; } return ret;}inline void exgcd(long long a, long long b, long long &amp;d, long long &amp;x, long long &amp;y){ if (!b) d = a, x = 1, y = 0; else exgcd(b, a % b, d, y, x), y -= a / b * x;}inline long long inv(long long x){ return fastpow(x, p - 2);}inline long long bsgs(long long a, long long b){ if (!a) return b ? -1 : 1; mp.clear(); long long m = ceil(sqrt(p)), t = 1; for (long long i = 0; i &lt; m; i++) { if (!mp.count(t)) mp[t] = i; t = t * a % p; } long long k = inv(t), w = b; for (long long i = 0; i &lt; m; i++) { if (mp.count(w)) return i * m + mp[w]; w = w * k % p; } return -1;}int main(int argc, char ** argv){ ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; T &gt;&gt; K; while (T--) { cin &gt;&gt; y &gt;&gt; z &gt;&gt; p; if (K == 1) { cout &lt;&lt; fastpow(y, z) &lt;&lt; endl; } else if (K == 2) { exgcd(y, p, gcd, X, Y); if (z % gcd) cout &lt;&lt; &quot;Orz, I cannot find x!&quot; &lt;&lt; endl; else { cout &lt;&lt; (X * z / gcd % p + p) % p &lt;&lt; endl;//Important } } else { long long ans = bsgs(y % p, z % p); if (ans == -1) cout &lt;&lt; &quot;Orz, I cannot find x!&quot; &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; } } return 0;} 后记BSGS部分参考Menci的博客","link":"/2018/10/04/SDOI2011-%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"title":"「TJOI2009」 猜数字","text":"Solution经典的Chinese Remainder Theorem例题然而我并不是被CRT卡的，细节较多考虑将方程组变形$$\\begin{cases}x\\equiv a_1(\\mathrm{mod},b_1)\\\\x\\equiv a_2(\\mathrm{mod},b_2)\\\\\\dots\\\\x\\equiv a_k(\\mathrm{mod},b_k)\\end{cases}$$直接用CRT实现即可 Detail 1乘法会爆long long，须用快速龟速乘 Detail 2快读注意判负数 Detail 3$a_i$可能为负，为了方便实现，在使用时转为模$b_i$等价类的最小正元素 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;inline void Read(long long &amp;x){ x = 0; register char ch = getchar(); register int flag = 0; while (!isdigit(ch)) flag = (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if (flag) x = -x;}long long mul(long long a, long long b, long long MOD){ long long ret = 0; while (a) { if (a &amp; 1) (ret += b) %= MOD; (b += b) %= MOD; a &gt;&gt;= 1; } return ret;}long long k, s = 1, n;long long a[110], b[110];void exgcd(long long a, long long b, long long &amp;x, long long &amp;y){ if (!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x;}int main(){ Read(k); for (int i = 1; i &lt;= k; ++i) Read(a[i]); for (int i = 1; i &lt;= k; ++i) Read(b[i]), s *= b[i]; for (int i = 1; i &lt;= k; ++i) { register long long m = s / b[i], x, y; exgcd(m, b[i], x, y); (n += mul(mul((a[i] % b[i] + b[i]) % b[i], m, s), x, s)) %= s; } cout &lt;&lt; (n + s) % s &lt;&lt; endl; return 0;}","link":"/2018/11/16/TJOI2009-%E7%8C%9C%E6%95%B0%E5%AD%97/"},{"title":"「ZJOI2013」 K大数查询","text":"整体二分裸题 Solution所谓整体二分，需要数据结构题满足一下性质 询问的答案具有可二分性 修改对判定答案的贡献互相独立，修改之间互不影响效果 修改如果对判定答案有贡献，则贡献为一确定的与判定标准无关的值 贡献满足交换律、结合律，具有可加性 题目允许离线算法 论文中还提到我们在处理的过程中，复杂度绝对不能和序列总长$n$线性相关，只能和当前处理序列区间的长度相关一个显然的推论就是我们清空辅助的数据结构 (如BIT等) 不能直接清空而要逆向地加 / 减回去 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;template &lt;typename T&gt;void read(T&amp; x){ char c = getchar(); int minus = 0; for (x = 0; !isdigit(c); minus |= (c == '-'), c = getchar()); for (; isdigit(c); x = x * 10 + (c ^ 48), c = getchar()); if (minus) x = -x;} // void read()template &lt;typename Cur, typename ...List&gt;void read(Cur&amp; x, List&amp; ...y){ read(x), read(y...);} // void read()struct Operation{ long long op, l, r, x, id; Operation(long long op = 0, long long l = 0, long long r = 0, long long x = 0, int id = 0) : op(op), l(l), r(r), x(x), id(id) {}}; // struct Operationint n, m, queryNum;long long ans[50010], cur[50010];class BIT{private: long long b1[50010], b2[50010];public: void update(long long pos, long long val) { for (int i = pos; i &lt;= n; i += i &amp; -i) b1[i] += val, b2[i] += val * pos; } long long query(long long pos) { long long res = 0; for (int i = pos; i; i -= i &amp; -i) res += (pos + 1) * b1[i] - b2[i]; return res; }}; // class BIT::BIT bit;::Operation o[50010], o1[50010], o2[50010];void solve(long long rL, long long rR, int qL, int qR){ if (rL &gt; rR || qL &gt; qR) return; if (rL == rR) { for (int i = qL; i &lt;= qR; ++i) ans[o[i].id] = rL; return; } long long mid = rL + rR &gt;&gt; 1; for (int i = qL; i &lt;= qR; ++i) if (o[i].op == 1 &amp;&amp; o[i].x &gt; mid) bit.update(o[i].l, 1), bit.update(o[i].r + 1, -1); else if (o[i].op == 2) cur[i] = bit.query(o[i].r) - bit.query(o[i].l - 1); for (int i = qL; i &lt;= qR; ++i) if (o[i].op == 1 &amp;&amp; o[i].x &gt; mid) bit.update(o[i].l, -1), bit.update(o[i].r + 1, 1); int t1 = 0, t2 = 0; for (int i = qL; i &lt;= qR; ++i) if (o[i].op == 2) { if (cur[i] &gt;= o[i].x) o2[++t2] = o[i]; else o[i].x -= cur[i], o1[++t1] = o[i]; } else { if (o[i].x &lt;= mid) o1[++t1] = o[i]; else o2[++t2] = o[i]; } for (int i = 1; i &lt;= t1; ++i) o[qL + i - 1] = o1[i]; for (int i = 1; i &lt;= t2; ++i) o[qL + t1 + i - 1] = o2[i]; solve(rL, mid, qL, qL + t1 - 1); solve(mid + 1, rR, qL + t1, qR);} // void solve()int main(){ std::ios::sync_with_stdio(0); std::cout.tie(0); read(n, m); for (int i = 1; i &lt;= m; ++i) { int op = 0, a = 0, b = 0, c = 0; read(op, a, b, c); o[i] = Operation(op, a, b, c, op == 2 ? ++queryNum : 0); } solve(-n, n, 1, m); for (int i = 1; i &lt;= queryNum; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; std::endl; return 0;} Reference 2013年信息学奥林匹克中国国家队候选队员论文《浅谈数据结构题的几个非经典解法》，许昊然，南京外国语学校","link":"/2019/08/02/ZJOI2013-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2/"},{"title":"Windows WSL 折腾记","text":"安装Win + X，管理员模式进入Powershell后 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 输入用户名时，注意首字母小写等，否则会有如下错误信息 123adduser: Please enter a username matching the regular expression configuredvia the NAME_REGEX[_SYSTEM] configuration variable. Use the `--force-badname'option to relax this check or reconfigure NAME_REGEX. 乱搞获取root权限进入系统后，如果直接 1$ su 会出现 1su: Authentication failure 别问我为啥，更新一遍密码就行（可以相同） 12$ sudo passwd root$ su 这样就有root权限了（过于鬼畜 切换软件源先做个备份 1234# cd ..# cd ..# cd etc/apt# vim sources.list Vim添加如下内容至sources.list 12345678deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse 之后保存退出 12# apt-get update# apt-get upgrade 重启Win + R，services.msc进入服务后找到LxssManager项重启 重装在Powershell里输入 1wslconfig /unregister Ubuntu 即可","link":"/2019/08/11/Windows-WSL-%E6%8A%98%E8%85%BE%E8%AE%B0/"},{"title":"「TJOI2015」 概率论","text":"Solution令$g(i)$表示有$i$个节点的不同形态的树的个数令$f(i)$表示有$i$个节点的不同形态的树的叶子节点的总个数那么答案即为$f(i) / g(i)$ $g$不难想到，有$$g(n) = \\sum_{i}g(i)g(n - i - 1) + [n = 0]$$看出来这玩意是个卷积哇令$G(z)$为$g$的OGF，两边同时乘上$z ^ n$，有$$\\begin{aligned}G(z) &amp;= \\sum_{n}g(n)z ^ n \\notag \\\\&amp;= \\sum_{i, n}g(i)g(n - i - 1)z ^ n + \\sum_{n = 0}z ^ n \\notag \\\\&amp;= \\sum_ig(i)z ^ i\\sum_ng(n - i - 1)z ^ {n - i} + 1 \\notag \\\\&amp;= G(z) \\cdot zG(z) + 1 \\notag\\end{aligned}$$解得$$G(z) = \\frac{1\\pm\\sqrt{1 - 4z}}{2z}$$因为$G(0) = 1$，对两式分别求极限$$\\begin{aligned}\\lim_{z\\to 0^+}\\frac{1+\\sqrt{1 - 4z}}{2z} = +\\infty \\notag \\\\\\lim_{z\\to 0^+}\\frac{1-\\sqrt{1 - 4z}}{2z} = 1\\notag\\end{aligned}$$故取$G(z) = \\frac{1-\\sqrt{1 - 4z}}{2z}$由二项式定理，得$$\\begin{aligned}\\sqrt{1 - 4z} &amp;= \\sum_{i \\ge 0}\\binom{1 / 2}{i}(-4z) ^ i\\notag\\\\&amp;= 1 + \\sum_{i \\ge 1}\\frac{1}{2i}\\binom{-1 / 2}{i - 1}(-4z) ^ i\\notag\\end{aligned}$$由于$$\\binom{-1/2}{n} = \\binom{-1}{4} ^ n\\binom{2n}{n}$$故$$\\begin{aligned}\\frac{1 - \\sqrt{1 - 4z}}{2z} &amp;= \\sum_{i \\ge 1}\\frac{1}{i}\\binom{-1 / 2}{i - 1}(-4z) ^ {i - 1}\\notag \\\\&amp;=\\sum_{n \\ge 0}\\binom{-1 / 2}{n}\\frac{(-4z) ^ n}{n + 1}\\notag \\\\&amp;=\\sum_{n \\ge 0}\\binom{2n}{n}\\frac{z ^ n}{n + 1}\\notag\\end{aligned}$$故$$g(n) = [z ^ n]G(z) = \\binom{2n}{n}\\frac{1}{n + 1}$$ $f$搞完$g$来搞$f$哇依然不难想到$$f(n) = 2\\sum_{i = 0}^{n - 1}f(i)g(n - i - 1)$$令$F(z)$为$f$的OGF，推导略，得$$F(z) = 2zF(z)G(z) + z = z(1 - 4z) ^ {- 1 / 2}$$观察到$$(zG(z))’ = \\frac{1}{\\sqrt{1 - 4z}} = \\frac{F(z)}{z}$$故$$f(n) = ng(n - 1)$$","link":"/2019/03/16/TJOI2015-%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"title":"扑棱蛾子 CG 提取","text":"又开始不务正业了 Preface柚子厨一只，没了 Preparation crass expimg KrkrExtract MainStep 1把 KrkrExtract.exe 和 KrkrExtract.dll 丢到游戏根目录里面，把游戏可执行文件拖到 KrkrExtract.exe 上打开 然后点击 !!Dump!!，等待之后把目录下的 KrkrExtract_Output 文件夹拖出来 Step 2KrkrExtract_Output 里面有相当多的东西，比方说场景在 bgimage 里面等等，但是我们需要的是立绘，在 evimage 里面 里面 png 文件是萌版的， pimg 文件是立绘。把 pimg 文件弄出来之后，写个程序搜集目录下所有文件名以便批处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;io.h&gt;using namespace std;#define MAX_PATH 80void getFiles( string path, vector&lt;string&gt;&amp; files ) { //文件句柄 long hFile = 0; //文件信息 struct _finddata_t fileinfo; string p; if((hFile = _findfirst(p.assign(path).append(&quot;\\\\*&quot;).c_str(),&amp;fileinfo)) != -1) { do { //如果是目录,迭代之 //如果不是,加入列表 if((fileinfo.attrib &amp; _A_SUBDIR)) { if(strcmp(fileinfo.name,&quot;.&quot;) != 0 &amp;&amp; strcmp(fileinfo.name,&quot;..&quot;) != 0) getFiles( p.assign(path).append(&quot;\\\\&quot;).append(fileinfo.name), files ); } else { files.push_back(p.assign(path).append(&quot;\\\\&quot;).append(fileinfo.name) ); } }while(_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); } }int main(){ freopen(&quot;filenames_pimg.txt&quot;, &quot;w&quot;, stdout); vector&lt;string&gt; files; char * filePath = &quot;U:\\\\pimg&quot;; ////获取该路径下的所有文件 getFiles(filePath, files); char str[30]; int size = files.size(); for (int i = 0;i &lt; size;i++) { cout&lt;&lt;files[i].c_str()&lt;&lt;endl; } return 0;} 其中 char * filePath = 后面是存放 pimg 文件的目录，注意斜杠要双的 这个程序写的相当丑（网上复制的），而且似乎会把子文件夹和父文件夹以及自身给读取了，所以 filenames_pimg.txt 需要人工处理一下 Step 3其实 2 3 两步可以合起来，不过网上抄的就懒得改了 修改 filenames_pimg.txt 做成批处理 12345678910111213141516#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;int main(){ freopen(&quot;filenames_pimg.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;commands.bat&quot;, &quot;w&quot;, stdout); std::string s = &quot;&quot;; for (; std::cin &gt;&gt; s; ) { std::cout &lt;&lt; &quot;D:\\\\tools\\\\expimg\\\\expimg.exe&quot; &lt;&lt; &quot; &quot; &lt;&lt; s &lt;&lt; std::endl; } return 0;} 这才是我的码风，比上面的不知道高到哪里去了 std::cout 后面是 expimg.exe 工具所在的位置，依然是双斜杠 处理完之后运行批处理，然后进入 expimg 工具所在目录，把解包出来的 tlg 文件全部弄出来 Step 4接下来就是用 crass 解 tlg 了 神奇的是不知道为什么，控制台用 crage.exe 一直有问题，因此选择 GUI 版的 Step 53500+文件，里面有一大半都是表情图层，可以自行合并也可以全删了 留下来 469 张就是 CG 了 Postscript一开始试图用 xp3tools 解包，但似乎 16 进制文件头被改了，于是作罢。这种套路之前见过，当时放弃了，现在发现也不是没有解决的方法 柚子社 CG 确实耐看。柚子社天下第一！ SM.MS 不让上传 5M 以上的图，用 waifu2x 1.0x 转成 png 竟然就成了 2.8M 的……顺便吐槽一下 SM.MS 变得慢的要命","link":"/2020/03/31/%E6%89%91%E6%A3%B1%E8%9B%BE%E5%AD%90-CG-%E6%8F%90%E5%8F%96/"},{"title":"「网络流 24 题」 搭配飞行员","text":"SolutionAnalysis这道题的建模还是很好建的正驾驶和副驾驶配对就从正驾驶往副驾驶连一条边然后建立Super Source往正驾驶连边和Super Sink从副驾驶连边跑一遍最大流即可毒瘤你谷要求输出方案，只需检查跑完最大流后的网络的边的流量即可，下面的代码检查的是反向边流量 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;struct Edge{ int v, w, next; Edge(int v = 0, int w = 0, int next = 0) : v(v), w(w), next(next) {}};int cntEdge = -1, n, m, t, s = 0, a, b, ans;int head[1000010], d[1000010], num[1000010], u[1000010];Edge edge[1000010];void addEdge(int u, int v, int w){ edge[++cntEdge] = Edge(v, w, head[u]), head[u] = cntEdge;}void bfs(){ std::queue &lt;int&gt; q; q.push(t), ++num[d[t] = 1]; while (q.size()) { int x = q.front(); q.pop(); for (int i = head[x]; i != -1; i = edge[i].next) { int y = edge[i].v; if (!d[y] &amp;&amp; !edge[i].w) ++num[d[y] = d[x] + 1], q.push(y); } }}int dfs(int cur, int aug){ if (!aug || cur == t) return aug; int ret = 0, f = 0; for (int i = head[cur]; i != -1; i = edge[i].next) { int y = edge[i].v; if (d[cur] == d[y] + 1 &amp;&amp; (f = dfs(y, std::min(aug, edge[i].w)))) { augPair[cur][y] = 1; aug -= f, ret += f, edge[i].w -= f, edge[i ^ 1].w += f; if (!aug) return ret; } } if (!(--num[d[cur]])) d[s] = n + 3; ++num[++d[cur]]; return ret;}int main(){ std::ios::sync_with_stdio(0); std::cin.tie(0); memset(head, -1, sizeof head); std::cin &gt;&gt; m &gt;&gt; n; t = n + 1; for (int i = 1; i &lt;= m; ++i) addEdge(s, i, 1), addEdge(i, s, 0); for (int i = m + 1; i &lt;= n; ++i) addEdge(i, t, 1), addEdge(t, i, 0); while (std::cin &gt;&gt; a &gt;&gt; b &amp;&amp; a != -1) addEdge(a, b, 1), addEdge(b, a, 0); bfs(); while (d[s] &lt;= n + 2) ans += dfs(s, 0x7f7f7f7f); std::cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; for (int i = n * 2; i &lt;= cntEdge; i += 2) if (edge[i ^ 1].w) std::cout &lt;&lt; edge[i ^ 1].v &lt;&lt; &quot; &quot; &lt;&lt; edge[i].v &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2019/03/02/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E6%90%AD%E9%85%8D%E9%A3%9E%E8%A1%8C%E5%91%98/"},{"title":"「网络流 24 题」 最长递增子序列","text":"Solution注意，本题中递增子序列非严格递增 AnalysisTask 1显然的经典DP令$f(i)$表示选择$a_i$作为递增子序列的最后一个数所能得到的最长长度，易得$$f(i) = \\max_{j &lt; i, a_j \\le a_i}\\lbrace f(j)\\rbrace + 1$$长度$\\max\\lbrace f(i)\\rbrace$记作$s$ Task 2我们考虑子序列是怎么生成的：设当前序列的结尾是$a_i$，往后拓展序列时，我们会选择$a_i \\le a_j, i &lt; j$的$a_j$于是我们将所有$a_i \\le a_j, i &lt; j$的点对$(i, j)$连边，形成的图记作$G$对于所有入度为$0$的点 从Super Source向其连边，容量均为$1$。表示可以从这个点开始进行子序列的选择 从这个点进行BFS，找出$G$中从该点经$s - 1$个点能到达的全部点，打上标记。表示该点与搜索出的点能形成$s$个点组成的路径，即能构造出长度为$s$的子序列 接着对于打上标记的点，向Super Sink连边，容量均为$1$跑一遍最大流即可 Task 3这就简单了，将Super Source向$1$的边与$n$向Super Sink的容量设为$+\\infty$即可 Find the BugWA了，不过分还比较高一定是哪里出问题了……没错！一个点可以作为向Super Sink连边的点，同时也可以向后面的点连边，这就会导致流量变大怎么解决？跳过中间的组成序列的那些点！我们只关心一个序列的开头和结尾，将其连边即可Super Source/Sink的连边规则不变 Extra丧心病狂的$n = 1$的点，特判即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;struct Edge{ int from, to, capa, next; Edge(int from = 0, int to = 0, int capa = 0, int next = 0) : from(from), to(to), capa(capa), next(next) {}};int n, len, s, t, cntEdge = -1, cur;int a[510], tag[510], indeg[510], num[1010], d[510], head[1000010];Edge edge[1000010];std::vector &lt;int&gt; zeroDeg;std::vector &lt;int&gt; g[510];std::map &lt;int, int&gt; map;void getLen(){ int f[510]; for (int i = 1; i &lt;= n; ++i) { f[i] = 1; for (int j = 1; j &lt; i; ++j) if (a[i] &gt;= a[j] &amp;&amp; f[i] &lt;= f[j]) f[i] = f[j] + 1; len = std::max(len, f[i]); } std::cout &lt;&lt; len &lt;&lt; &quot;\\n&quot;;}void addEdge(int x, int y, int z){ edge[++cntEdge] = Edge(x, y, z, head[x]), head[x] = cntEdge; edge[++cntEdge] = Edge(y, x, 0, head[y]), head[y] = cntEdge;}void findNode(int x, int y){ if (y == len) { map[x] = 1; addEdge(cur, x, 1); return; } for (auto i : g[x]) findNode(i, y + 1);}void buildNetwork(){ for (auto i : zeroDeg) addEdge(s, i, 1), cur = i, findNode(i, 1); for (auto&amp; i : map) addEdge(i.first, t, 1);}void bfs(){ std::queue &lt;int&gt; q; q.push(t), ++num[d[t] = 1]; while (q.size()) { int x = q.front(); q.pop(); for (int i = head[x]; ~i; i = edge[i].next) { int to = edge[i].to; if (!d[to] &amp;&amp; !edge[i].capa) ++num[d[to] = d[x] + 1], q.push(to); } }}int dfs(int x, int aug){ if (!aug || x == t) return aug; int res = 0, f = 0; for (int i = head[x]; ~i; i = edge[i].next) { int to = edge[i].to; if (d[x] == d[to] + 1 &amp;&amp; (f = dfs(to, std::min(aug, edge[i].capa)))) { aug -= f, res += f, edge[i].capa -= f, edge[i ^ 1].capa += f; if (!aug) return res; } } if (!(--num[d[x]])) d[s] = n + 3; ++num[++d[x]]; return res;}void maxFlow(){ memset(d, 0, sizeof d); memset(num, 0, sizeof num); int res = 0; bfs(); while (d[s] &lt;= n + 2) res += dfs(s, 0x7f7f7f7f); std::cout &lt;&lt; (res == 0x7f7f7f7f ? 1 : res) &lt;&lt; &quot;\\n&quot;;}void rebuildNetwork(){ for (int i = 0; i &lt;= cntEdge; i += 2) { edge[i].capa = 1, edge[i ^ 1].capa = 0; if (edge[i].from == n &amp;&amp; edge[i].to == t) edge[i].capa = 0x7f7f7f7f; else if (edge[i].from == 0 &amp;&amp; edge[i].to == 1) edge[i].capa = 0x7f7f7f7f; }}int main(){ memset(head, -1, sizeof head); std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n; s = 0, t = n + 1; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i]; getLen(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt; i; ++j) if (a[i] &gt;= a[j]) ++indeg[i], g[j].push_back(i); if (!indeg[i]) zeroDeg.push_back(i); } buildNetwork(); maxFlow(); rebuildNetwork(); maxFlow(); return 0;}","link":"/2019/03/02/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"第 1 届全俄罗斯数学奥林匹克","text":"AFO 后整点活题目来自苏淳先生编著的《苏联中学生数学奥林匹克试题汇编》，部分答案有参考俄罗斯 / 苏联的题还是很有趣的只不过大多不会做罢了 1法 1退役 OIer 表示建图我熟 考虑将矩形视作图的点，矩形间的公共线段视作连接两点的边，再加上表示外界的类超级源点，本质就是该图的一笔画问题 建出来的图中奇度数点的个数大于 2，故不可能一笔画 法 2考虑一个矩形，如果由奇数条线段组成，则折线的起 / 终点必有且仅有其一在矩形内 图中有三个矩形由奇数条线段组成，故不存在 2取矩形中点 $O$，显然有 $O$ 到 1, 3 二圆切线的距离 $d_1 = \\dfrac{r_1+r_3}{2}$，到 2, 4 二圆切线的距离 $d_2 = \\dfrac{r_2+r_4}{2}$ 又 $r_1+r_3 = r_2+r_4$，有 $d_1 = d_2$，即存在内切圆，其圆心为 $O$，半径为 $d_1 = d_2$ 3考虑前 20 个数中，必然存在一个个位为 0 且十位非 9 的数，设其数位和为 $s$，则该数往后数 19 个数必然能得到 10 个数位和 $s + 1, \\cdots, s + 10$ 再加上其本身的数位和 $s$，知这 11 个连续自然数中必然有一个被 11 整除 4只需构造一个删除任意两行后都有三列存在星号的图形即可，方式有很多，如$(1, 1), (1, 2), (2, 4), (3, 1), (3, 3), (4, 2), (4, 3)$ 星号个数小于 7 时，分两种情况 存在某行 / 列上有 3 个星号。此时删去该行，只剩三个星号，一个一个删即可 每行 / 列至多有 2 个星号。由容斥原理，必有两行与两列中有 2 个星号，删去这两行 / 列后还剩两个星号，一个一个删即可。 55a令 $p = abcd$，则第二组的四个元素乘积为 $p^2$，第三组为 $p^4$。以此类推，显然若 $p\\neq 1$，则不可能复现 接下来模拟 1 2 3 4 $a$ $b$ $c$ $d$ $ab$ $bc$ $cd$ $da$ $ab^2c$ $bc^2d$ $cd^2a$ $da^2b$ $ab^3c^3d = b^2c^2$ $bc^3d^3a = c^2d^2$ $cd^3a^3b = d^2a^2$ $da^3b^3c = a^2b^2$ 可见，题中的操作过程本质上是对第二组数的不断平方并重排。故若第二组数中有不为 1 的数，之后的迭代过程中（第 $2k$ 组中对应的项）必然会无限增长 / 减小，这样就不存在周期，即不可能复现。故有 $$ab = bc = cd = da = 1$$ 结合 $abcd = 1$，可知 $a = b = c = d = 1$ 5b看吧我都说这两问简直毫无关系 一开始想归纳，觉得显然不可做，事实证明还是我太菜了 &amp; 还是跟上一问有关系的（ 考虑归纳，显然 $n = 1$ 时成立 假设 $n = k$ 时成立，模拟 $n = k + 1$ 的情况 1 2 3 4 $\\cdots$ $a_1$ $a_2$ $a_3$ $a_4$ $\\cdots$ $a_1a_2$ $a_2a_3$ $a_3a_4$ $a_4a_5$ $\\cdots$ $a_1a_2^2a_3 = a_1a_3$ $a_2a_3^2a_4 = a_2a_4$ $a_3a_4^2a_5 = a_3a_5$ $a_4a_5^2a_6 = a_4a_6$ $\\cdots$ 经观察，我们可以认为是 $a_1a_3, a_2a_4, \\cdots$ 将 $a_2, a_3, \\cdots$ 作为桥梁来实现合并，因而该操作过程本质上是 ${a_1, a_3, a_5, \\cdots, a_{2^{k+1}}-1}$ 和 ${a_2, a_4, a_6, \\cdots, a_{2^{k+1}}}$ 这两个长度为 $2^k$ 的数列的变化。由归纳假设，知 $n = k + 1$ 时命题也成立 5a 和 5b 的共性在于模拟后通过观察，找出变换的本质 66a坑了，几何题真的毫无思路 6b我不会几何法，所以我选择解析 设 $\\triangle ABC$ 的边长为 $2a$，$A(0, a), B(0, -a), C(\\sqrt3a, 0)$。其中 $2a\\le 5\\Rightarrow a\\le \\dfrac{5}{2}$ 由 $AP = 2, BP = 3$，写出两圆的方程 $$\\begin{cases} x^2 + (y - a)^2 = 4\\\\ x^2 + (y + a)^2 = 9\\end{cases}$$由于要使 $|CP|$ 最大，取二圆左侧交点，即 $$P(\\dfrac{-\\sqrt{104a^2-16a^4-25}}{4a}, \\dfrac{5}{4a})$$ 则 $$|CP|^2 = (-x_P + \\sqrt 3a)^2 + y_P^2 = \\dfrac{13}{2} + 2a^2 + \\dfrac{\\sqrt 3\\sqrt{104a^2-16a^4-25}}{2}$$ 换元，令 $t = a^2$，知 $0 &lt; t\\le \\dfrac{25}{4}$令 $f(t) = |CP|^2 = \\dfrac{13}{2} + 2t + \\dfrac{\\sqrt3}{2}\\sqrt{104t-16t^2-25}$ $$ f’(t) = 2 + \\dfrac{\\sqrt{3}(104-32t)}{4\\sqrt{104t-16t^2-25}}\\\\ f’’(t) = 2\\sqrt3\\times\\dfrac{-4\\sqrt{104t-16t^2-25}-\\dfrac{13-4t(104-32t)}{2\\sqrt{104t-16t^2-25}}}{104t-16t^2-25}$$ 令 $m = \\sqrt{104t-16t^2-25}$ $$\\begin{aligned}f’’(t) &amp;= 2\\sqrt3\\times\\dfrac{-4m^2-\\dfrac{1}{2}(13-4t)(104-32t)}{m^3}\\\\&amp;= 2\\sqrt3\\times\\dfrac{(-416t+64t^2+100-676+416t-64t^2)}{m^3}\\\\&amp;= 2\\sqrt3\\times\\dfrac{-576}{m^3} &lt; 0\\end{aligned}$$ 故 $f’(t)$ 单调减，而 $$f’(4) = 2 + 2\\sqrt3\\times\\dfrac{-3}{\\sqrt{416-256-25}} = 2 - \\sqrt{\\dfrac{108}{135}} &gt; 2 - \\sqrt4 = 0\\\\f’(5) = 2 + 2\\sqrt3\\times\\dfrac{-7}{\\sqrt{520-400-25}} = 2 - \\sqrt{\\dfrac{588}{95}} &lt; 2 - \\sqrt4 = 0$$ 故 $f’(t)$ 在 $(4, 5)$ 内有唯一零点 $t_0$由 $f’(t_0) = 0$，得 $$\\sqrt3(4t_0-13) = \\sqrt{104t_0-16t_0^2-25}$$ 知 $4t_0 - 13 &gt; 0$，化简得 $$(4t_0-19)(4t_0-7) = 0$$ 故解得 $t_0 = \\dfrac{19}{4}$，故 $$f(t)_{\\mathrm{max}} = f(\\dfrac{19}{4}) = 25$$ 即 $$d_{\\mathrm{max}} = \\sqrt{25} = 5$$","link":"/2021/02/13/%E7%AC%AC-1-%E5%B1%8A%E5%85%A8%E4%BF%84%E7%BD%97%E6%96%AF%E6%95%B0%E5%AD%A6%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B/"},{"title":"「网络流 24 题」 负载平衡","text":"Digression本题可以用一种奇特的初中奥数方法乱搞，有兴趣读者可以去洛谷上看题解 SolutionAnalysis一下想到费用流哇设$\\overline{a}$为输入数据的平均数，则对于每个仓库只可能有两种情况（不考虑相等）：$a_i &lt; \\overline{a}$或$a_i &gt; \\overline{a}$ 我们考虑 $a_i &lt; \\overline{a}$即仓库$i$需要有流量汇入，且流量为$\\overline{a} - a_i$ $a_i &gt; \\overline{a}$即仓库$i$需要有流量流出，且流量为$a_i - \\overline{a}$ 于是建立Super Sink从每个需汇入点连边，Super Source向每个需流出点连边，容量皆为$|\\overline{a} - a_i|$相邻的仓库别忘连边哇 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cmath&gt;struct Edge{ int to, capa, cost, next; Edge (int to = 0, int capa = 0, int cost = 0, int next = 0) : to(to), capa(capa), cost(cost), next(next) {}};int n, cntEdge = -1, minCost, s, t, tot;int head[100010], dis[100010], vis[100010], a[110];Edge edge[100010];void addEdge(int u, int v, int capa, int cost){ edge[++cntEdge] = Edge(v, capa, cost, head[u]), head[u] = cntEdge; edge[++cntEdge] = Edge(u, 0, -cost, head[v]), head[v] = cntEdge;}int SPFA(){ memset(vis, 0, sizeof vis); memset(dis, 0x7f7f7f7f, sizeof dis); dis[t] = 0, vis[t] = 1; std::deque &lt;int&gt; q; q.push_back(t); while (q.size()) { int x = q.front(); q.pop_front(); for (int i = head[x]; ~i; i = edge[i].next) { if (edge[i ^ 1].capa &amp;&amp; dis[edge[i].to] &gt; dis[x] - edge[i].cost) { dis[edge[i].to] = dis[x] - edge[i].cost; if (!vis[edge[i].to]) { vis[edge[i].to] = 1; if (q.size() &amp;&amp; dis[edge[i].to] &lt; dis[q.front()]) q.push_front(edge[i].to); else q.push_back(edge[i].to); } } } vis[x] = 0; } return dis[s] &lt; 0x7f7f7f7f;}int dfs(int x, int aug){ vis[x] = 1; if (x == t) return aug; int f = 0, res = 0; for (int i = head[x]; ~i; i = edge[i].next) { if (edge[i].capa &amp;&amp; !vis[edge[i].to] &amp;&amp; dis[x] - edge[i].cost == dis[edge[i].to]) { f = dfs(edge[i].to, std::min(aug, edge[i].capa)); minCost += f * edge[i].cost; edge[i].capa -= f, edge[i ^ 1].capa += f, aug -= f, res += f; if (!aug) break; } } return res;}void costFlow(){ while (SPFA()) { vis[t] = 1; while (vis[t]) memset(vis, 0, sizeof vis), dfs(s, 0x7f7f7f7f); } std::cout &lt;&lt; minCost &lt;&lt; &quot;\\n&quot;;}int main(){ std::ios::sync_with_stdio(0); std::cin.tie(0); memset(head, -1, sizeof head); std::cin &gt;&gt; n; s = 0, t = n + 1; for (int i = 1; i &lt;= n; ++i) std::cin &gt;&gt; a[i], tot += a[i], addEdge(i, i == n ? 1 : i + 1, 0x7f7f7f7f, 1), addEdge(i, i == 1 ? n : i - 1, 0x7f7f7f7f, 1); tot /= n; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt;= tot) addEdge(s, i, a[i] - tot, 0); else addEdge(i, t, tot - a[i], 0); costFlow(); return 0;}","link":"/2019/03/02/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1/"},{"title":"「网络流 24 题」 软件补丁","text":"SolutionAnalysis$n \\le 20$……状压！这题目最短路建模挺好想的毕竟我这种状压都没写过的人都会写令第$i$位$0/1$ 对于搜索状态，表示当前无/有错误$i$ 对于补丁，表示否/是引进新错误$i$ 然后跑一遍SPFA，边跑边建边……不用存边…… Attention字符串不要用getchar()读，Windows和Linux的**问题！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;int n, m;int b1[110], b2[110], f1[110], f2[110], a[110], f[(1 &lt;&lt; 20) + 10], vis[(1 &lt;&lt; 20) + 10];std::string A, B;void SPFA(){ std::queue &lt;int&gt; q; q.push((1 &lt;&lt; n) - 1); f[(1 &lt;&lt; n) - 1] = 0; while (q.size()) { int x = q.front(), y = 0; q.pop(); vis[x] = 0; for (int i = 1; i &lt;= m; ++i) { if ((b1[i] &amp; x) == b1[i] &amp;&amp; (b2[i] &amp; x) == 0) { y = ((x | f1[i]) ^ f1[i]) | f2[i]; if (f[x] + a[i] &lt; f[y]) { f[y] = f[x] + a[i]; if (!vis[y]) vis[y] = 1, q.push(y); } } } } std::cout &lt;&lt; (f[0] == 0x7f7f7f7f ? 0 : f[0]) &lt;&lt; &quot;\\n&quot;;}int main(){ std::ios::sync_with_stdio(0); std::cin.tie(0); std::cin &gt;&gt; n &gt;&gt; m; memset(f, 0x7f7f7f7f, sizeof f); for (int i = 1; i &lt;= m; ++i) { std::cin &gt;&gt; a[i] &gt;&gt; A &gt;&gt; B; for (int j = 0; j &lt; n; ++j) { if (A[j] == '+') b1[i] |= 1 &lt;&lt; j; else if (A[j] == '-') b2[i] |= 1 &lt;&lt; j; } for (int j = 0; j &lt; n; ++j) { if (B[j] == '-') f1[i] |= 1 &lt;&lt; j; else if (B[j] == '+') f2[i] |= 1 &lt;&lt; j; } } SPFA(); return 0;}","link":"/2019/03/02/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98-%E8%BD%AF%E4%BB%B6%E8%A1%A5%E4%B8%81/"}],"tags":[{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"概率","slug":"概率","link":"/tags/%E6%A6%82%E7%8E%87/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"计数","slug":"计数","link":"/tags/%E8%AE%A1%E6%95%B0/"},{"name":"SA","slug":"SA","link":"/tags/SA/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"SCC","slug":"SCC","link":"/tags/SCC/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"BIT","slug":"BIT","link":"/tags/BIT/"},{"name":"Leftist Tree","slug":"Leftist-Tree","link":"/tags/Leftist-Tree/"},{"name":"DSU on Tree","slug":"DSU-on-Tree","link":"/tags/DSU-on-Tree/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"不等式","slug":"不等式","link":"/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"容斥","slug":"容斥","link":"/tags/%E5%AE%B9%E6%96%A5/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"整体二分","slug":"整体二分","link":"/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"OGF","slug":"OGF","link":"/tags/OGF/"},{"name":"Gal","slug":"Gal","link":"/tags/Gal/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"状压","slug":"状压","link":"/tags/%E7%8A%B6%E5%8E%8B/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"categories":[{"name":"OI","slug":"OI","link":"/categories/OI/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"Games","slug":"Games","link":"/categories/Games/"},{"name":"MO","slug":"MO","link":"/categories/MO/"}]}