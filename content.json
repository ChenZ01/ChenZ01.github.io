{"pages":[{"title":"Friends","text":"Name Info FlyInTheSky 广东北江中学 Logey 临沂一中 redbag LG管理 skyofwar 江苏省丹阳高级中学 SiriusRen 北京邮电大学 Yirannn 吉林大学附属中学 多多良假伞 聊城一中","link":"/friends/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"About","text":"站点基于Hexo搭建，使用NexT.Pisces主题，使用GitHub Pages托管网页本站音乐播放器：APlayer，由DIYgod基于MIT License发布 个人初三，江苏省丹阳高级中学永远感谢Yirannn退役前的一番话语AFO = Always Firmly in OI","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"「AtCoder」 ABC 103","text":"题外话永远记住日本时间比中国早1个小时！这篇比较水，除了T3 题目链接AtCoder ABC 103 题解T1纯暴力不解释 代码1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a, b, c;#define X abs(a-b)#define Y abs(b-c)#define Z abs(a-c)int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; min(X + Y, min(X + Z, Y + Z)) &lt;&lt; endl; return 0;} T2纯暴力，字符串的函数需要熟悉一些 代码123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;string S, T;int main(int argc, char ** argv){ getline(cin, S); getline(cin, T); for (int i = S.length(); i; i--) { char ch = S[S.length() - 1]; S.erase(S.length() - 1, 1); S.insert(S.begin(), ch); if (S == T) { cout &lt;&lt; \"Yes\\n\"; return 0; } } cout &lt;&lt; \"No\\n\"; return 0;} T3这题真的是给Beginner做的？虽然代码比较短小精悍这题就是要我们证明对于序列${a_1,a_2,\\dots,a_n}$，存在$x\\equiv(a_k-1)(\\mathrm{mod}\\,a_k),1\\leqslant k\\leqslant n$当然，稍微想想会会发现$\\prod_{k=1}^na_k-1$即为满足上述条件的$x$既然存在$x$，则最大的$f$值就显而易见是$\\sum_{k=1}^n(a_k-1)=\\sum_{k=1}^na_k-n$那么就可以相当完美地解决这道题 代码123456789101112#include &lt;iostream&gt;using namespace std;int n, ans, a;int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a, ans += a; cout &lt;&lt; ans - n &lt;&lt; endl; return 0;} T4上来就想到DP，想了一会发现是贪心，然后我就跪在了sort()上……STL的东西最好还是了解怎么回事再用！贪心的思路很好想，具体看代码 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Edge{ int st, ed;};Edge a[100010];int n, m, ans;bool cmp(Edge x, Edge y){ if (x.ed == y.ed) return x.st &lt; y.st; else return x.ed &lt; y.ed;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i].st &gt;&gt; a[i].ed; sort(a + 1, a + m + 1, cmp); int Cur = 0; for (int i = 1; i &lt;= m; i++) { if (a[i].st &gt;= Cur) { ans++; Cur = a[i].ed; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 后记本篇博文相当水……当然也不是我故意的为了肝后面一篇重磅的数学博文，OI只能稍稍搁置一下了顺带说一句绝对不要对后面一篇博文抱有什么能看得懂的幻想","link":"/2018/07/23/AtCoder-ABC-103/"},{"title":"「AHOI2017初中组」 alter","text":"Link洛谷 3718 Solution由于对于一个答案我们很容易验证是否可行，考虑二分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int n, k, t;string st;int check(int x){ int len = 1, cnt = 0; for (int i = 1; i &lt; st.length(); ++i) { if (st[i] == st[i - 1]) ++len; else len = 1; if (len &gt; x) { ++cnt, len = 0; if (x &lt; 2) st[i] = st[i] == 'N' ? 'F' : 'N', ++len; } } if (cnt &lt;= k) return 1; else return 0;}int main(){ ios::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; st; int l = 1, r = n; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout &lt;&lt; l &lt;&lt; endl; return 0;}","link":"/2018/10/27/AHOI2017初中组-alter/"},{"title":"「Codeforces 767C」 Garland","text":"LinkCF767C Solution很显然，权值总和不为$3$倍数的话无解那么对于可将权值分成三份相等的情况，我们的工作就是分三棵子树使得每棵子树的权值和等于总和的三分之一我们可以自叶节点向根节点方向累加权值，遇到目前累加和符合条件的就记录一下重点来了：满足权值和条件的子树个数不一定等于3，因为有负权的存在假设有$4$棵子树的权值和都等于$w=W/3$，那么树上必定存在一部分其权值和等于$-w$由于我们是从下往上统计的，这部分一定处在最上面两棵子树之间。那么我们把这一部分与两个权值为$w$的子树合并，必然能得到3棵符合要求的子树因此最后的判断条件就是$cnt&gt;=3$ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, u, w, W, Root;int s[1000010];vector &lt;int&gt; tree[1000010];vector &lt;int&gt; cut;void dfs(int cur, int fr){ for (int i = 0; i &lt; tree[cur].size(); ++i) if (tree[cur][i] != fr) dfs(tree[cur][i], cur), s[cur]+= s[tree[cur][i]]; if (s[cur] == W) cut.push_back(cur), s[cur] = 0;}int main(){ ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; u &gt;&gt; w, s[i] = w, W += w; if (u) tree[u].push_back(i), tree[i].push_back(u); else Root = i; } if (W % 3) { cout &lt;&lt; -1 &lt;&lt; endl; return 0; } W /= 3, dfs(Root, Root); if (cut.size() &gt;= 3) cout &lt;&lt; cut[0] &lt;&lt; \" \" &lt;&lt; cut[1] &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;}","link":"/2018/10/25/Codeforces-767C-Garland/"},{"title":"「GCJ R1A 2008 C」 numbers","text":"题目链接GCJ R1A 2008 C总觉得Code Jam都需要科学方式访问是不是有些太过了 题解拿到手首先肯定不能暴力，于是我们考虑数学方法 分析对于这个式子：$(3+\\sqrt{5})^n$，一眼想到二项式定理，将其展开得：$$(3+\\sqrt{5})^n=C_n^03^n\\sqrt{5}^0+C_n^13^{n-1}\\sqrt{5}^1+\\dots+C_n^{n-1}3^1\\sqrt{5}^{n-1}+C_n^n3^0\\sqrt{5}^n$$不难发现若幂次为偶数，则$\\sqrt{5}$也会变成整数，那么我们可以将上面的式子写成如下形式：$$(3+\\sqrt{5})^n=f(n)+g(n)\\sqrt{5}$$$f(n)$即为展开式种所有运算结果为整数的部分的和仍然没法解决，我们再考虑另一个式子：$$(3-\\sqrt{5})^n=C_n^03^n\\sqrt{5}^0-C_n^13^{n-1}\\sqrt{5}^1+\\dots+(-1)^{n-1}C_n^{n-1}3^1\\sqrt{5}^{n-1}+(-1)^nC_n^n3^0\\sqrt{5}^n$$同理，可写成：$$(3-\\sqrt{5})^n=f(n)-g(n)\\sqrt{5}$$二式相加，得：$$(3+\\sqrt{5})^n+(3-\\sqrt{5})^n=2f(n)$$所以$$(3+\\sqrt{5})^n=2f(n)-(3-\\sqrt{5})^n$$考虑到$$0&lt;(3-\\sqrt{5})^n&lt;1$$而我们要求的是整数部分，那么完全可以写成$$\\lfloor(3+\\sqrt{5})^n\\rfloor=2f(n)-1$$ 求解$f$问题是这个$f$怎么求考虑以下递推式： \\begin{align}(3+\\sqrt{5})^{n+1}&amp;=(3+\\sqrt{5})(3+\\sqrt{5})^n\\\\&amp;=(3+\\sqrt{5})(f(n)+g(n)\\sqrt{5})\\\\&amp;=3f(n)+3\\sqrt{5}g(n)+\\sqrt{5}f(n)+5g(n)\\end{align}所以\\begin{align}f(n+1)=3f(n)+5g(n)\\\\g(n+1)=f(n)+3g(n)\\end{align}由此我们可以用矩阵快速幂解决 矩阵原始矩阵：\\begin{align}\\begin{bmatrix}f(0)\\\\g(0)\\end{bmatrix}=\\begin{bmatrix}1\\\\0\\end{bmatrix}\\end{align}递推的矩阵：\\begin{bmatrix}3&amp;5\\\\1&amp;3\\end{bmatrix}至此问题解决 代码printf()格式化真心强大1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#pragma warning(disable:4996)using namespace std;int T, n;struct Mat{ int r, c; int matrix[10][10];};Mat basmat;void init(){ basmat.c = basmat.r = 2; basmat.matrix[0][0] = 3, basmat.matrix[0][1] = 5; basmat.matrix[1][0] = 1, basmat.matrix[1][1] = 3;}Mat mul(Mat mat1, Mat mat2){ Mat tmat; memset(tmat.matrix, 0, sizeof tmat.matrix); tmat.r = mat1.r; tmat.c = mat2.c; for (int i = 0; i &lt; mat1.r; i++) for (int j = 0; j &lt; mat2.c; j++) for (int k = 0; k &lt; mat1.c; k++) tmat.matrix[i][j] = (tmat.matrix[i][j] + mat1.matrix[i][k] * mat2.matrix[k][j]) % 1000; return tmat;}void fastpow(int index){ Mat retmat; retmat.r = retmat.c = 2; retmat.matrix[0][0] = retmat.matrix[1][1] = 1; retmat.matrix[0][1] = retmat.matrix[1][0] = 0; while (index) { if (index &amp; 1) retmat = mul(retmat, basmat); basmat = mul(basmat, basmat); index &gt;&gt;= 1; } printf(\"%03d\\n\", ((retmat.matrix[0][0] &lt;&lt; 1) - 1) % 1000);}int main(int argc, char ** argv){ freopen(\"C-large-practice.in\", \"r\", stdin); freopen(\"C-large-practice.out\", \"w\", stdout); scanf(\"%d\", &amp;T); for (int TT = 1; TT &lt;= T; TT++) { scanf(\"%d\", &amp;n); init(); printf(\"Case #%d: \", TT); fastpow(n); } return 0;}","link":"/2018/09/02/GCJ-R1A-2008-C/"},{"title":"「BZOJ 1441」 Min - 裴蜀定理","text":"LinkBZOJ 1441 Solution第一发BZOJ题解，顺便改一下post标题格式 Analysis我们先不管$a_3\\dots a_n$，单看$a_1, a_2$方便起见我们令$a = a_1, b = a_2$那么很显然$a$与$b$的线性组合集中最小正元素即为$\\gcd(a, b)$现在我们考虑加入$c = a_3$，则它与$a, b$构造的最小解即为$\\gcd(c, \\gcd(a, b))$上面我们先考虑线性组合$a, b$，即我们按顺序构造解，正确性显然 裴蜀定理对于任意整数$a, b$，定有$\\gcd(a, b) | (ax + by)$ Proof有了该定理，我们更理性地看一下我们的做法首先对于两个整数$a, b$，其能构造出的最小正值为$\\gcd(a, b)$，且对于$a, b$线性组合集中的任意元素$k$，都有$\\gcd(a, b) | k$那么加入第三个数$c$，则肯定有$\\gcd(c, k) \\geq \\gcd(c, \\gcd(a, b))$推广至一般形式，对于已经处理出的最小解$s=\\gcd(a_1, a_2, \\dots, a_k)$以及另一个解$s’$，加入$a_{k + 1}$，则定有$$\\gcd(s’, a_{k + 1}) \\geq \\gcd(s, a_{k + 1})$$因此本题的$s$即为$\\gcd(a_1, a_2, \\dots, a_n)$ Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;inline void Read(int &amp;x){ x = 0; char ch = getchar(); int minu = 0; while (!isdigit(ch)) ch = getchar(), minu = ch == '-'; while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if (minu) x = -x;}int gcd(int x, int y){ return y ? gcd(y, x % y) : x;}int n, a, b, ans;int main(){ freopen(\"1441.in\", \"r\", stdin); freopen(\"1441.out\", \"w\", stdout); Read(n); Read(a); for (int i = 2; i &lt;= n; ++i) { Read(b); ans = (a = gcd(a, b)); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2018/11/21/BZOJ-1441/"},{"title":"GitHub 图床","text":"正文 create a repository clone 到本地 将想要上传的图片push 进入图床repository，找到你刚才push的图片 左键单击查看图片 在图片上右击-在新标签页中打开图片 复制图片url 该url即可直接调用 注意：以“https://github.com/” 开头的并不是你图片的url正常情况下url应以“https://raw.githubusercontent.com/” 开头在调用时严格区分大小写，包括文件扩展名的大小写！","link":"/2018/07/11/GitHub-图床/"},{"title":"「HDU 1166」 敌兵布阵","text":"题外话永远不要迷信快读！或许你认为手写read()很快，实际上在HDU上惨不忍睹！目前原因未知，知道的dalao欢迎email本蒟蒻目测是getchar()与换行符的锅 题目链接HDU 1166 题解明显线段树裸题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define local#ifdef local#pragma warning(disable:4996)#endifusing namespace std;int T, n, x, y, ans;int a[200010];int sum[200010];int add[200010];string st;void pushup(int root){ sum[root] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1];}void build(int l, int r, int root){ if (l == r) sum[root] = a[l]; else { int mid = (l + r) &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); }}void update(int l, int r, int root){ if (l == r) sum[root] += y; else { int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(l, mid, root &lt;&lt; 1); else update(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); }}void query(int l, int r, int root){ if (l &gt;= x &amp;&amp; r &lt;= y) { ans += sum[root]; return; } int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) query(l, mid, root &lt;&lt; 1); if (y &gt; mid) query(mid + 1, r, root &lt;&lt; 1 | 1);}void init(){ memset(sum, 0, sizeof sum); memset(add, 0, sizeof add); build(1, n, 1);}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; T; for (int T_T = 1; T_T &lt;= T; T_T++) { printf(\"Case %d:\\n\", T_T); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; init(); while (cin &gt;&gt; st) { ans = 0; if (st == \"End\") break; cin &gt;&gt; x &gt;&gt; y; if (st == \"Sub\") y *= -1; if (st == \"Query\") query(1, n, 1), printf(\"%d\\n\", ans); else update(1, n, 1); } } return 0;}","link":"/2018/08/07/HDU-1166/"},{"title":"「HDU 1698」Just a Hook","text":"题外话弃用cin（除了读long long的时候），改回scanf 题目链接HDU 1698 题解区间修改+区间求和，果断线段树区间修改注意不能退化成单点修改，需使用lazy-tag（即val数组） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;#pragma warning(disable:4996)int CASE, n, q, x, y, z;int sum[400010];int val[400010];void pushup(int root){ sum[root] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1];}void pushdown(int root, int len){ if (val[root]) { val[root &lt;&lt; 1] = val[root &lt;&lt; 1 | 1] = val[root]; sum[root &lt;&lt; 1] = val[root] * (len - (len &gt;&gt; 1)); sum[root &lt;&lt; 1 | 1] = val[root] * (len &gt;&gt; 1); val[root] = 0; }}void build(int l, int r, int root){ val[root] = 0; if (l == r) sum[root] = 1; else { int mid = (l + r) &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); }}void update(int l, int r, int root){ if (l &gt;= x &amp;&amp; r &lt;= y) sum[root] = z * (r - l + 1), val[root] = z; else { pushdown(root, r - l + 1); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(l, mid, root &lt;&lt; 1); if (y &gt; mid) update(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); }}int main(int argc, char ** argv){ scanf(\"%d\", &amp;CASE); for (int i = 1; i &lt;= CASE; i++) { scanf(\"%d%d\", &amp;n, &amp;q); build(1, n, 1); while (q--) { scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); update(1, n, 1); } printf(\"Case %d: The total value of the hook is %d.\\n\", i, sum[1]); } return 0;}","link":"/2018/08/19/HDU-1698/"},{"title":"「HEOI2015」 兔子与樱花","text":"Link洛谷 4107 Solution假设当前节点为$i$，则其某个子节点$j$被删除且不违背最大载重的话一定满足$$c_i+c_j-1\\leq m$$而且只需满足这个条件即可那么我们为了删除尽可能多的点，易想到贪心解决 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int n, m, tmp, son, ans;int c[2000010], k[2000010];vector &lt;int&gt; tree[2000010];bool cmp(const int &amp;x, const int &amp;y){ return c[x] &lt; c[y];}void dfs(int root){ int sze = tree[root].size(); if (!sze) return; for (int i = 0; i &lt; sze; ++i) dfs(tree[root][i]); sort(tree[root].begin(), tree[root].end(), cmp); for (register int i = 0; i &lt; sze; ++i) { if (c[root] + c[tree[root][i]] - 1 &lt;= m) c[root] += c[tree[root][i]] - 1, ++ans; else break; }}int main(){ ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; c[i]; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; tmp; c[i] += tmp; while (tmp--) cin &gt;&gt; son, tree[i].push_back(son); } dfs(0); cout &lt;&lt; ans &lt;&lt; endl; return 0;} Extra洛谷提交时记得开O2","link":"/2018/10/23/HEOI2015-兔子与樱花/"},{"title":"「POJ 1160」 Post Office","text":"题外话话说原本mathjax老是出故障的\\$\\$突然变正常了，开心~ 题目链接POJ 1160 大意在$V$个村庄里选$P$个作为邮局，使得每个村庄到距它最近的邮局的距离和最短。 题解裸典型的区间DP。设$f(i,j)$表示前$i$个村庄内建立$j$个邮局的最小距离和，最终答案即为$f(V,P)$。可以想到，前$i$个村庄内建立$j$个邮局即为前$k$个村庄建立$j-1$个邮局、第$k+1$到第$i$个村庄建一个邮局。设$w(i,j)$表示在村庄$i$、$j$之间建立一个邮局后，该邮局与村庄$i$、$j$的最短距离和。易得：$w(i,j)=w(i,j-1)+a(j)-a((i+j)/2)$。可能有人会问，如果$i+j$为偶，则位置能确定（$(i+j)/2\\in N^*$）；但若$i+j$为偶，是选$\\lceil (i+j)/2 \\rceil$还是$\\lfloor (i+j)/2 \\rfloor$呢？我们可以假设共有6个村庄，要在范围$[1..6]$内选择1个做邮局。根据上面疑问，我们分别选取$\\lceil (i+j)/2 \\rceil$即4与$\\lfloor (i+j)/2 \\rfloor$即3做比较。设每个村庄位置分别为$a_i$。 选取4。则总距离为：$$(a_4-a_1)+(a_4-a_2)+(a_4-a_3)+0+(a_5-a_4)+(a_6-a_4)=a_6+a_5+a_4-a_3-a_2-a_1$$ 选取3。则总距离为：$$(a_3-a_1)+(a_3-a_2)+0+(a_4-a_3)+(a_5-a_3)+(a_6-a_3)=a_6+a_5+a_4-a_3-a_2-a_1$$ 因此，可得当$i+j$为偶时，选$\\lceil (i+j)/2 \\rceil$与$\\lfloor (i+j)/2 \\rfloor$ 等价。计算$w$数组时可以用前缀和优化，在此不赘述。综上，不难得方程：$f(i,j)=min\\lbrace f(i,j),f(k,j-1)+w(k+1,j)\\rbrace$时间复杂度$O(pv^2)$ 代码 - 裸12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) { for (int j = i + 1; j &lt;= v; j++) { w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; } } memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) { f[i][i] = 0; f[i][1] = w[1][i]; } for (int j = 2; j &lt;= p; j++) { for (int i = j + 1; i &lt;= v; i++) { for (int k = j - 1; k &lt; i; k++) { f[i][j] = min(f[i][j], f[k][j - 1] + w[k + 1][i]);//注意别写到括号外面去 } } } cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;} 优化在这里，我们要用到一个叫做四边形不等式的东西。 四边形不等式此问题中包含着一个常见的状态转移方程：$$f(i,j)=min\\lbrace f(i,k-1)+f(k,j)+w(i,j)\\rbrace$$假如对于任意$i\\leq i’&lt;j\\leq j’$，都有$w(i’,j)\\leq w(i,j’)$，那么我们称函数$w$满足关于区间包含的单调性另外，假如有：$$w(i,j)+w(i’,j’)\\leq w(i’,j)+w(i,j’)$$那么我们称函数$w$满足四边形不等式。不等式较抽象，建议画图理解。理解后，我们引出两个定理：1、若上述函数$w$同时满足区间包含单调性与四边形不等式，那么函数$f$也满足四边形不等式，即：$$f(i,j)+f(i’,j’)\\leq f(i’,j)+f(i,j’),\\;i\\leq i’&lt;j\\leq j’$$我们再定义函数$s(i,j)$表示$f(i,j)$取得最优值时对应的$k$。此时有定理：2、若上述函数$f$满足四边形不等式，则函数$s$单调，即：$$s(i,j)\\leq s(i,j+1)\\leq s(i+1,j+1)$$得出结论2后，我们发现：$s(i,j-1)\\leq s(i,j)\\leq s(i+1,j)$因此函数$f$等价于：$$f(i,j)=min\\lbrace f(i,k-1)+f(k,j)+w(i,j)\\rbrace,\\;s(i,j-1)\\leq k\\leq s(i+1,j)$$ 回到问题理解四边形不等式后，我们发现：本题的$f$也满足四边形不等式（证明实在没力气了）。因此，本题可以优化成$O(vp)$。 代码 - 优化123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int v, p;int a[100001];int f[1001][1001];int w[1001][1001];int s[1001][1001];int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; v &gt;&gt; p; for (int i = 1; i &lt;= v; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= v; i++) { s[i][i] = i; for (int j = i + 1; j &lt;= v; j++) { w[i][j] = w[i][j - 1] + a[j] - a[(i + j) / 2]; } } memset(f, 0x7f7f7f7f, sizeof(f)); for (int i = 1; i &lt;= v; i++) f[i][1] = w[1][i]; for (int i = 1; i &lt;= p; i++) s[v + 1][i] = v;//计算可能越界 for (int i = 1; i &lt;= p; i++) { for (int j = v; j &gt; i; j--) { for (int k = s[j][i - 1]; k &lt;= s[j + 1][i]; k++) { if (f[j][i] &gt; f[k][i - 1] + w[k + 1][j]) { f[j][i] = f[k][i - 1] + w[k + 1][j]; s[j][i] = k; } } } } cout &lt;&lt; f[v][p] &lt;&lt; endl; return 0;}","link":"/2018/01/06/POJ-1160/"},{"title":"Hello, 2019!","text":"Goodbye, 2018! Hello, 2019! 20186月，第一次买了Office 3659月，进入江苏省丹阳高级中学拔尖创新人才预备班10月，第一次月考达到巅峰11月，胆大无比地向年纪主任要停课的时间11月，第一次NOIP提高组11月，NOIP后一天，期中考试爆炸12月，自己与一等奖的线只差了5分12月，某OIer的退役感想令我愣了半天12月，数学第一次没有涂答题卡12月，压抑不住自己对日本文学的好奇，偷偷地去买了本《罗生门》12月，第一次去看DC的电影Amber Heard小姐姐真好看12月，抛弃了Visual Studio，正式加入Visual Studio Code大军12月，可爱的老同学给我买了一份Cytus II 2019?三句话，继往开来 人生不如一行波德莱尔 艺术至上？学术至上？我希望做一个学术至上的人，但在2018，很显然并不是 人生悲剧的第一幕始于成为父母子女。遗传、境遇、偶然，掌握我们命运的，终究还是这三种东西 18年提高组，真是苦涩啊这是我第一次被“偶然”击败，月考的没涂答题卡是第二次震惊于自己的不佳状态，对不起，让你们失望了看到高二学长AFO，自己呢？声嘶力竭地吼着”Always Firmly in OI”，你有实力吗？ 人生就像一部缺了很多页的书，实在难以称之为书，但总算勉成一部 缺憾终究会有，2019，希望能少一些吧 Goodbye, 2018! Hello, 2019! 2019，A new ChenZ01","link":"/2019/01/01/Hello-2019/"},{"title":"「POJ 2823」 Sliding Window","text":"题外话这题提交方式很玄学……C++交就TLE，改成G++就AC了…… 题目链接POJ 2823 题解首先我们想到暴力模拟，妥妥的TLE，加上POJ老掉牙的机器，不知道T成什么样了……既然模拟不可行，那么我们只能考虑一种新的方法。目前我们貌似没有掌握一种算法能快速算区间最大值的，因此我们只能从数据结构入手。堆？你怎么确定元素是否超出窗口边界？用struct？那还怎么用STL的priority_queue？线段树？和堆一样的问题（怎么删除超出边界的元素）。我们发现，我们需要的是一种 能支持\\(O(1)\\)输出队列最大值 具有队列的一切功能（进队、出队） 要实现这两个功能，我们只能请出新的角色——单调队列 单调队列上文已经说明单调队列的作用了，接下来我们要讨论如何实现单调队列。首先队列清空（这里有个坑，留待你发掘）。遇到即将入队的新元素，将它与队尾元素比较，如果大于队尾元素就不断弹出队尾元素，直到队尾元素大于即将入队的元素位置。新元素进队。保证队列元素都在规定范围内：判断队首元素是否超过边界，若超过，就不断弹出队首元素，直到队首元素在规定范围内。规定范围内的最大值就是该队列的队首元素。由于要实现两端都能出队的队列，只能挥泪告别STL，迎接手写queue了…… 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, k;int a[1000005];int q[1000005];//队列int p[1000005];//下标struct Number{ int pos, val;}num[1000005];void SolBig(){ int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) { while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; } cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) { while (l &lt;= r&amp;&amp;q[r] &lt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; } cout &lt;&lt; endl;}void SolSml(){ int l = 1, r = 0; for (int i = 1; i &lt;= k; i++) { while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt; i - k) l++; } cout &lt;&lt; q[l]; for (int i = k + 1; i &lt;= n; i++) { while (l &lt;= r&amp;&amp;q[r] &gt;= a[i]) r--; q[++r] = a[i]; p[r] = i; while (p[l] &lt;= i - k) l++; cout &lt;&lt; ' ' &lt;&lt; q[l]; } cout &lt;&lt; endl;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; SolSml(); SolBig(); return 0;}","link":"/2017/11/26/POJ-2823/"},{"title":"「SDOI2006」 保安站岗","text":"Link洛谷 2458 Solution对于某个节点，其被覆盖的情况有三种： 被其父节点覆盖 被自己覆盖 被其子节点覆盖 那么我们可按以下方式转移：设$f(0/1/2,i)$表示节点$i$被父节点/本身/子节点覆盖且其子树全被覆盖的最小代价，设$j$为其子节点，易得方程$$f(0,i)=\\sum\\min\\lbrace f(1,j),f(2,j)\\rbrace$$$$f(1,i)=\\sum\\min\\lbrace f(0,j),f(1,j),f(2,j)\\rbrace$$$$f(2,i)=f(1,k)+\\sum_{j\\neq k}\\min\\lbrace f(1,j),f(2,j)\\rbrace,f(1,k)=\\min\\lbrace f(1,j)\\rbrace$$ $f(2,i)$转移的细节依然令$j$为$i$的一个子节点思路即取一个最优的子节点强制性的使用它的$f(1,j)$来转移，其余的取最优方案有个细节千万注意：并非$f(1,j)$最小的$j$为最优，反例即为该点的$f(2,j)$远小于该点的$f(1,j)$值也就是我们强制选择的点就是$f(1,j)-f(2,j)$最小的点以$x$记录上述值，$y$记录是否选过$f(1,j)&lt;f(2,j)$的点（$j$本身覆盖优于$j$的子节点覆盖）若$y=0$，那么我们必须加上一个最小的$f(1,j)-f(2,j)$，否则代表我们已经选过最优的这种点了，不作改动 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, numi, ordi, soni;int w[1510], f[3][1510];vector &lt;int&gt; tree[1510];void dfs(int cur, int fr){ int x = 0x7f7f7f7f, y = 0; f[1][cur] = w[cur]; for (int i = 0; i &lt; tree[cur].size(); ++i) { int to = tree[cur][i]; if (to != fr) { dfs(to, cur), f[0][cur] += min(f[1][to], f[2][to]), f[1][cur] += min(f[0][to], min(f[1][to], f[2][to])); if (f[1][to] &lt; f[2][to]) ++y; else x = min(x, f[1][to] - f[2][to]); f[2][cur] += min(f[1][to], f[2][to]); } } if (!y) f[2][cur] += x;}int main(){ ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; ordi &gt;&gt; w[ordi] &gt;&gt; numi; for (; numi; --numi) cin &gt;&gt; soni, tree[ordi].push_back(soni), tree[soni].push_back(ordi); } dfs(1, 0); cout &lt;&lt; min(f[1][1], f[2][1]) &lt;&lt; endl; return 0;}","link":"/2018/10/26/SDOI2006-保安站岗/"},{"title":"「SDOI2010」 古代猪文 - CRT + Lucas","text":"Link洛谷 2480 Solution题意即求$$G ^ {\\sum_{d | n}C_n^d}\\,\\mathrm{mod}\\,999911659$$ Step 1推广费马小定理可得$$G^{\\sum_{d | n}C_n^d\\,\\mathrm{mod}\\,999911659} = G^{\\sum_{d | n}C_n^d\\,\\mathrm{mod}\\,999911658}\\,\\mathrm{mod}\\,999911659$$ Step 2快速幂很好办，那么唯一的难点就是指数——模数不为质数，不能直接用Lucas Theorem再看一眼我们要求的指数$$\\sum_{d | n}C_n^d\\,\\mathrm{mod}\\,999911658$$对于$d$我们采用$O(\\sqrt{n})$的方式暴力枚举，然后呢……似乎我们已经走入穷途末路了…… Step 3方便起见令$s = \\sum_{d | n}C_n^d, x = s \\,\\mathrm{mod}\\,999911659$分解$999911658 = 2 \\cdot 3 \\cdot 4679 \\cdot 35617$令$a_1 = s\\,\\mathrm{mod}\\, 2, a_2 = s\\,\\mathrm{mod}\\, 3, a_3 = s\\,\\mathrm{mod}\\, 4679, a_4 = s\\,\\mathrm{mod}\\, 35617$我们可以得到\\begin{cases}x \\equiv a_1 (\\mathrm{mod}\\, 2)\\\\x \\equiv a_2 (\\mathrm{mod}\\, 3)\\\\x \\equiv a_3 (\\mathrm{mod}\\, 4679)\\\\x \\equiv a_3 (\\mathrm{mod}\\, 35617)\\end{cases}求解出$x$即为指数 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;#define MOD 999911659template &lt;class T&gt;void Read(T &amp;x){ x = 0; register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}long long n, g;long long frac[50010];void init(long long p){ frac[0] = 1; for (register long long i = 1; i &lt;= p; ++i) frac[i] = frac[i - 1] * i % p;}inline long long fastpow(long long base, long long index, long long p){ register long long ret = 1; while (index) { if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; } return ret;}inline long long inv(long long x, long long p){ return fastpow(x, p - 2, p);}inline long long C(long long x, long long y, long long p){ if (x &lt; y) return 0; else return frac[x] * inv(frac[y], p) * inv(frac[x - y], p) % p;}inline long long Lucas(long long x, long long y, long long p){ if (x &lt; y) return 0; else if (x &lt; p &amp;&amp; y &lt; p) return C(x, y, p); else return Lucas(x % p, y % p, p) * Lucas(x / p, y / p, p) % p;}inline long long CRT(vector &lt;long long&gt; &amp;a, vector &lt;long long&gt; &amp;b){ register long long ret = 0, m = MOD - 1; for (register int i = 0; i &lt; 4; ++i) ret = (ret + a[i] * (m / b[i]) % m * inv(m / b[i], b[i]) % m) % m; return (ret % m + m) % m;}inline long long sum(long long p){ vector &lt;long long&gt; a(4), b(4); b[0] = 2, b[1] = 3, b[2] = 4679, b[3] = 35617; for (register int j = 0; j &lt; 4; ++j) { init(b[j]); for (register int i = 1; i * i &lt;= n; ++i) { if (!(n % i)) { a[j] = (a[j] + Lucas(n, i, b[j])) % b[j]; if (i * i != n) a[j] = (a[j] + Lucas(n, n / i, b[j])) % b[j]; } } } return CRT(a, b) % p;}int main(){ Read(n), Read(g); if (!(g % MOD)) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; fastpow(g, sum(MOD), MOD)&lt;&lt; endl;}","link":"/2018/12/04/SDOI2010-古代猪文/"},{"title":"「SPOJ 1043」 GSS1","text":"题目链接源地址：SPOJ GSS1洛谷搬运：SP1043源地址访问太慢了啦！ 题解查询区间最大子段和，经典的模型（可是我今天才会） 分析很显然，一个长度大于$2$的区间的最大子段和只有可能是三种情况： 左区间的最大子段和 右区间的最大子段和 左区间的右区间的最大子段和+右区间的左区间的最大子段和 对于线段树表示区间$[L,R]$的第$i$个区间，我们定义 $S(i)$表示该区间的区间和 $L(i)$表示该区间前缀最大和 $R(i)$表示该区间后缀最大和 $M(i)$表示该区间最大子段和 $left_i$表示左区间 $right_i$表示右区间 由此我们显然有： $S(i)=S(left_i)+S(right_i)$ $L(i)=\\max(L(left_i)),S(left_i))+L(right_i))$ $R(i)=\\max(R(right_i),S(right_i)+R(left_i))$ $M(i)=\\max(M(left_i),M(right_i),R(left_i)+L(right_i))$ queryquery()函数比较特别，在此感谢Logey提供思路设当前即将查询的第$i$个区间为$[L,R]$，令$ans$表示该区间查询的结果，$rans$表示上一个访问过的区间的后缀最大和考虑到线段树是从左子树递归的，$rans$也可以理解为以$L-1$结尾的后缀最大和，即若当前区间完全被询问区间包含，那么修改$rans$的值，否则遍历左右子树，而右子树的$rans$完全可以从左子树的$rans$继承所以对于完全被询问区间包含的区间，我们有$ans=\\max(M(i),rans+L(i))$随后修改以便继续遍历：$rans=\\max(R(i),rans+S(i))$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, x, y, ans, rans;int a[50010];int L[200010], R[200010], M[200010], S[200010];void pushup(int root){ S[root] = S[root &lt;&lt; 1] + S[root &lt;&lt; 1 | 1]; L[root] = max(L[root &lt;&lt; 1], S[root &lt;&lt; 1] + L[root &lt;&lt; 1 | 1]); R[root] = max(R[root &lt;&lt; 1 | 1], S[root &lt;&lt; 1 | 1] + R[root &lt;&lt; 1]); M[root] = max(M[root &lt;&lt; 1], max(M[root &lt;&lt; 1 | 1], R[root &lt;&lt; 1] + L[root &lt;&lt; 1 | 1]));}void build(int l, int r, int root){ if (l == r) L[root] = R[root] = M[root] = S[root] = a[l]; else { int mid = (l + r) &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); }}void query(int l, int r, int root){ if (l &gt;= x &amp;&amp; r &lt;= y) { ans = max(ans, max(M[root], rans + L[root])); rans = max(R[root], rans + S[root]); } else { int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) query(l, mid, root &lt;&lt; 1); if (y &gt; mid) query(mid + 1, r, root &lt;&lt; 1 | 1); }}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); cin &gt;&gt; m; while (m--) { cin &gt;&gt; x &gt;&gt; y; ans = rans = -0x7f7f7f7f; query(1, n, 1); cout &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/2018/09/15/SPOJ-1043/"},{"title":"「SPOJ 2713」 GSS4","text":"题目链接源地址：SPOJ GSS4洛谷搬运：SP2713 题解又是一道假的紫题又是一道系列毒瘤题 分析显然开方操作不能打lazy-tag，对于每个修改我们只能直接单点或区间修改既然只能这么做，我们必须考虑开方操作的优化由于开方后再开方相当于四次根号，那么开了$n$次方的数所得结果就是$2^n$次根号，这个数一定不会大到哪里去事实上，$\\lfloor^{64}\\sqrt{10^{18}}\\rfloor=1$，因此超过$6$次开方的区间所有的数一定为$1$根据这个性质，我们有如下思想：对于将修改的区间$[L,R]$，若每个数都等于$1$（亦即区间和$=R-L+1$），这个区间无需操作，否则修改到点由于一个点最多被修改$6$次，复杂度可以接受 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;long long s[500010];long long n, q, tmp, op, ans;int x, y, cnt;void init(){ memset(s, 0, sizeof s);}void pushup(int root){ s[root] = s[root &lt;&lt; 1] + s[root &lt;&lt; 1 | 1];}void build(int l, int r, int root){ if (l == r) cin &gt;&gt; tmp, s[root] = tmp; else { int mid = l + r &gt;&gt; 1; build(l, mid, root &lt;&lt; 1); build(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); }}void update(int l, int r, int root){ if (s[root] &lt;= r - l + 1) return; if (l == r) s[root] = (long long)floor(sqrt(s[root])); else { int mid = l + r &gt;&gt; 1; if (x &lt;= mid) update(l, mid, root &lt;&lt; 1); if (y &gt; mid) update(mid + 1, r, root &lt;&lt; 1 | 1); pushup(root); }}void query(int l, int r, int root){ if (l &gt;= x &amp;&amp; r &lt;= y) ans += s[root]; else { int mid = l + r &gt;&gt; 1; if (x &lt;= mid) query(l, mid, root &lt;&lt; 1); if (y &gt; mid) query(mid + 1, r, root &lt;&lt; 1 | 1); }}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin.tie(0); while (cin &gt;&gt; n) { cout &lt;&lt; \"Case #\" &lt;&lt; ++cnt &lt;&lt; \":\" &lt;&lt; endl; init(); build(1, n, 1); cin &gt;&gt; q; while (q--) { cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (x &gt; y) swap(x, y); if (op) { ans = 0; query(1, n, 1); cout &lt;&lt; ans &lt;&lt; endl; } else { update(1, n, 1); } } cout &lt;&lt; endl; } return 0;}","link":"/2018/09/16/SPOJ-2713/"},{"title":"「SDOI2011」 计算器","text":"Link洛谷 2485 Solution1裸的快速幂取模 2令$d=\\gcd(a,n)$ 一个推论当且仅当$d|b$时，方程$ax\\equiv b(\\mathrm{mod}\\,n)$对于未知量$x$有解 一个定理假设对某些整数$x’$和$y’$，有$d=ax’+ny’$。若$d|b$，则方程$ax\\equiv b(\\mathrm{mod}\\,n)$的有一个解的值为$x_0$，这里$$x_0=x’(b/d)\\,\\mathrm{mod}\\,n$$ 证明根据$x’$的性质，即：$$ax\\equiv d(\\mathrm{mod}\\,n)$$可得：\\begin{align}ax_0&amp;\\equiv ax’(b/d)(\\mathrm{mod}\\,n)\\\\&amp;\\equiv d(b/d)(\\mathrm{mod}\\,n)\\\\&amp;\\equiv b(\\mathrm{mod}\\,n)\\end{align}因此$x_0$是方程$ax\\equiv b(\\mathrm{mod}\\,n)$的一个解 解决那么对于询问2，用扩欧求方程$ax’+ny’=d$即可注意根据上面的一个推论，当$d$不整除$b$时该方程无解 3我们引入一个概念—— 离散对数若$g$是$\\mathrm{Z}_n^*$的一个原根且$a$是$\\mathrm{Z}_n^*$中的任意元素，则存在一个$z$，使得$g^z\\equiv a(\\mathrm{mod}\\,n)$，则将$z$称为对模$n$到基$g$上的$a$的一个离散对数或指数说人话，也就是对于给定的$a,b,p$，存在一个$x$，使得$$a^x\\equiv b(\\mathrm{mod}\\,p)$$则称$x$为$b$在模$p$意义下以$a$为底的离散对数 很显然本题就是让我们求$y$的离散对数，常用方法叫做BSGS——Baby Step-Giant Step BSGS拿出我们要解的关于$x$的方程：$$a^x\\equiv b(\\mathrm{mod}\\,p)$$令$m=\\lceil \\sqrt{p}\\rceil$。根据费马小定理，有$a^{p-1}\\equiv 1(\\mathrm{mod}\\,p)$故若方程有解，则必存在一个$0\\leq x&lt;p-1$根据除法的定义，令$x=im+j$，方程可化为： \\begin{align}a^x&amp;\\equiv b(\\mathrm{mod}\\,p)\\\\a^{im+j}&amp;\\equiv b(\\mathrm{mod}\\,p)\\\\a^j&amp;\\equiv b\\cdot a^{-im}(\\mathrm{mod}\\,p)\\\\a^j&amp;\\equiv b\\cdot (a^{-m})^i(\\mathrm{mod}\\,p)\\end{align}得到这玩意，我们就只需找到一组$i,j$使得最后一个式子成立即可那么我们先枚举$j$，递推出左边$a^j\\,\\mathrm{mod}\\,p$的所有取值，并将其按照$(a^j\\,\\mathrm{mod}\\,p)\\mapsto j$的映射关系插入到哈希表中之后求出$a^m\\,\\mathrm{mod}\\,p$的乘法逆元，枚举$i$，递推出所有的$b\\cdot(a^{-m})^i$，每得到一个值后在哈希表内查找该值。若存在，取出对应的$j$，$x=im+j$即为一个解 Extra注意取模的时候可能有负数，并且应该先模$p$，具体见代码注释的那一行，卡了我35分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;long long T, K, y, z, p, gcd, X, Y;map &lt;long long, long long&gt; mp;inline long long fastpow(long long base, long long index){ long long ret = 1; while (index) { if (index &amp; 1) ret = ret * base % p; base = base * base % p; index &gt;&gt;= 1; } return ret;}inline void exgcd(long long a, long long b, long long &amp;d, long long &amp;x, long long &amp;y){ if (!b) d = a, x = 1, y = 0; else exgcd(b, a % b, d, y, x), y -= a / b * x;}inline long long inv(long long x){ return fastpow(x, p - 2);}inline long long bsgs(long long a, long long b){ if (!a) return b ? -1 : 1; mp.clear(); long long m = ceil(sqrt(p)), t = 1; for (long long i = 0; i &lt; m; i++) { if (!mp.count(t)) mp[t] = i; t = t * a % p; } long long k = inv(t), w = b; for (long long i = 0; i &lt; m; i++) { if (mp.count(w)) return i * m + mp[w]; w = w * k % p; } return -1;}int main(int argc, char ** argv){ ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); cin &gt;&gt; T &gt;&gt; K; while (T--) { cin &gt;&gt; y &gt;&gt; z &gt;&gt; p; if (K == 1) { cout &lt;&lt; fastpow(y, z) &lt;&lt; endl; } else if (K == 2) { exgcd(y, p, gcd, X, Y); if (z % gcd) cout &lt;&lt; \"Orz, I cannot find x!\" &lt;&lt; endl; else { cout &lt;&lt; (X * z / gcd % p + p) % p &lt;&lt; endl;//Important } } else { long long ans = bsgs(y % p, z % p); if (ans == -1) cout &lt;&lt; \"Orz, I cannot find x!\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; } } return 0;} 后记BSGS部分参考Menci的博客","link":"/2018/10/04/SDOI2011-计算器/"},{"title":"「SDOI2013」 随机数生成器 - BSGS","text":"Link洛谷 3306 Solution大力推式子 \\begin{align}X_{i + 1} &amp;\\equiv aX_i + b(\\mathrm{mod}\\,p)\\\\X_{i + 1} + \\frac{b}{a} &amp;\\equiv aX_i + b + \\frac{b}{a}(\\mathrm{mod}\\,p)\\\\aX_{i + 1} + b &amp;\\equiv a^2X_i + ab + b(\\mathrm{mod}\\,p)\\\\X_{i + 2} &amp;\\equiv a^2X_i + ab + b(\\mathrm{mod}\\,p)\\\\\\end{align} 那么我们得到 \\begin{align}X_2 &amp;\\equiv aX_1 + b(\\mathrm{mod}\\,p)\\\\X_3 &amp;\\equiv a ^ 2X_1 + ab + b(\\mathrm{mod}\\,p)\\\\X_4 &amp;\\equiv a ^ 3X_1 + a ^ 2b + ab + b(\\mathrm{mod}\\,p)\\\\\\dots\\\\X_i &amp;\\equiv a ^ {i - 1}X_1 + b\\sum_{j = 0} ^ {i - 2}a ^ j(\\mathrm{mod}\\,p)\\\\\\end{align} 也就是我们要判断如下方程是否有整数解，若有则求解 $$t \\equiv a ^ {i - 1}X_1 + b\\sum_{j = 0} ^ {i - 2}a ^ j(\\mathrm{mod}\\,p)$$ 继续化化化 \\begin{align}t &amp;\\equiv a ^ {i - 1}X_1 + b\\sum_{j = 0} ^ {i - 2}a ^ j(\\mathrm{mod}\\,p)\\\\t &amp;\\equiv a ^ {i - 1}X_1 + b\\frac{1 - a ^ {i - 1}}{1 - a}(\\mathrm{mod}\\,p)\\\\t &amp;\\equiv a ^ {i - 1}X_1 + \\frac{b}{1 - a} - \\frac{b}{1 - a} \\cdot a^{i - 1}(\\mathrm{mod}\\,p)\\\\t &amp;\\equiv a ^ {i - 1}(X_1 - \\frac{b}{1 - a}) + \\frac{b}{1 - a}(\\mathrm{mod}\\,p)\\\\a ^ {i - 1} &amp;\\equiv \\frac{t - \\frac{b}{1 - a}}{X_1 - \\frac{b}{1 - a}}(\\mathrm{mod}\\,p)\\\\\\end{align} 大功告成，用BSGS求解出$i - 1$的值，由于$t$是第$i$项，答案加一即可 Detail 1对于$X_1 = t$时，直接输出$1$ Detail 2对于$a = 0$时，$X_i = b$ Detail 3对于$a = 1$时，有$X_i \\equiv X_1 + b(i - 1)(\\mathrm{mod}\\,p)$那么求解$t - X_1 \\equiv b(i - 1)(\\mathrm{mod}\\,p)$的系数$i - 1$即可注意当答案就是$p$的时候不要再模$p$了 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;template &lt;class I&gt;inline void Read(I &amp;x){ register char ch = getchar(); for (; !isdigit(ch); ch = getchar()); for (x = 0; isdigit(ch); x = x * 10 + (ch ^ 48), ch = getchar());}long long NUMOFCASES, a, b, p, x, t, X, Y;long long fastpow(long long base, int index, int MOD){ register long long ret = 1; while (index) { if (index &amp; 1) ret = ret * base % MOD; base = base * base % MOD; index &gt;&gt;= 1; } return ret;}long long gcd(long long a, long long b){ return b ? gcd(b, a % b) : a;}long long inv(long long x, int MOD){ return fastpow(x, MOD - 2, MOD);}long long bsgs(long long a, long long b, int MOD){ a %= MOD, b %= MOD; std::map&lt;long long, long long&gt; map; register long long m = ceil(sqrt(MOD)), t = 1; for (register int i = 0; i &lt; m; ++i) { if (!map.count(t)) map[t] = i; t = t * a % MOD; } register long long k = inv(t, MOD), w = b; for (int i = 0; i &lt; m; ++i) { if (map.count(w)) return i * m + map[w]; w = w * k % MOD; } return -1;}int main(){ Read(NUMOFCASES); for (; NUMOFCASES; --NUMOFCASES) { Read(p), Read(a), Read(b), Read(x), Read(t); if (x == t) cout &lt;&lt; 1 &lt;&lt; endl; else if (a == 1) { t = (t - x + p) % p; if (t % gcd(b, p)) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; (t * inv(b, p) + 1 == p ? t * inv(b, p) + 1 : (t * inv(b, p) + 1) % p) &lt;&lt; endl; } else if (a == 0) { if (b == t) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; } else { long long ans = bsgs(a, ((t - b * inv(1 - a, p)) % p + p) % p * inv(((x - b * inv(1 - a, p)) % p + p) % p , p), p) % p; if (ans == -1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans + 1 &lt;&lt; endl; } }}","link":"/2018/12/04/SDOI2013-随机数生成器/"},{"title":"「TJOI2009」 猜数字","text":"Link洛谷 3868 Solution经典的Chinese Remainder Theorem例题然而我并不是被CRT卡的，细节较多考虑将方程组变形\\begin{cases}x\\equiv a_1(\\mathrm{mod}\\,b_1)\\\\x\\equiv a_2(\\mathrm{mod}\\,b_2)\\\\\\dots\\\\x\\equiv a_k(\\mathrm{mod}\\,b_k)\\end{cases}直接用CRT实现即可 Detail 1乘法会爆long long，须用快速龟速乘 Detail 2快读注意判负数 Detail 3$a_i$可能为负，为了方便实现，在使用时转为模$b_i$等价类的最小正元素 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;inline void Read(long long &amp;x){ x = 0; register char ch = getchar(); register int flag = 0; while (!isdigit(ch)) flag = (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if (flag) x = -x;}long long mul(long long a, long long b, long long MOD){ long long ret = 0; while (a) { if (a &amp; 1) (ret += b) %= MOD; (b += b) %= MOD; a &gt;&gt;= 1; } return ret;}long long k, s = 1, n;long long a[110], b[110];void exgcd(long long a, long long b, long long &amp;x, long long &amp;y){ if (!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x;}int main(){ Read(k); for (int i = 1; i &lt;= k; ++i) Read(a[i]); for (int i = 1; i &lt;= k; ++i) Read(b[i]), s *= b[i]; for (int i = 1; i &lt;= k; ++i) { register long long m = s / b[i], x, y; exgcd(m, b[i], x, y); (n += mul(mul((a[i] % b[i] + b[i]) % b[i], m, s), x, s)) %= s; } cout &lt;&lt; (n + s) % s &lt;&lt; endl; return 0;}","link":"/2018/11/16/TJOI2009-猜数字/"},{"title":"Ubuntu apt-get错误","text":"正文Problem在使用apt-get命令时，我意外的发现了以下错误： E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 网上查过很多人的博客，大体思路是找进程并杀之然而我查进程时竟发现没有apt-get进程于是我继续寻找，终于找到了正解： Solution1234sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/locksudo dpkg --configure -asudo apt-get update 问题即顺利解决","link":"/2018/08/20/Ubuntu-apt-get错误/"},{"title":"树状数组修改与查询","text":"正文我们将修改与查询问题归为四大类 单点修改，单点查询这就不用做了，无脑开数组或map 单点修改，区间查询这里的树状数组用法较基础，模板题目：洛谷 3374 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, x, y;long long s[1000010];inline void update(int pos, int add){ while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;}inline long long query(int pos){ long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t , update(i, t); while (q--) { cin &gt;&gt; t &gt;&gt; x &gt;&gt; y; if (t == 1) update(x, y); else cout &lt;&lt; query(y) - query(x - 1) &lt;&lt; endl; } return 0;} 区间修改，单点查询我们学习一个叫做差分的神奇东西简单来说，对于原数组$a,a_0=0$，定义差分数组$d$，其构造法则为：$$d_i=a_i-a_{i-1}$$可以发现：$$a_i=\\sum_{j=1}^id_j$$假设我们给区间$[l,r]$加上$k$，那么我们会发现$d_l$变大了$k$，$d_{r+1}$变小了$k$，其余的不变因此我们只需维护$d$数组的前缀和即可，树状数组可以很方便的维护依然送上模板题目：洛谷 3368 Code实现时要注意我们维护的是差分数组，因此在对树状数组的初始化时要注意update的元素1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, q, t, l, r, x, lst;long long s[1000010];void update(int pos, int add){ while (pos &lt;= n) s[pos] += add, pos += pos &amp; -pos;}long long query(int pos){ long long sum = 0; while (pos) sum += s[pos], pos -= pos &amp; -pos; return sum;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; while (q--) { cin &gt;&gt; t; if (t == 1) cin &gt;&gt; l &gt;&gt; r &gt;&gt; x, update(l, x), update(r + 1, -x); else cin &gt;&gt; x, cout &lt;&lt; query(x) &lt;&lt; endl; } return 0;} 区间修改，区间查询我们依然要用到差分，定义与上面的相同当我们查询区间$[l,r]$时，前缀和思想是非常清晰的：$$\\sum_{i=l}^ra_i=\\sum_{i=1}^ra_i-\\sum_{i=1}^{l-1}a_i$$对于一个单独的$\\sum_{i=1}^xa_i$，我们有：$$\\sum_{i=1}^xa_i=\\sum_{i=1}^x\\sum_{j=1}^id_j=\\sum_{i=1}^x(x-i+1)d_i$$再将其进行一个神奇的转换：$$\\sum_{i=1}^x(x-i+1)d_i=\\sum_{i=1}^x(x+1)d_i-\\sum_{i=1}^xid_i=(x+1)\\sum_{i=1}^xd_i-\\sum_{i=1}^xid_i$$所以我们可以维护两个树状数组，分别维护$d_i$和$id_i$即可每个询问区间的答案即是：$$\\sum_{i=1}^ra_i-\\sum_{i=1}^{l-1}a_i=(r+1)\\sum_{i=1}^rd_i-\\sum_{i=1}^rid_i-l\\sum_{i=1}^{l-1}d_i+\\sum_{i=1}^{l-1}id_i$$ Code维护时注意，第二个树状数组维护的是$id_i$，这意味着第一个树状数组update操作变化的值是$k$，那么第二个树状数组update操作变化的值是$ki$模板：POJ 3468千万注意数据规模可能超int，因此我选择整数运算和long long无异但范围比long long大的long double（其实没必要） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#pragma warning(disable:4996)int n, q, t, a, b, c, lst;char ch;long double s1[100010];long double s2[100010];void update(int pos, long long add){ int tpos = pos; while (pos &lt;= n) s1[pos] += add, s2[pos] += tpos * add, pos += pos &amp; -pos;}long long query(int pos){ long long sum = 0, tpos = pos; while (pos) sum += (tpos + 1)*s1[pos] - s2[pos], pos -= pos &amp; -pos; return sum;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; t, update(i, t - lst), lst = t; for (int i = 1; i &lt;= q; i++) { cin &gt;&gt; ch; if (ch == 'C') cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, update(a, c), update(b + 1, -c); else cin &gt;&gt; a &gt;&gt; b, cout &lt;&lt; query(b) - query(a - 1) &lt;&lt; endl; } return 0;}","link":"/2018/09/23/树状数组修改与查询/"},{"title":"「洛谷 1091」 合唱队形","text":"题外话最近都刷的什么垃圾题目啊……连我自己都不忍直视 题目链接洛谷 1091 题解在大意中已经写的很明显了，要求最少的不在原序列的元素个数。虽然读起来有些别扭，但仔细一想，可以转化成求最长符合条件的子序列的长度，再拿\\(n\\)减去该长度即可。再看题，符合条件的子序列是什么？满足“有且只有一个元素与其左边所有元素单调上升，与其右边所有元素单调下降”。明显是最长上升子序列和最长下降子序列的组合！我们可以把前\\(i\\)个元素变成一个序列并求最长上升子序列的长度，第\\(i+1\\)~第\\(n\\)个元素变成一个序列并求最长下降子序列的长度。设\\(f(i)\\)为取第\\(i\\)个元素的最长上升/下降子序列长度。得DP方程：\\(f(i)=max(f(i),f(j)+1),\\;a_i＜(＞)a_j,\\,j&lt;i\\) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n, ans;int a[1001], f[1001];void ms(){ memset(f, 0, sizeof(f));}bool judge(int op, int x, int y){ if (!op) return x &gt; y; else return x &lt; y;}int longest(int op, int x){ //若op=0，则求最长上升子序列长度，否则求最长下降子序列长度。 //C++中语句连起来可以写成 S1, S2, S3;的形式。 int st, ed; if (!op) st = 1, ed = x; else st = x, ed = n; ms(); for (int i = st; i &lt;= ed; i++) { f[i] = 1; for (int j = st; j &lt; i; j++) { if (judge(op, a[i], a[j])) f[i] = max(f[i], f[j] + 1); } } int tmp = -0x7f7f7f7f; for (int i = st; i &lt;= ed; i++) tmp = max(tmp, f[i]); return tmp;}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) ans = max(ans, longest(0, i) + longest(1, i+1)); cout &lt;&lt; n - ans &lt;&lt; endl; return 0;}","link":"/2017/07/29/洛谷-1091/"},{"title":"「洛谷 1281」 书的复制","text":"题外话写这篇博文的目的有两个，一是好久没有写关于OI的博文，二是某大佬说最好写一下提醒别人别被数据坑了……毕竟我被这题的神奇数据坑了2个多小时 题目链接洛谷 1281话说洛谷换新的url了 题解用一句非常精辟的话概括题意（不是我想出来的）：寻找一种分配方案，使抄写页数最多的最少很明显的二分就出来了不过二分只能找出答案，根据答案推每个人的任务还需要处理鉴于题目中说“尽可能让前面的人少抄写”，故从尾至头贪心，给后面的人分配的越多越好由于是从后往前分配任务的，输出是从前往后，于是采用栈记录输出的数据，当然也可以用递归输出 坑你以为就这样完了？我那3次WA就是这么来的……事实上，对于$m=0,k=0$的情况是不用输出的……真的巨坑啊…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;int m, k;int Max;int a[100001];stack &lt;int&gt; outl;stack &lt;int&gt; outr;bool judge(int t){ int sum = 0; int pseudo_peo = 1; for (int i = 1; i &lt;= m; i++) { if (a[i]&gt;t) return false; if (sum + a[i] &lt;= t) sum += a[i]; else { sum = a[i]; pseudo_peo++; } } return pseudo_peo &lt;= k;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); cin &gt;&gt; m &gt;&gt; k; if (!m &amp;&amp; !k) { return 0; } for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; a[i]; Max += a[i]; } int l = 1, r = Max; while (l&lt;r) { int mid = (l + r) / 2; if (judge(mid)) r = mid; else l = mid + 1; } int ans = l; int sum = 0; int cntpeop = k - 1; r = m; for (int i = m; i; i--) { if (sum + a[i] &lt;= ans &amp;&amp; i&gt;cntpeop) { sum += a[i]; l = i; } else { outl.push(l); outr.push(r); l = r = i; sum = a[i]; cntpeop--; } } cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; while (!outl.empty()) { cout &lt;&lt; outl.top() &lt;&lt; \" \" &lt;&lt; outr.top() &lt;&lt; endl; outl.pop(); outr.pop(); } return 0;}","link":"/2018/07/16/洛谷-1281/"},{"title":"「洛谷 1306」 斐波那契公约数","text":"题目链接洛谷 1306 题解数据范围是$10^9$，直接暴力显然不可取，因此我们考虑数学方法令$f(i)$表示斐波那契数列第$i$项 引理$$\\gcd(f(n),f(n+1))=1$$ 证： \\begin{align}\\gcd(f(n),f(n+1))&amp;=\\gcd(f(n),f(n+1)-f(n))\\\\&amp;=\\gcd(f(n),f(n-1))\\\\&amp;=\\gcd(f(n-2),f(n-1))\\\\&amp;\\dots\\\\&amp;=\\gcd(f(1),f(2))\\\\&amp;=1\\\\\\end{align} 结论与证明设$n&lt;m, f(n)=a, f(n+1)=b$则 $f(n+2)=a+b,f(n+3)=a+2b,\\dots,f(m)=f(m-n-1)a+f(m-n)b$$\\because f(n)=a,f(n+1)=b,f(m)=f(m-n-1)a+f(m-n)b$$\\therefore f(m)=f(m-n-1)\\cdot f(n)+f(m-n)\\cdot f(n+1)$$\\therefore\\gcd(f(n),f(m))=\\gcd(f(n),f(m-n-1)\\cdot f(n)+f(m-n)\\cdot f(n+1))$$\\therefore\\gcd(f(n),f(m))=\\gcd(f(n),f(m-n)\\cdot f(n+1))$$\\therefore\\gcd(f(n),f(m))=\\gcd(f(n),f(m-n))$$\\therefore\\gcd(f(n),f(m))=\\gcd(f(n),f(m\\,\\mathrm{mod}\\,n))$令$t=m\\,\\mathrm{mod}\\,n$则$\\gcd(f(n),f(m))=\\gcd(f(n),f(t))=\\gcd(f(t),f(n))$递归下去会发现这就是辗转相除，由此我们得到：$$\\gcd(f(n),f(m))=f(\\gcd(n,m))$$ 矩阵加速考虑我们需要将列向量\\begin{bmatrix}f(1)\\\\f(0)\\end{bmatrix}乘上一个矩阵$A$以转移到\\begin{bmatrix}f(2)\\\\f(1)\\end{bmatrix}实际上就是\\begin{align}\\begin{bmatrix}f(1)\\\\f(0)\\end{bmatrix}\\cdot\\begin{bmatrix}a_{11}&amp;a_{12}\\\\a_{21}&amp;a_{22}\\end{bmatrix}=\\begin{bmatrix}f(0)+f(1)\\\\f(1)\\end{bmatrix}\\end{align}易得：$$A=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}$$所以我们可以得到：\\begin{align}\\begin{bmatrix}f(n+1)\\\\f(n)\\end{bmatrix}=\\begin{bmatrix}1&amp;1\\\\1&amp;0\\end{bmatrix}^n\\cdot\\begin{bmatrix}f(1)\\\\f(0)\\end{bmatrix}\\end{align}化简可知$f(n)$即为乘方后矩阵的$a_{21}$过程采用矩阵快速幂 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Mat{ long long matrix[2][2]; int r, c;};Mat basmat;int n, m;long long gcd(long long x, long long y){ return y ? gcd(y, x%y) : x;}Mat mul(Mat mat1, Mat mat2){ Mat tmat; memset(tmat.matrix, 0, sizeof tmat.matrix); tmat.r = mat1.r; tmat.c = mat2.c; for (int i = 0; i &lt; mat1.r; i++) for (int j = 0; j &lt; mat2.c; j++) for (int k = 0; k &lt; mat1.c; k++) tmat.matrix[i][j] = (tmat.matrix[i][j] + mat1.matrix[i][k] * mat2.matrix[k][j]) % 100000000; return tmat; }void fastpow(int index){ Mat retmat; retmat.matrix[0][0] = retmat.matrix[1][1] = 1; retmat.matrix[0][1] = retmat.matrix[1][0] = 0; retmat.r = 2; retmat.c = 2; while (index) { if (index &amp; 1) retmat = mul(retmat, basmat); basmat = mul(basmat, basmat); index &gt;&gt;= 1; } cout &lt;&lt; retmat.matrix[1][0] &lt;&lt; endl; return;}void init(){ basmat.matrix[0][0] = basmat.matrix[0][1] = basmat.matrix[1][0] = 1; basmat.matrix[1][1] = 0; basmat.r = 2; basmat.c = 2;}int main(int argc, char ** argv){ ios::sync_with_stdio(false); init(); cin &gt;&gt; n &gt;&gt; m; fastpow(gcd(n, m)); return 0;}","link":"/2018/08/26/洛谷-1306/"},{"title":"「洛谷 1313」 计算系数","text":"前言感谢学长！虽然问了很多智障问题，占用了你宝贵的打游戏的时间由衷的感谢你！ 题目链接洛谷 1313本题亦是NOIP2011提高组D2T1 题解二项式定理展开拿到式子首先变个形（$y$在前太丑了）：$$(ax+by)^k$$二项式定理展开后，得：$$C_k^0(ax)^k(by)^0+C_k^1(ax)^{k-1}(by)^1+\\dots+C_n^k(ax)^0(by)^k$$由于$n+m=k$，可得$x^ny^m$项就是$C_k^m(ax)^{k-m}(by)^m$展开并合并，得：$$C_k^m\\cdot x^{k-m}y^m\\cdot a^{k-m}b^m$$ 分析$a^{k-m}b^m$用快速幂很好处理，我们的主要目标就是对$C_k^m$取模这里毫无疑问可以递推，但是数学题就纯数学！再将$C_k^m$写成定义式的形式：$$C_k^m=\\frac{k!}{m!(k-m)!}$$直接算阶乘long long也承受不了，那么继续使用数学方法 引理1$$\\frac{a}{b}\\,\\mathrm{mod}\\,p=ab^{-1}\\,\\mathrm{mod}\\,p$$其中$b^{-1}$表示$b$在模$p$（通常情况下$p$为质数，本题为$10007$）意义下关于$a$的乘法逆元且$b|a$ 证明这么简单的结论我竟然折腾了半天才搞出来……\\begin{align}\\frac{a}{b}b\\,\\mathrm{mod}\\,p&amp;=a\\,\\mathrm{mod}\\,p\\\\&amp;=ab^{-1}b\\,\\mathrm{mod}\\,p\\\\\\end{align}$\\therefore \\frac{a}{b}\\,\\mathrm{mod}\\,p=ab^{-1}\\,\\mathrm{mod}\\,p$ 继续分析根据引理1，有：$$C_k^m=\\frac{k!}{m!(k-m)!}=k![m!(k-m)!]^{-1}$$很显然我们要求$m!(k-m)!$的逆元，扩欧可以很好的做到这点（求之前先模一下）但是我们想要更有趣一些的做法啊 引理2若$p$为质数，$n\\perp p$，则$$n\\,\\mathrm{mod}\\,p,2n\\,\\mathrm{mod}\\,p\\dots (p-1)n\\,\\mathrm{mod}\\,p$$生成一个$1\\dots p-1$的排列 证明设存在$0&lt;a&lt;b&lt;p$使得$an\\,\\mathrm{mod}\\,p=bn\\,\\mathrm{mod}\\,p$则有$(a-b)n\\,\\mathrm{mod}\\,p=0$\\begin{align}&amp;\\therefore (a-b)n=kp\\\\&amp;\\because n\\perp p\\\\&amp;\\therefore (a-b)\\,\\mathrm{mod}\\,p=0\\\\&amp;\\because 0&lt;a,b&lt;p\\\\&amp;\\therefore a=b\\end{align}而这与$a&lt;b$矛盾$\\therefore \\nexists 0&lt;a&lt;b&lt;p$使得$an\\equiv bn(\\mathrm{mod}\\,p)$因此$n\\,\\mathrm{mod}\\,p,2n\\,\\mathrm{mod}\\,p\\dots (p-1)n\\,\\mathrm{mod}\\,p$生成一个$1\\dots p-1$的排列 引理3（费马小定理）$$n^{p-1}\\equiv 1(\\mathrm{mod}\\,p),\\,n\\perp p$$ 证明我为什么吃饱了撑的要来证明这个根据引理2，我们把这$p-1$个数乘起来，可得：\\begin{align}\\prod_{i=1}^{p-1}in&amp;\\equiv\\prod_{i=1}^{p-1}(in\\,\\mathrm{mod}\\,p)(\\mathrm{mod}\\,p)\\\\&amp;\\equiv(p-1)!\\end{align}即：$$(p-1)!n^{p-1}\\equiv(p-1)!(\\mathrm{mod}\\,p)$$$p$是质数，因此$\\gcd((p-1)!,p)=1$，故可将上式的$(p-1)!$消去，故得：$$n^{p-1}\\equiv 1(\\mathrm{mod}\\,p)$$ 对费马小定理的变形根据费马小定理，有$n^{p-1}\\equiv 1(\\mathrm{mod}\\,p),\\,n\\perp p$$\\therefore n\\cdot n^{p-2}\\equiv 1(\\mathrm{mod}\\,p)$$\\therefore n^{p-2}\\equiv \\frac{1}{n}(\\mathrm{mod}\\,p)$根据引理1，有：$$n^{p-2}\\equiv n^{-1}(\\mathrm{mod}\\,p)$$因此可以通过快速幂求$n^{p-2}$来求$n^{-1}$ 最后一步根据所有前置的分析，我们将式$k![m!(k-m)!]^{-1}$写成$(k![m!(k-m)!])^{p-2}$至此完美解决 总结前面太长了，这里总结一下先将要求的单项式拿出来：$$C_k^ma^{k-m}b^m$$然后对于$a$和$b$的幂次用快速幂解决对于$C_k^m$，写成$\\frac{k!}{m!(k-m)!}$后，对分母用快速幂求其逆元，分子直接阶乘求 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int a, b, k, n, m;long long ans;long long fastpow(int base, int index){ long long ret = 1; base %= 10007; while (index) { if (index &amp; 1) ret = ret * base % 10007; base = base * base % 10007; index &gt;&gt;= 1; } return ret;}long long frac(int x){ return x ? frac(x - 1) % 10007 * x % 10007 : 1;}long long C(int x, int y){ return frac(x) * fastpow(frac(y) * frac(x - y), 10005) % 10007;}int main(int argc, char ** argv){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; k &gt;&gt; n &gt;&gt; m; cout &lt;&lt; fastpow(a, k - m) % 10007 * fastpow(b, m) % 10007 * C(k, m) % 10007 &lt;&lt; endl; return 0;} 后记两个引理都是学长帮忙证出来的费马小定理的证明参考Concrete Mathematics，生成$p-1$的排列也是学长帮助证明的费马小定理变形参考プログラミングコンテストチャレンジブック","link":"/2018/09/29/洛谷-1313/"},{"title":"生日悖论的证明","text":"正文悖论描述若有$23$个人，则至少有两个人生日相同的概率要大于$50\\%$从引起逻辑矛盾的角度来说生日悖论并非一种悖论 证明设$P(n)$表示$n$个人中至少有两个人生日相同的概率计算$P(n)$不容易，我们可以通过计算$P(n)=1-\\overline{P}(n)$得到，其中$\\overline{P}(n)$是该$n$人中，每个人生日都不相同的概率在此声明：不考虑双胞胎、闰年等特殊情况假设$n&gt;365$，则根据鸽巢原理，得：$$\\overline{P}(n)=0,P(n)=1$$假设$n\\leq 365$，根据生日两两不相等，得：\\begin{align}\\overline{P}(n)&amp;=\\frac{365}{365}\\cdot(1-\\frac{1}{365})\\cdot(1-\\frac{2}{365})\\dots(1-\\frac{n-1}{365})\\\\&amp;=\\frac{365}{365}\\cdot\\frac{364}{365}\\dots\\frac{365-n+1}{365}\\\\&amp;=\\frac{365!}{365^n(365-n)!}\\end{align}故$$P(n)=1-\\overline{P}(n)=1-\\frac{365!}{365^n(365-n)!}$$用Maple 2018输出（数据大到爆炸），我们可以看到：$$P(10)=11.69\\%,P(23)=50.73\\%,P(60)=99.41\\%$$ 至此该命题得证","link":"/2018/08/20/生日悖论的证明/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"乱搞","slug":"乱搞","link":"/tags/乱搞/"},{"name":"GCJ","slug":"GCJ","link":"/tags/GCJ/"},{"name":"矩阵","slug":"矩阵","link":"/tags/矩阵/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"HDU","slug":"HDU","link":"/tags/HDU/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"POJ","slug":"POJ","link":"/tags/POJ/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"四边形不等式","slug":"四边形不等式","link":"/tags/四边形不等式/"},{"name":"单调队列","slug":"单调队列","link":"/tags/单调队列/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"洛谷","slug":"洛谷","link":"/tags/洛谷/"},{"name":"概率","slug":"概率","link":"/tags/概率/"}],"categories":[{"name":"OI","slug":"OI","link":"/categories/OI/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Math","slug":"Math","link":"/categories/Math/"}]}